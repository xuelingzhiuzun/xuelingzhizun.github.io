<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="这个课程是希望提供更多的 Node.js 实战机会，通过每一节精心安排的课程目标，让 Node.js 的初学者们可以循序渐进地，有目的有挑战地开展 Node.js 的学习。 alsotanggithub.com&#x2F;xuelingzhizun&#x2F;node-lessons">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.js 包教不会">
<meta property="og:url" content="http://example.com/2016/09/25/bjbh/index.html">
<meta property="og:site_name" content="XFNOTES">
<meta property="og:description" content="这个课程是希望提供更多的 Node.js 实战机会，通过每一节精心安排的课程目标，让 Node.js 的初学者们可以循序渐进地，有目的有挑战地开展 Node.js 的学习。 alsotanggithub.com&#x2F;xuelingzhizun&#x2F;node-lessons">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson2/1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson2/2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson2/3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson4/1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson4/2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson5/1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson5/2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson7/1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson10/1.png">
<meta property="og:image" content="https://github.com/alsotang/node-lessons/blob/master/lesson12/1.png">
<meta property="og:image" content="https://github.com/alsotang/node-lessons/blob/master/lesson12/2.png">
<meta property="og:image" content="https://github.com/alsotang/node-lessons/blob/master/lesson12/3.png">
<meta property="og:image" content="https://github.com/alsotang/node-lessons/blob/master/lesson12/4.png">
<meta property="og:image" content="https://github.com/alsotang/node-lessons/blob/master/lesson13/1.png">
<meta property="og:image" content="https://github.com/alsotang/node-lessons/blob/master/lesson13/2.png">
<meta property="og:image" content="https://github.com/alsotang/node-lessons/blob/master/lesson14/1.png">
<meta property="og:image" content="https://github.com/alsotang/node-lessons/blob/master/lesson15/1.png">
<meta property="og:image" content="https://github.com/Ricardo-Li/node-lessons/blob/master/lesson16/1.png">
<meta property="article:published_time" content="2016-09-25T10:08:00.000Z">
<meta property="article:modified_time" content="2018-01-07T11:40:14.000Z">
<meta property="article:author" content="xuefeng">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="node.js">
<meta property="article:tag" content="async">
<meta property="article:tag" content="express">
<meta property="article:tag" content="mocha">
<meta property="article:tag" content="session">
<meta property="article:tag" content="cookie">
<meta property="article:tag" content="包教不会">
<meta property="article:tag" content="module">
<meta property="article:tag" content="shoule">
<meta property="article:tag" content="istanbul">
<meta property="article:tag" content="正则表达式">
<meta property="article:tag" content="benchmark">
<meta property="article:tag" content="this">
<meta property="article:tag" content="闭包">
<meta property="article:tag" content="Mongodb">
<meta property="article:tag" content="Mongoose">
<meta property="article:tag" content="promise">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson2/1.png">

<link rel="canonical" href="http://example.com/2016/09/25/bjbh/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Node.js 包教不会 | XFNOTES</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XFNOTES</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-ategories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>ategories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/09/25/bjbh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xuefeng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XFNOTES">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Node.js 包教不会
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-25 18:08:00" itemprop="dateCreated datePublished" datetime="2016-09-25T18:08:00+08:00">2016-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-01-07 19:40:14" itemprop="dateModified" datetime="2018-01-07T19:40:14+08:00">2018-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node-js/" itemprop="url" rel="index"><span itemprop="name">node.js</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote><p>这个课程是希望提供更多的 Node.js 实战机会，通过每一节精心安排的课程目标，让 Node.js 的初学者们可以循序渐进地，有目的有挑战地开展 Node.js 的学习。</p>
<footer><strong>alsotang</strong><cite><a target="_blank" rel="noopener" href="https://github.com/xuelingzhizun/node-lessons">github.com/xuelingzhizun/node-lessons</a></cite></footer></blockquote>
<a id="more"></a>
<h1 id="《一个最简单的-express-应用》"><a href="#《一个最简单的-express-应用》" class="headerlink" title="《一个最简单的 express 应用》"></a>《一个最简单的 express 应用》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson1 项目，在其中编写代码。当在浏览器中访问 <code>http://localhost:3000/</code> 时，输出 <code>Hello World</code>。</p>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>访问 <code>http://localhost:3000/</code> 时，输出 <code>你好，世界</code>。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>包管理器 npm 。使用 npm 安装包，并自动安装所需依赖。</li>
<li>框架 express 。学习新建 express 实例，并定义 routes ，产生输出。</li>
</ol>
<h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>按照惯例，我们来个 helloworld 入门。</p>
<h3 id="包管理器-npm"><a href="#包管理器-npm" class="headerlink" title="包管理器 npm"></a>包管理器 npm</h3><p>npm 可以自动管理包的依赖. 只需要安装你想要的包, 不必考虑这个包的依赖包.</p>
<p>在 PHP 中, 包管理使用的 <code>Composer</code>, python 中，包管理使用 <code>easy_install</code> 或者 <code>pip</code>，ruby 中我们使用 <code>gem</code>。而在 Node.js 中，对应就是 <code>npm</code>，npm 是 <code>Node.js Package Manager</code> 的意思。</p>
<h3 id="框架-Express"><a href="#框架-Express" class="headerlink" title="框架 Express"></a>框架 Express</h3><p>express 是 Node.js 应用最广泛的 web 框架，现在是 4.x 版本，它非常薄。跟 Rails 比起来，完全两个极端。</p>
<p>express 的官网是 <a target="_blank" rel="noopener" href="http://expressjs.com/">http://expressjs.com/</a> ，我常常上去看它的 API。</p>
<p>首先我们需要得到一个 express。</p>
<p>不同于 ruby 的 gem 装在全局，Node.js 的依赖是以项目为单位管理的，直接就安装在项目的 <code>node_modules</code> 目录下，而且每个依赖都可以有指定版本的其他依赖，这些依赖像一棵树一样。根据我自己的使用经验来说，npm 的体验在 pip 和 gem 之上。</p>
<p>OK，新建一个文件夹叫 lesson1 的，进去里面安装 express</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lesson1 &amp;&amp; cd lesson1</span><br><span class="line"># 这里没有从官方 npm 安装，而是使用了大淘宝的 npm 镜像</span><br><span class="line">$ npm install express --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>安装完成后，我们的 lesson1 目录下应该会出现一个 <code>node_modules</code> 文件夹，<code>ls</code> 看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls node_modules</span><br></pre></td></tr></table></figure>

<p>里面如果出现 express 文件夹则说明安装成功。</p>
<p>或者 npm命令提供更清晰直观的显示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list</span><br></pre></td></tr></table></figure>

<p>我们继续应用程序的编写。</p>
<p>新建一个 app.js 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch app.js</span><br></pre></td></tr></table></figure>

<p>copy 进去这些代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这句的意思就是引入 `express` 模块，并将它赋予 `express` 这个变量等待使用。</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用 express 实例，它是一个函数，不带参数调用时，会返回一个 express 实例，将这个变量赋予 app 变量。</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// app 本身有很多方法，其中包括最常用的 get、post、put/patch、delete，在这里我们调用其中的 get 方法，为我们的 `/` 路径指定一个 handler 函数。</span></span><br><span class="line"><span class="comment">// 这个 handler 函数会接收 req 和 res 两个对象，他们分别是请求的 request 和 response。</span></span><br><span class="line"><span class="comment">// request 中包含了浏览器传来的各种信息，比如 query 啊，body 啊，headers 啊之类的，都可以通过 req 对象访问到。</span></span><br><span class="line"><span class="comment">// res 对象，我们一般不从里面取信息，而是通过它来定制我们向浏览器输出的信息，比如 header 信息，比如想要向浏览器输出的内容。这里我们调用了它的 #send 方法，向浏览器输出一个字符串。</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义好我们 app 的行为之后，让它监听本地的 3000 端口。这里的第二个函数是个回调函数，会在 listen 动作成功后执行，我们这里执行了一个命令行输出操作，告诉我们监听动作已完成。</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;app is listening at port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行</p>
<p><code>$ node app.js</code></p>
<p>这时候我们的 app 就跑起来了，终端中会输出 <code>app is listening at port 3000</code>。这时我们打开浏览器，访问 <code>http://localhost:3000/</code>，会出现 <code>Hello World</code>。如果没有出现的话，肯定是上述哪一步弄错了，自己调试一下。</p>
<h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>在这个例子中，node代码监听了3000端口，用户通过访问<code>http://localhost:3000/</code> 得到了内容，为什么呢？</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口的作用：<code>通过端口来区分出同一电脑内不同应用或者进程，从而实现一条物理网线(通过分组交换技术-比如internet)同时链接多个程序</code><br><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Port_(computer_networking)">Port_(computer_networking)</a></p>
<p>端口号是一个 16位的 uint, 所以其范围为 1 to 65535 (对TCP来说, port 0 被保留，不能被使用. 对于UDP来说, source端的端口号是可选的， 为0时表示无端口).</p>
<p><code>app.listen(3000)</code>，进程就被打标，电脑接收到的3000端口的网络消息就会被发送给我们启动的这个进程</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p><a target="_blank" rel="noopener" href="http://www.ietf.org/rfc/rfc1738.txt">RFC1738</a> 定义的url格式笼统版本<code>&lt;scheme&gt;:&lt;scheme-specific-part&gt;</code>，<br>scheme有我们很熟悉的<code>http</code>、<code>https</code>、<code>ftp</code>，以及著名的<code>ed2k</code>，<code>thunder</code>。</p>
<p>通常我们熟悉的url定义成这个样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;&#x2F;&lt;url-path&gt;</span><br></pre></td></tr></table></figure>
<p>用过ftp的估计能体会这么长的，网页上很少带auth信息，所以就精简成这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;:&#x2F;&#x2F;&lt;host&gt;:&lt;port&gt;&#x2F;&lt;url-path&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中, scheme=http, host=localhost, port=3000, url-path=/, 再联想对照一下浏览器端<code>window.location</code>对象。<br>著名的<code>localhost</code>，你可以在电脑的hosts文件上找到</p>
<p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/URI_scheme">在这篇文章中提到</a>： <code>URI schemes are frequently and incorrectly referred to as &quot;protocols&quot;, or specifically as URI protocols or URL protocols, since most were originally designed to be used with a particular protocol, and often have the same name</code>，比较认同这个观点，尤其是今天移动设备的时代里， android和ios的开发中大量使用uri作为跨app通讯通道，把scheme理解为协议略狭隘了。</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>在了解完端口和url之后，再去看例子代码，相信应该好理解很多。<br>有必要的话，还可以在解刨一下express的use逻辑，对峙<code>http.createServer</code>，相信还有火花，:)</p>
<h1 id="《学习使用外部模块》"><a href="#《学习使用外部模块》" class="headerlink" title="《学习使用外部模块》"></a>《学习使用外部模块》</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson2 项目，在其中编写代码。</p>
<p>当在浏览器中访问 <code>http://localhost:3000/?q=alsotang</code> 时，输出 <code>alsotang</code> 的 md5 值，即 <code>bdd5e57b5c0040f9dc23d430846e68a3</code>。</p>
<h2 id="挑战-1"><a href="#挑战-1" class="headerlink" title="挑战"></a>挑战</h2><p>访问 <code>http://localhost:3000/?q=alsotang</code> 时，输出 <code>alsotang</code> 的 sha1 值，即 <code>e3c766d71667567e18f77869c65cd62f6a1b9ab9</code>。</p>
<h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>学习 req.query 的用法</li>
<li>学习建立 package.json 来管理 Node.js 项目。</li>
</ol>
<h2 id="课程内容-1"><a href="#课程内容-1" class="headerlink" title="课程内容"></a>课程内容</h2><p>卧槽，不写 package.json 就写项目我觉得好不爽啊，所以这个 lesson2 我就得跟大家介绍一下 package.json 这个文件的用法了。</p>
<p>简单说来呢，这个 package.json 文件就是定义了项目的各种元信息，包括项目的名称，git repo 的地址，作者等等。最重要的是，其中定义了我们项目的依赖，这样这个项目在部署时，我们就不必将 <code>node_modules</code> 目录也上传到服务器，服务器在拿到我们的项目时，只需要执行 <code>npm install</code>，则 npm 会自动读取 package.json 中的依赖并安装在项目的 <code>node_modules</code> 下面，然后程序就可以在服务器上跑起来了。</p>
<p>本课程的每个 lesson 里面的示例代码都会带上一份 package.json，大家可以去看看它的大概样子。</p>
<p>我们来新建一个 lesson2 项目，并生成一份它的 package.json。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lesson2 &amp;&amp; cd lesson2</span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure>

<p>OK，这时会要求我们输入一些信息，乱填就好了，反正这个地方也不用填依赖关系。</p>
<p><code>npm init</code> 这个命令的作用就是帮我们互动式地生成一份最简单的 package.json 文件，<code>init</code> 是 <code>initialize</code> 的意思，初始化。</p>
<p>当乱填信息完毕之后，我们的目录下就会有个 package.json 文件了。</p>
<p>这时我们来安装依赖，这次的应用，我们依赖 <code>express</code> 和 <code>utility</code> 两个模块。</p>
<p><code>$ npm install express utility --save</code></p>
<p>这次的安装命令与上节课的命令有两点不同，一是没有指定 registry，没有指定的情况下，默认从 npm 官方安装，上次我们是从淘宝的源安装的。二是多了个 <code>--save</code> 参数，这个参数的作用，就是会在你安装依赖的同时，自动把这些依赖写入 package.json。命令执行完成之后，查看 package.json，会发现多了一个 <code>dependencies</code> 字段，如下图：</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson2/1.png"></p>
<p>这时查看 <code>node_modules</code> 目录，会发现有两个文件夹，分别是 express 和 utility</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson2/2.png"></p>
<p>我们开始写应用层的代码，建立一个 <code>app.js</code> 文件，复制以下代码进去：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> utility = <span class="built_in">require</span>(<span class="string">&#x27;utility&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 express 实例</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从 req.query 中取出我们的 q 参数。</span></span><br><span class="line">  <span class="comment">// 如果是 post 传来的 body 数据，则是在 req.body 里面，不过 express 默认不处理 body 中的信息，需要引入 https://github.com/expressjs/body-parser 这个中间件才会处理，这个后面会讲到。</span></span><br><span class="line">  <span class="comment">// 如果分不清什么是 query，什么是 body 的话，那就需要补一下 http 的知识了</span></span><br><span class="line">  <span class="keyword">var</span> q = req.query.q;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 utility.md5 方法，得到 md5 之后的值</span></span><br><span class="line">  <span class="comment">// 之所以使用 utility 这个库来生成 md5 值，其实只是习惯问题。每个人都有自己习惯的技术堆栈，</span></span><br><span class="line">  <span class="comment">// 我刚入职阿里的时候跟着苏千和朴灵混，所以也混到了不少他们的技术堆栈，仅此而已。</span></span><br><span class="line">  <span class="comment">// utility 的 github 地址：https://github.com/node-modules/utility</span></span><br><span class="line">  <span class="comment">// 里面定义了很多常用且比较杂的辅助方法，可以去看看</span></span><br><span class="line">  <span class="keyword">var</span> md5Value = utility.md5(q);</span><br><span class="line"></span><br><span class="line">  res.send(md5Value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;app is running at port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>OK，运行我们的程序</p>
<p><code>$ node app.js</code></p>
<p>访问 <code>http://localhost:3000/?q=alsotang</code>，完成。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>如果直接访问 <code>http://localhost:3000/</code> 会抛错</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson2/3.png"></p>
<p>可以看到，这个错误是从 <code>crypto.js</code> 中抛出的。</p>
<p>这是因为，当我们不传入 <code>q</code> 参数时，<code>req.query.q</code> 取到的值是 <code>undefined</code>，<code>utility.md5</code> 直接使用了这个空值，导致下层的 <code>crypto</code> 抛错。</p>
<h1 id="《使用-superagent-与-cheerio-完成简单爬虫》"><a href="#《使用-superagent-与-cheerio-完成简单爬虫》" class="headerlink" title="《使用 superagent 与 cheerio 完成简单爬虫》"></a>《使用 superagent 与 cheerio 完成简单爬虫》</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson3 项目，在其中编写代码。</p>
<p>当在浏览器中访问 <code>http://localhost:3000/</code> 时，输出 CNode(<a target="_blank" rel="noopener" href="https://cnodejs.org/">https://cnodejs.org/</a> ) 社区首页的所有帖子标题和链接，以 json 的形式。</p>
<p>输出示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;【公告】发招聘帖的同学留意一下这里&quot;</span>,</span><br><span class="line">    <span class="string">&quot;href&quot;</span>: <span class="string">&quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&quot;</span>,</span><br><span class="line">    <span class="string">&quot;href&quot;</span>: <span class="string">&quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="挑战-2"><a href="#挑战-2" class="headerlink" title="挑战"></a>挑战</h2><p>访问 <code>http://localhost:3000/</code> 时，输出包括主题的作者，</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;【公告】发招聘帖的同学留意一下这里&quot;</span>,</span><br><span class="line">    <span class="string">&quot;href&quot;</span>: <span class="string">&quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;alsotang&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&quot;</span>,</span><br><span class="line">    <span class="string">&quot;href&quot;</span>: <span class="string">&quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;otheruser&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>学习使用 superagent 抓取网页</li>
<li>学习使用 cheerio 分析网页</li>
</ol>
<h2 id="课程内容-2"><a href="#课程内容-2" class="headerlink" title="课程内容"></a>课程内容</h2><p>Node.js 总是吹牛逼说自己异步特性多么多么厉害，但是对于初学者来说，要找一个能好好利用异步的场景不容易。我想来想去，爬虫的场景就比较适合，没事就异步并发地爬几个网站玩玩。</p>
<p>本来想教大家怎么爬 github 的 api 的，但是 github 有 rate limit 的限制，所以只好牺牲一下 CNode 社区（国内最专业的 Node.js 开源技术社区），教大家怎么去爬它了。</p>
<p>我们这回需要用到三个依赖，分别是 express，superagent 和 cheerio。</p>
<p>先介绍一下，</p>
<p>superagent(<a target="_blank" rel="noopener" href="http://visionmedia.github.io/superagent/">http://visionmedia.github.io/superagent/</a> ) 是个 http 方面的库，可以发起 get 或 post 请求。</p>
<p>cheerio(<a target="_blank" rel="noopener" href="https://github.com/cheeriojs/cheerio">https://github.com/cheeriojs/cheerio</a> ) 大家可以理解成一个 Node.js 版的 jquery，用来从网页中以 css selector 取数据，使用方式跟 jquery 一样一样的。</p>
<p>还记得我们怎么新建一个项目吗？</p>
<ol>
<li>新建一个文件夹，进去之后 <code>npm init</code></li>
<li>安装依赖 <code>npm install --save PACKAGE_NAME</code></li>
<li>写应用逻辑</li>
</ol>
<p>我们应用的核心逻辑长这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用 superagent 去抓取 https://cnodejs.org/ 的内容</span></span><br><span class="line">  superagent.get(<span class="string">&#x27;https://cnodejs.org/&#x27;</span>)</span><br><span class="line">    .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, sres</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 常规的错误处理</span></span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> next(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// sres.text 里面存储着网页的 html 内容，将它传给 cheerio.load 之后</span></span><br><span class="line">      <span class="comment">// 就可以得到一个实现了 jquery 接口的变量，我们习惯性地将它命名为 `$`</span></span><br><span class="line">      <span class="comment">// 剩下就都是 jquery 的内容了</span></span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(sres.text);</span><br><span class="line">      <span class="keyword">var</span> items = [];</span><br><span class="line">      $(<span class="string">&#x27;#topic_list .topic_title&#x27;</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">idx, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $element = $(element);</span><br><span class="line">        items.push(&#123;</span><br><span class="line">          title: $element.attr(<span class="string">&#x27;title&#x27;</span>),</span><br><span class="line">          href: $element.attr(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      res.send(items);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>OK，一个简单的爬虫就是这么简单。这里我们还没有利用到 Node.js 的异步并发特性。不过下两章内容都是关于异步控制的。</p>
<p>记得好好看看 superagent 的 API，它把链式调用的风格玩到了极致。</p>
<h1 id="《使用-eventproxy-控制并发》"><a href="#《使用-eventproxy-控制并发》" class="headerlink" title="《使用 eventproxy 控制并发》"></a>《使用 eventproxy 控制并发》</h1><h2 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson4 项目，在其中编写代码。</p>
<p>代码的入口是 <code>app.js</code>，当调用 <code>node app.js</code> 时，它会输出 CNode(<a target="_blank" rel="noopener" href="https://cnodejs.org/">https://cnodejs.org/</a> ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。</p>
<p>输出示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;【公告】发招聘帖的同学留意一下这里&quot;</span>,</span><br><span class="line">    <span class="string">&quot;href&quot;</span>: <span class="string">&quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;</span>,</span><br><span class="line">    <span class="string">&quot;comment1&quot;</span>: <span class="string">&quot;呵呵呵呵&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&quot;</span>,</span><br><span class="line">    <span class="string">&quot;href&quot;</span>: <span class="string">&quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;comment1&quot;</span>: <span class="string">&quot;沙发！&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="挑战-3"><a href="#挑战-3" class="headerlink" title="挑战"></a>挑战</h2><p>以上文目标为基础，输出 <code>comment1</code> 的作者，以及他在 cnode 社区的积分值。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;【公告】发招聘帖的同学留意一下这里&quot;</span>,</span><br><span class="line">    <span class="string">&quot;href&quot;</span>: <span class="string">&quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;</span>,</span><br><span class="line">    <span class="string">&quot;comment1&quot;</span>: <span class="string">&quot;呵呵呵呵&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author1&quot;</span>: <span class="string">&quot;auser&quot;</span>,</span><br><span class="line">    <span class="string">&quot;score1&quot;</span>: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>体会 Node.js 的 callback hell 之美</li>
<li>学习使用 eventproxy 这一利器控制并发</li>
</ol>
<h2 id="课程内容-3"><a href="#课程内容-3" class="headerlink" title="课程内容"></a>课程内容</h2><p><em>注意，cnodejs.org 网站有并发连接数的限制，所以当请求发送太快的时候会导致返回值为空或报错。建议一次抓取3个主题即可。文中的40只是为了方便讲解</em></p>
<p>这一章我们来到了 Node.js 最牛逼的地方——异步并发的内容了。</p>
<p>上一课我们介绍了如何使用 superagent 和 cheerio 来取主页内容，那只需要发起一次 http get 请求就能办到。但这次，我们需要取出每个主题的第一条评论，这就要求我们对每个主题的链接发起请求，并用 cheerio 去取出其中的第一条评论。</p>
<p>CNode 目前每一页有 40 个主题，于是我们就需要发起 1 + 40 个请求，来达到我们这一课的目标。</p>
<p>后者的 40 个请求，我们并发地发起：），而且不会遇到多线程啊锁什么的，Node.js 的并发模型跟多线程不同，抛却那些观念。更具体一点的话，比如异步到底为何异步，Node.js 为何单线程却能并发这类走近科学的问题，我就不打算讲了。对于这方面有兴趣的同学，强烈推荐 @朴灵 的 《九浅一深Node.js》： <a target="_blank" rel="noopener" href="http://book.douban.com/subject/25768396/">http://book.douban.com/subject/25768396/</a> 。</p>
<p>有些逼格比较高的朋友可能听说过 promise 和 generator 这类概念。不过我呢，只会讲 callback，主要原因是我个人只喜欢 callback。</p>
<p>这次课程我们需要用到三个库：superagent cheerio eventproxy(<a target="_blank" rel="noopener" href="https://github.com/JacksonTian/eventproxy">https://github.com/JacksonTian/eventproxy</a> )</p>
<p>手脚架的工作各位自己来，我们一步一步来一起写出这个程序。</p>
<p>首先 app.js 应该长这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventproxy = <span class="built_in">require</span>(<span class="string">&#x27;eventproxy&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> superagent = <span class="built_in">require</span>(<span class="string">&#x27;superagent&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"><span class="comment">// url 模块是 Node.js 标准库里面的</span></span><br><span class="line"><span class="comment">// http://nodejs.org/api/url.html</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cnodeUrl = <span class="string">&#x27;https://cnodejs.org/&#x27;</span>;</span><br><span class="line"></span><br><span class="line">superagent.get(cnodeUrl)</span><br><span class="line">  .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> topicUrls = [];</span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(res.text);</span><br><span class="line">    <span class="comment">// 获取首页所有的链接</span></span><br><span class="line">    $(<span class="string">&#x27;#topic_list .topic_title&#x27;</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">idx, element</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> $element = $(element);</span><br><span class="line">      <span class="comment">// $element.attr(&#x27;href&#x27;) 本来的样子是 /topic/542acd7d5d28233425538b04</span></span><br><span class="line">      <span class="comment">// 我们用 url.resolve 来自动推断出完整 url，变成</span></span><br><span class="line">      <span class="comment">// https://cnodejs.org/topic/542acd7d5d28233425538b04 的形式</span></span><br><span class="line">      <span class="comment">// 具体请看 http://nodejs.org/api/url.html#url_url_resolve_from_to 的示例</span></span><br><span class="line">      <span class="keyword">var</span> href = url.resolve(cnodeUrl, $element.attr(<span class="string">&#x27;href&#x27;</span>));</span><br><span class="line">      topicUrls.push(href);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(topicUrls);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>运行 <code>node app.js</code></p>
<p>输出如下图：</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson4/1.png"></p>
<p>OK，这时候我们已经得到所有 url 的地址了，接下来，我们把这些地址都抓取一遍，就完成了，Node.js 就是这么简单。</p>
<p>抓取之前，还是得介绍一下 eventproxy 这个库。</p>
<p>用 js 写过异步的同学应该都知道，如果你要并发异步获取两三个地址的数据，并且要在获取到数据之后，对这些数据一起进行利用的话，常规的写法是自己维护一个计数器。</p>
<p>先定义一个 <code>var count = 0</code>，然后每次抓取成功以后，就 <code>count++</code>。如果你是要抓取三个源的数据，由于你根本不知道这些异步操作到底谁先完成，那么每次当抓取成功的时候，就判断一下 <code>count === 3</code>。当值为真时，使用另一个函数继续完成操作。</p>
<p>而 eventproxy 就起到了这个计数器的作用，它来帮你管理到底这些异步操作是否完成，完成之后，它会自动调用你提供的处理函数，并将抓取到的数据当参数传过来。</p>
<p>假设我们不使用 eventproxy 也不使用计数器时，抓取三个源的写法是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考 jquery 的 $.get 的方法</span></span><br><span class="line">$.get(<span class="string">&quot;http://data1_source&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data1</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">  $.get(<span class="string">&quot;http://data2_source&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">    $.get(<span class="string">&quot;http://data3_source&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data3</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// something</span></span><br><span class="line">      <span class="keyword">var</span> html = fuck(data1, data2, data3);</span><br><span class="line">      render(html);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述的代码大家都写过吧。先获取 data1，获取完成之后获取 data2，然后再获取 data3，然后 fuck 它们，进行输出。</p>
<p>但大家应该也想到了，其实这三个源的数据，是可以并行去获取的，data2 的获取并不依赖 data1 的完成，data3 同理也不依赖 data2。</p>
<p>于是我们用计数器来写，会写成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  $.get(<span class="string">&#x27;http://data1_source&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    result.data1 = data;</span><br><span class="line">    count++;</span><br><span class="line">    handle();</span><br><span class="line">    &#125;);</span><br><span class="line">  $.get(<span class="string">&#x27;http://data2_source&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    result.data2 = data;</span><br><span class="line">    count++;</span><br><span class="line">    handle();</span><br><span class="line">    &#125;);</span><br><span class="line">  $.get(<span class="string">&#x27;http://data3_source&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    result.data3 = data;</span><br><span class="line">    count++;</span><br><span class="line">    handle();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> html = fuck(result.data1, result.data2, result.data3);</span><br><span class="line">      render(html);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><del>丑的一逼，</del>也不算丑，主要我写代码好看。</p>
<p>如果我们用 eventproxy，写出来是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ep = <span class="keyword">new</span> eventproxy();</span><br><span class="line">ep.all(<span class="string">&#x27;data1_event&#x27;</span>, <span class="string">&#x27;data2_event&#x27;</span>, <span class="string">&#x27;data3_event&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data1, data2, data3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> html = fuck(data1, data2, data3);</span><br><span class="line">  render(html);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.get(<span class="string">&#x27;http://data1_source&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  ep.emit(<span class="string">&#x27;data1_event&#x27;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">$.get(<span class="string">&#x27;http://data2_source&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  ep.emit(<span class="string">&#x27;data2_event&#x27;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">$.get(<span class="string">&#x27;http://data3_source&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  ep.emit(<span class="string">&#x27;data3_event&#x27;</span>, data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>好看多了是吧，也就是个高等计数器嘛。</p>
<p><code>ep.all(&#39;data1_event&#39;, &#39;data2_event&#39;, &#39;data3_event&#39;, function (data1, data2, data3) &#123;&#125;);</code></p>
<p>这一句，监听了三个事件，分别是 <code>data1_event, data2_event, data3_event</code>，每次当一个源的数据抓取完成时，就通过 <code>ep.emit()</code> 来告诉 <code>ep</code> 自己，某某事件已经完成了。</p>
<p>当三个事件未同时完成时，<code>ep.emit()</code> 调用之后不会做任何事；当三个事件都完成的时候，就会调用末尾的那个回调函数，来对它们进行统一处理。</p>
<p>eventproxy 提供了不少其他场景所需的 API，但最最常用的用法就是以上的这种，即：</p>
<ol>
<li>先 <code>var ep = new eventproxy();</code> 得到一个 eventproxy 实例。</li>
<li>告诉它你要监听哪些事件，并给它一个回调函数。<code>ep.all(&#39;event1&#39;, &#39;event2&#39;, function (result1, result2) &#123;&#125;)</code>。</li>
<li>在适当的时候 <code>ep.emit(&#39;event_name&#39;, eventData)</code>。</li>
</ol>
<p>eventproxy 这套处理异步并发的思路，我一直觉得就像是汇编里面的 goto 语句一样，程序逻辑在代码中随处跳跃。本来代码已经执行到 100 行了，突然 80 行的那个回调函数又开始工作了。如果你异步逻辑复杂点的话，80 行的这个函数完成之后，又激活了 60 行的另外一个函数。并发和嵌套的问题虽然解决了，但老祖宗们消灭了几十年的 goto 语句又回来了。</p>
<p>至于这套思想糟糕不糟糕，我个人倒是觉得还是不糟糕，用熟了看起来蛮清晰的。不过 js 这门渣渣语言本来就乱嘛，什么变量提升（<a target="_blank" rel="noopener" href="http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html">http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html</a> ）啊，没有 main 函数啊，变量作用域啊，数据类型常常简单得只有数字、字符串、哈希、数组啊，这一系列的问题，都不是事儿。</p>
<p>编程语言美丑啥的，咱心中有佛就好。</p>
<p>回到正题，之前我们已经得到了一个长度为 40 的 <code>topicUrls</code> 数组，里面包含了每条主题的链接。那么意味着，我们接下来要发出 40 个并发请求。我们需要用到 eventproxy 的 <code>#after</code> API。</p>
<p>大家自行学习一下这个 API 吧：<a target="_blank" rel="noopener" href="https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C">https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C</a></p>
<p>我代码就直接贴了哈。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到 topicUrls 之后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个 eventproxy 的实例</span></span><br><span class="line"><span class="keyword">var</span> ep = <span class="keyword">new</span> eventproxy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令 ep 重复监听 topicUrls.length 次（在这里也就是 40 次） `topic_html` 事件再行动</span></span><br><span class="line">ep.after(<span class="string">&#x27;topic_html&#x27;</span>, topicUrls.length, <span class="function"><span class="keyword">function</span> (<span class="params">topics</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// topics 是个数组，包含了 40 次 ep.emit(&#x27;topic_html&#x27;, pair) 中的那 40 个 pair</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始行动</span></span><br><span class="line">  topics = topics.map(<span class="function"><span class="keyword">function</span> (<span class="params">topicPair</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接下来都是 jquery 的用法了</span></span><br><span class="line">    <span class="keyword">var</span> topicUrl = topicPair[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> topicHtml = topicPair[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(topicHtml);</span><br><span class="line">    <span class="keyword">return</span> (&#123;</span><br><span class="line">      title: $(<span class="string">&#x27;.topic_full_title&#x27;</span>).text().trim(),</span><br><span class="line">      href: topicUrl,</span><br><span class="line">      comment1: $(<span class="string">&#x27;.reply_content&#x27;</span>).eq(<span class="number">0</span>).text().trim(),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;final:&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(topics);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">topicUrls.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">topicUrl</span>) </span>&#123;</span><br><span class="line">  superagent.get(topicUrl)</span><br><span class="line">    .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;fetch &#x27;</span> + topicUrl + <span class="string">&#x27; successful&#x27;</span>);</span><br><span class="line">      ep.emit(<span class="string">&#x27;topic_html&#x27;</span>, [topicUrl, res.text]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出长这样：</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson4/2.png"></p>
<p>完整的代码请查看 lesson4 目录下的 app.js 文件</p>
<h1 id="《使用-async-控制并发》"><a href="#《使用-async-控制并发》" class="headerlink" title="《使用 async 控制并发》"></a>《使用 async 控制并发》</h1><h2 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson5 项目，在其中编写代码。</p>
<p>代码的入口是 <code>app.js</code>，当调用 <code>node app.js</code> 时，它会输出 CNode(<a target="_blank" rel="noopener" href="https://cnodejs.org/">https://cnodejs.org/</a> ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。</p>
<p>注意：与上节课不同，并发连接数需要控制在 5 个。</p>
<p>输出示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;【公告】发招聘帖的同学留意一下这里&quot;</span>,</span><br><span class="line">    <span class="string">&quot;href&quot;</span>: <span class="string">&quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;</span>,</span><br><span class="line">    <span class="string">&quot;comment1&quot;</span>: <span class="string">&quot;呵呵呵呵&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&quot;</span>,</span><br><span class="line">    <span class="string">&quot;href&quot;</span>: <span class="string">&quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;comment1&quot;</span>: <span class="string">&quot;沙发！&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>学习 async(<a target="_blank" rel="noopener" href="https://github.com/caolan/async">https://github.com/caolan/async</a> ) 的使用。这里有个详细的 async demo 演示：<a target="_blank" rel="noopener" href="https://github.com/alsotang/async_demo">https://github.com/alsotang/async_demo</a></li>
<li>学习使用 async 来控制并发连接数。</li>
</ol>
<h2 id="课程内容-4"><a href="#课程内容-4" class="headerlink" title="课程内容"></a>课程内容</h2><p>lesson4 的代码其实是不完美的。为什么这么说，是因为在 lesson4 中，我们一次性发了 40 个并发请求出去，要知道，除去 CNode 的话，别的网站有可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的 IP 封掉。</p>
<p>我们在写爬虫的时候，如果有 1000 个链接要去爬，那么不可能同时发出 1000 个并发链接出去对不对？我们需要控制一下并发的数量，比如并发 10 个就好，然后慢慢抓完这 1000 个链接。</p>
<p>用 async 来做这件事很简单。</p>
<p>这次我们要介绍的是 async 的 <code>mapLimit(arr, limit, iterator, callback)</code> 接口。另外，还有个常用的控制并发连接数的接口是 <code>queue(worker, concurrency)</code>，大家可以去 <a target="_blank" rel="noopener" href="https://github.com/caolan/async#queueworker-concurrency">https://github.com/caolan/async#queueworker-concurrency</a> 看看说明。</p>
<p>这回我就不带大家爬网站了，我们来专注知识点：并发连接数控制。</p>
<p>对了，还有个问题是，什么时候用 eventproxy，什么时候使用 async 呢？它们不都是用来做异步流程控制的吗？</p>
<p>我的答案是：</p>
<p>当你需要去多个源(一般是小于 10 个)汇总数据的时候，用 eventproxy 方便；当你需要用到队列，需要控制并发数，或者你喜欢函数式编程思维时，使用 async。大部分场景是前者，所以我个人大部分时间是用 eventproxy 的。</p>
<p>正题开始。</p>
<p>首先，我们伪造一个 <code>fetchUrl(url, callback)</code> 函数，这个函数的作用就是，当你通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetchUrl(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something with `content`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>调用它时，它会返回 <code>http://www.baidu.com</code> 的页面内容回来。</p>
<p>当然，我们这里的返回内容是假的，返回延时是随机的。并且在它被调用时，会告诉你它现在一共被多少个地方并发调用着。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发连接数的计数器</span></span><br><span class="line"><span class="keyword">var</span> concurrencyCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fetchUrl = <span class="function"><span class="keyword">function</span> (<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// delay 的值在 2000 以内，是个随机的整数</span></span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">parseInt</span>((<span class="built_in">Math</span>.random() * <span class="number">10000000</span>) % <span class="number">2000</span>, <span class="number">10</span>);</span><br><span class="line">  concurrencyCount++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;现在的并发数是&#x27;</span>, concurrencyCount, <span class="string">&#x27;，正在抓取的是&#x27;</span>, url, <span class="string">&#x27;，耗时&#x27;</span> + delay + <span class="string">&#x27;毫秒&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    concurrencyCount--;</span><br><span class="line">    callback(<span class="literal">null</span>, url + <span class="string">&#x27; html content&#x27;</span>);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们接着来伪造一组链接</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">  urls.push(<span class="string">&#x27;http://datasource_&#x27;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这组链接的长这样：</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson5/1.png"></p>
<p>接着，我们使用 <code>async.mapLimit</code> 来并发抓取，并获取结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.mapLimit(urls, <span class="number">5</span>, <span class="function"><span class="keyword">function</span> (<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  fetchUrl(url, callback);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;final:&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行输出是这样的：</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson5/2.png"></p>
<p>可以看到，一开始，并发链接数是从 1 开始增长的，增长到 5 时，就不再增加。当其中有任务完成时，再继续抓取。并发连接数始终控制在 5 个。</p>
<p>完整代码请参见 app.js 文件。</p>
<h1 id="《测试用例：mocha，should，istanbul》"><a href="#《测试用例：mocha，should，istanbul》" class="headerlink" title="《测试用例：mocha，should，istanbul》"></a>《测试用例：mocha，should，istanbul》</h1><h2 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson6 项目，在其中编写代码。</p>
<p>main.js: 其中有个 fibonacci 函数。fibonacci 的介绍见：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Fibonacci_number">http://en.wikipedia.org/wiki/Fibonacci_number</a> 。</p>
<p>此函数的定义为 <code>int fibonacci(int n)</code></p>
<ul>
<li>当 n === 0 时，返回 0；n === 1时，返回 1;</li>
<li>n &gt; 1 时，返回 <code>fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)</code>，如 <code>fibonacci(10) === 55</code>;</li>
<li>n 不可大于10，否则抛错，因为 Node.js 的计算性能没那么强。</li>
<li>n 也不可小于 0，否则抛错，因为没意义。</li>
<li>n 不为数字时，抛错。</li>
</ul>
<p>test/main.test.js: 对 main 函数进行测试，并使行覆盖率和分支覆盖率都达到 100%。</p>
<h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>学习使用测试框架 mocha : <a target="_blank" rel="noopener" href="http://mochajs.org/">http://mochajs.org/</a></li>
<li>学习使用断言库 should : <a target="_blank" rel="noopener" href="https://github.com/tj/should.js">https://github.com/tj/should.js</a></li>
<li>学习使用测试率覆盖工具 istanbul : <a target="_blank" rel="noopener" href="https://github.com/gotwarlost/istanbul">https://github.com/gotwarlost/istanbul</a></li>
<li>简单 Makefile 的编写 : <a target="_blank" rel="noopener" href="http://blog.csdn.net/haoel/article/details/2886">http://blog.csdn.net/haoel/article/details/2886</a></li>
</ol>
<h2 id="课程内容-5"><a href="#课程内容-5" class="headerlink" title="课程内容"></a>课程内容</h2><p>首先，作为一个 Node.js 项目，先执行 <code>npm init</code> 创建 package.json。</p>
<p>其次，建立我们的 main.js 文件，编写 <code>fibonacci</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">require</span>.main === <span class="built_in">module</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果是直接执行 main.js，则进入此处</span></span><br><span class="line">  <span class="comment">// 如果 main.js 被其他文件 require，则此处不会执行。</span></span><br><span class="line">  <span class="keyword">var</span> n = <span class="built_in">Number</span>(process.argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fibonacci(&#x27;</span> + n + <span class="string">&#x27;) is&#x27;</span>, fibonacci(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，这只是个简单的实现。</p>
<p>我们可以执行试试</p>
<p><code>$ node main.js 10</code></p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/1.png"></p>
<p>嗯，结果是 55，符合预期。</p>
<p>接下来我们开始测试驱动开发，现在简单的实现已经完成，那我们就对它进行一下简单测试吧。</p>
<p>我们先得把 main.js 里面的 fibonacci 暴露出来，这个简单。加一句</p>
<p><code>exports.fibonacci = fibonacci;</code>（要是看不懂这句就去补补 Node.js 的基础知识吧）</p>
<p>就好了。</p>
<p>然后我们在 <code>test/main.test.js</code> 中引用我们的 main.js，并开始一个简单的测试。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: test/main.test.js</span></span><br><span class="line"><span class="keyword">var</span> main = <span class="built_in">require</span>(<span class="string">&#x27;../main&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> should = <span class="built_in">require</span>(<span class="string">&#x27;should&#x27;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;test/main.test.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&#x27;should equal 55 when n === 10&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    main.fibonacci(<span class="number">10</span>).should.equal(<span class="number">55</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>把测试先跑通，我们再讲这段测试代码的含义。</p>
<p>装个全局的 mocha: <code>$ npm install mocha -g</code>。</p>
<p><code>-g</code> 与 非<code>-g</code> 的区别，就是安装位置的区别，g 是 global 的意思。如果不加的话，则安装 mocha 在你的项目目录下面；如果加了，则这个 mocha 是安装在全局的，如果 mocha 有可执行命令的话，那么这个命令也会自动加入到你系统 $PATH 中的某个地方（在我的系统中，是这里 <code>/Users/alsotang/.nvm/v0.10.29/bin</code>）</p>
<p>在 lesson6 目录下，直接执行</p>
<p><code>$ mocha</code></p>
<p>输出应如下</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/2.png"></p>
<p>那么，代码中的 describe 和 it 是什么意思呢？其实就是 BDD 中的那些意思，把它们当做语法来记就好了。</p>
<p>大家来看看 nodeclub 中，关于 topicController 的测试文件：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js">https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js</a></p>
<p>这文件的内容没有超出之前课程的范围吧。</p>
<p><code>describe</code> 中的字符串，用来描述你要测的主体是什么；<code>it</code> 当中，描述具体的 case 内容。</p>
<p>而引入的那个 should 模块，是个断言库。玩过 ruby 的同学应该知道 <code>rspec</code>，rspec 它把测试框架和断言库的事情一起做了，而在 Node.js 中，这两样东西的作用分别是 mocha 和 should 在协作完成。</p>
<p>should 在 js 的 Object “基类”上注入了一个 <code>#should</code> 属性，这个属性中，又有着许许多多的属性可以被访问。</p>
<p>比如测试一个数是不是大于3，则是 <code>(5).should.above(3)</code>；测试一个字符串是否有着特定前缀：<code>&#39;foobar&#39;.should.startWith(&#39;foo&#39;);</code>。should.js API 在：<a target="_blank" rel="noopener" href="https://github.com/tj/should.js">https://github.com/tj/should.js</a></p>
<p>should.js 如果现在还是 version 3 的话，我倒是推荐大家去看看它的 API 和 源码；现在 should 是 version 4 了，API 丑得很，但为了不掉队，我还是一直用着它。我觉得 expect 麻烦，所以不用 expect，对了，expect 也是一个断言库：<a target="_blank" rel="noopener" href="https://github.com/LearnBoost/expect.js/">https://github.com/LearnBoost/expect.js/</a> 。</p>
<p>回到正题，还记得我们 fibonacci 函数的几个要求吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 当 n &#x3D;&#x3D;&#x3D; 0 时，返回 0；n &#x3D;&#x3D;&#x3D; 1时，返回 1;</span><br><span class="line">* n &gt; 1 时，返回 &#96;fibonacci(n) &#x3D;&#x3D;&#x3D; fibonacci(n-1) + fibonacci(n-2)&#96;，如 &#96;fibonacci(10) &#x3D;&#x3D;&#x3D; 55&#96;;</span><br><span class="line">* n 不可大于10，否则抛错，因为 Node.js 的计算性能没那么强。</span><br><span class="line">* n 也不可小于 0，否则抛错，因为没意义。</span><br><span class="line">* n 不为数字时，抛错。</span><br></pre></td></tr></table></figure>

<p>我们用测试用例来描述一下这几个要求，更新后的 main.test.js 如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> main = <span class="built_in">require</span>(<span class="string">&#x27;../main&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> should = <span class="built_in">require</span>(<span class="string">&#x27;should&#x27;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;test/main.test.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&#x27;should equal 0 when n === 0&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    main.fibonacci(<span class="number">0</span>).should.equal(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should equal 1 when n === 1&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    main.fibonacci(<span class="number">1</span>).should.equal(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should equal 55 when n === 10&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    main.fibonacci(<span class="number">10</span>).should.equal(<span class="number">55</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should throw when n &gt; 10&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      main.fibonacci(<span class="number">11</span>);</span><br><span class="line">    &#125;).should.throw(<span class="string">&#x27;n should &lt;= 10&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should throw when n &lt; 0&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      main.fibonacci(-<span class="number">1</span>);</span><br><span class="line">    &#125;).should.throw(<span class="string">&#x27;n should &gt;= 0&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should throw when n isnt Number&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      main.fibonacci(<span class="string">&#x27;呵呵&#x27;</span>);</span><br><span class="line">    &#125;).should.throw(<span class="string">&#x27;n should be a Number&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>还是比较清晰的吧？</p>
<p>我们这时候跑一下 <code>$ mocha</code>，会发现后三个 case 都没过。</p>
<p>于是我们更新 fibonacci 的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;n should be a Number&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;n should &gt;= 0&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;n should &lt;= 10&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再跑一次 <code>$ mocha</code>，就过了。这就是传说中的测试驱动开发：先把要达到的目的都描述清楚，然后让现有的程序跑不过 case，再修补程序，让 case 通过。</p>
<p>安装一个 istanbul : <code>$ npm i istanbul -g</code></p>
<p>执行 <code>$ istanbul cover _mocha</code></p>
<p>这会比直接使用 mocha 多一行覆盖率的输出，</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/3.png"></p>
<p>可以看到，我们其中的分支覆盖率是 91.67%，行覆盖率是 87.5%。</p>
<p>打开 <code>open coverage/lcov-report/index.html</code> 看看</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/4.png"></p>
<p>其实这覆盖率是 100% 的，24 25 两行没法测。</p>
<p>mocha 和 istanbul 的结合是相当无缝的，只要 mocha 跑得动，那么 istanbul 就接得进来。</p>
<p>到此这门课其实就完了，剩下要说的内容，都是些比较细节的。比较懒的同学可以踩坑了之后再回来看。</p>
<p>上面的课程，不完美的地方就在于 mocha 和 istanbul 版本依赖的问题，但为了不引入不必要的复杂性，所以上面就没提到这点了。</p>
<p>假设你有一个项目A，用到了 mocha 的 version 3，其他人有个项目B，用到了 mocha 的 version 10，那么如果你 <code>npm i mocha -g</code> 装的是 version 3 的话，你用 <code>$ mocha</code> 是不兼容B项目的。因为 mocha 版本改变之后，很可能语法也变了，对吧。</p>
<p>这时，跑测试用例的正确方法，应该是</p>
<ol>
<li><code>$ npm i mocha --save-dev</code>，装个 mocha 到项目目录中去</li>
<li><code>$ ./node_modules/.bin/mocha</code>，用刚才安装的这个特定版本的 mocha，来跑项目的测试代码。</li>
</ol>
<p><code>./node_modules/.bin</code> 这个目录下放着我们所有依赖自带的那些可执行文件。</p>
<p>每次输入这个很麻烦对吧？所以我们要引入 Makefile，让 Makefile 帮我们记住复杂的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">  .&#x2F;node_modules&#x2F;.bin&#x2F;mocha</span><br><span class="line"></span><br><span class="line">cov test-cov:</span><br><span class="line">  .&#x2F;node_modules&#x2F;.bin&#x2F;istanbul cover _mocha</span><br><span class="line"></span><br><span class="line">.PHONY: test cov test-cov</span><br></pre></td></tr></table></figure>

<p>这时，我们只需要调用 <code>make test</code> 或者 <code>make cov</code>，就可以跑我们相应的测试了。</p>
<p>至于 Makefile 怎么写？以及 .PHONY 是什么意思，请看这里：<a target="_blank" rel="noopener" href="http://blog.csdn.net/haoel/article/details/2886">http://blog.csdn.net/haoel/article/details/2886</a> ，左耳朵耗子陈皓2004年的文章。</p>
<h1 id="《浏览器端测试：mocha，chai，phantomjs》"><a href="#《浏览器端测试：mocha，chai，phantomjs》" class="headerlink" title="《浏览器端测试：mocha，chai，phantomjs》"></a>《浏览器端测试：mocha，chai，phantomjs》</h1><h2 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson7 项目，在其中编写代码，我们暂时命名为 <em>vendor</em><br>根据下面的步骤，最终的项目结构应该长<a target="_blank" rel="noopener" href="https://github.com/alsotang/node-lessons/tree/master/lesson7/vendor">这样</a></p>
<p>这次我们测试的对象是上文提到的 fibonacci 函数</p>
<p>此函数的定义为 <code>int fibonacci(int n)</code></p>
<ul>
<li>当 n === 0 时，返回 0；n === 1时，返回 1;</li>
<li>n &gt; 1 时，返回 <code>fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)</code>，如 <code>fibonacci(10) === 55</code>;</li>
</ul>
<h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>学习使用测试框架 mocha 进行前端测试 : <a target="_blank" rel="noopener" href="http://mochajs.org/">http://mochajs.org/</a></li>
<li>了解全栈的断言库 chai: <a target="_blank" rel="noopener" href="http://chaijs.com/">http://chaijs.com/</a></li>
<li>了解 headless 浏览器 phantomjs: <a target="_blank" rel="noopener" href="http://phantomjs.org/">http://phantomjs.org/</a></li>
</ol>
<h3 id="前端脚本单元测试"><a href="#前端脚本单元测试" class="headerlink" title="前端脚本单元测试"></a>前端脚本单元测试</h3><p><a target="_blank" rel="noopener" href="https://github.com/alsotang/node-lessons/tree/master/lesson6">lesson6</a> 的内容都是针对后端环境中 node 的一些单元测试方案，出于应用健壮性的考量，针对前端 js 脚本的单元测试也非常重要。而前后端通吃，也是 mocha 的一大特点。</p>
<p>首先，前端脚本的单元测试主要有两个困难需要解决。</p>
<ol>
<li><p>运行环境应当在浏览器中，可以操纵浏览器的DOM对象，且可以随意定义执行时的 html 上下文。</p>
</li>
<li><p>测试结果应当可以直接反馈给 mocha，判断测试是否通过。</p>
</li>
</ol>
<h4 id="浏览器环境执行"><a href="#浏览器环境执行" class="headerlink" title="浏览器环境执行"></a>浏览器环境执行</h4><p>我们首先搭建一个测试原型，用 mocha 自带的脚手架可以自动生成。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd vendor            # 进入我们的项目文件夹</span><br><span class="line">npm i -g mocha       # 安装全局的 mocha 命令行工具</span><br><span class="line">mocha init .         # 生成脚手架</span><br></pre></td></tr></table></figure>

<p>mocha就会自动帮我们生成一个简单的测试原型, 目录结构如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── index.html       # 这是前端单元测试的入口</span><br><span class="line">├── mocha.css</span><br><span class="line">├── mocha.js</span><br><span class="line">└── tests.js         # 我们的单元测试代码将在这里编写</span><br></pre></td></tr></table></figure>

<p>其中 index.html 是单元测试的入口，tests.js 是我们的测试用例文件。</p>
<p>我们直接在 index.html 插入上述示例的 fibonacci 函数以及断言库 chaijs。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mocha&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.rawgit.com/chaijs/chai/master/chai.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="number">1</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在tests.js中写入对应测试用例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> should = chai.should();</span><br><span class="line">describe(<span class="string">&#x27;simple test&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&#x27;should equal 0 when n === 0&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.fibonacci(<span class="number">0</span>).should.equal(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这时打开index.html，可以发现测试结果，我们完成了浏览器端的脚本测试(注意我们调用了 <strong>window</strong> 对象)</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson7/1.png"></p>
<h4 id="测试反馈"><a href="#测试反馈" class="headerlink" title="测试反馈"></a>测试反馈</h4><p>mocha没有提供一个命令行的前端脚本测试环境(因为我们的脚本文件需要运行在浏览器环境中)，因此我们使用phanatomjs帮助我们搭建一个模拟环境。不重复制造轮子，这里直接使用mocha-phantomjs帮助我们在命令行运行测试。</p>
<p>首先安装mocha-phanatomjs</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g mocha-phantomjs</span><br></pre></td></tr></table></figure>

<p>然后在 index.html 的页面下加上这段兼容代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>mocha.run()<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (<span class="built_in">window</span>.initMochaPhantomJS &amp;&amp; <span class="built_in">window</span>.location.search.indexOf(<span class="string">&#x27;skip&#x27;</span>) === -<span class="number">1</span>) &#123;</span></span><br><span class="line">    initMochaPhantomJS()</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  mocha.ui(<span class="string">&#x27;bdd&#x27;</span>);</span></span><br><span class="line">  expect = chai.expect;</span><br><span class="line">  </span><br><span class="line">  mocha.run();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这时候, 我们在命令行中运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mocha-phantomjs index.html --ssl-protocol=any --ignore-ssl-errors=true</span><br></pre></td></tr></table></figure>

<p>结果展现是不是和后端代码测试很类似 :smile:</p>
<p>更进一步，我们可以直接在 package.json 的 scripts 中添加<br>(package.json 通过 <code>npm init</code> 生成，这里不再赘述)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;mocha-phantomjs index.html --ssl-protocol=any --ignore-ssl-errors=true&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>将mocha-phantomjs作为依赖</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mocha-phantomjs --save-dev</span><br></pre></td></tr></table></figure>

<p>直接运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<p>至此,我们实现了前端脚本的单元测试，基于 phanatomjs 你几乎可以调用所有的浏览器方法，而 mocha-phanatomjs 也可以很便捷地将测试结果反馈到 mocha，便于后续的持续集成。</p>
<h1 id="《测试用例：supertest》"><a href="#《测试用例：supertest》" class="headerlink" title="《测试用例：supertest》"></a>《测试用例：supertest》</h1><h2 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson8 项目，在其中编写代码。</p>
<p>app.js: 其中有个 fibonacci 接口。fibonacci 的介绍见：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Fibonacci_number">http://en.wikipedia.org/wiki/Fibonacci_number</a> 。</p>
<p>fibonacci 函数的定义为 <code>int fibonacci(int n)</code>，调用函数的路径是 ‘/fib?n=10’，然后这个接口会返回 ‘55’。函数的行为定义如下：</p>
<ul>
<li>当 n === 0 时，返回 0；n === 1时，返回 1;</li>
<li>n &gt; 1 时，返回 <code>fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)</code>，如 <code>fibonacci(10) === 55</code>;</li>
<li>n 不可大于10，否则抛错，http status 500，因为 Node.js 的计算性能没那么强。</li>
<li>n 也不可小于 0，否则抛错，500，因为没意义。</li>
<li>n 不为数字时，抛错，500。</li>
</ul>
<p>test/main.test.js: 对 app 的接口进行测试，覆盖以上所有情况。</p>
<h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>学习 supertest 的使用 (<a target="_blank" rel="noopener" href="https://github.com/tj/supertest">https://github.com/tj/supertest</a> )</li>
<li>复习 mocha，should 的使用</li>
</ol>
<h2 id="课程内容-6"><a href="#课程内容-6" class="headerlink" title="课程内容"></a>课程内容</h2><p>这是连续第三节课讲测试了..我自己都烦..看着烦的可以考虑跳下一课。</p>
<p>OK，基础知识前面都讲得很多了，这节课我不会事无巨细地写过程了。</p>
<p>噢，对了，说到 fibonacci，Node 中文圈的大神 @苏千(<a target="_blank" rel="noopener" href="https://github.com/fengmk2">https://github.com/fengmk2</a> ) 写过一个页面，对各种语言的 fibonacci 效率进行了测试：<a target="_blank" rel="noopener" href="http://fengmk2.cnpmjs.org/blog/2011/fibonacci/nodejs-python-php-ruby-lua.html">http://fengmk2.cnpmjs.org/blog/2011/fibonacci/nodejs-python-php-ruby-lua.html</a> 。其中，Node 的表现不知道比 Python 和 Ruby 高到哪里去了，与 CPU 谈笑风生。怀疑 js 的人啊，都 too simple，sometimes naive。</p>
<p>先来介绍一下 supertest。supertest 是 superagent 的孪生库。他的作者叫 tj，这是个在 Node.js 的历史上会永远被记住的名字，因为他一个人撑起了 npm 的半边天。别误会成他是 npm 的开发者，他的贡献是在 Node.js 的方方面面都贡献了非常高质量和口碑的库，比如 mocha 是他的，superagent 是他的，express 是他的，should 也是他的，还有其他很多很多，比如 koa，都是他的。如果你更详细点了解一些 Node 圈内的八卦，一定也会像我一样对 tj 佩服得五体投地。他的 github 首页是：<a target="_blank" rel="noopener" href="https://github.com/tj">https://github.com/tj</a> 。</p>
<p>假使你作为一个有志之士，想要以他为榜样，跟随他前进的步伐，那么我指条明路给你，不收费的：<a target="_blank" rel="noopener" href="http://tour.golang.org/">http://tour.golang.org/</a></p>
<p>为什么说 supertest 是 superagent 的孪生库呢，因为他们的 API 是一模一样的。superagent 是用来抓取页面用的，而 supertest，是专门用来配合 express （准确来说是所有兼容 connect 的 web 框架）进行集成测试的。</p>
<p>将使你有一个 app: <code>var app = express();</code>，想对它的 get 啊，post 接口啊之类的进行测试，那么只要把它传给 supertest：<code>var request = require(&#39;supertest&#39;)(app)</code>。之后调用 <code>requset.get(&#39;/path&#39;)</code> 时，就可以对 app 的 path 路径进行访问了。它的 API 参照 superagent 的来就好了：<a target="_blank" rel="noopener" href="http://visionmedia.github.io/superagent/">http://visionmedia.github.io/superagent/</a> 。</p>
<p>我们来新建一个项目</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm init <span class="comment"># ..一阵乱填</span></span></span><br></pre></td></tr></table></figure>

<p>然后安装我们的依赖（记得去弄清楚 <code>npm i --save</code> 与 <code>npm i --save-dev</code> 的区别）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;mocha&quot;</span>: <span class="string">&quot;^1.21.4&quot;</span>,</span><br><span class="line">  <span class="string">&quot;should&quot;</span>: <span class="string">&quot;^4.0.4&quot;</span>,</span><br><span class="line">  <span class="string">&quot;supertest&quot;</span>: <span class="string">&quot;^0.14.0&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;express&quot;</span>: <span class="string">&quot;^4.9.6&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，编写 app.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与之前一样</span></span><br><span class="line"><span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// typeof NaN === &#x27;number&#x27; 是成立的，所以要判断 NaN</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">&#x27;number&#x27;</span> || <span class="built_in">isNaN</span>(n)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;n should be a Number&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;n should &gt;= 0&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;n should &lt;= 10&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// END 与之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/fib&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// http 传来的东西默认都是没有类型的，都是 String，所以我们要手动转换类型</span></span><br><span class="line">  <span class="keyword">var</span> n = <span class="built_in">Number</span>(req.query.n);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 为何使用 String 做类型转换，是因为如果你直接给个数字给 res.send 的话，</span></span><br><span class="line">    <span class="comment">// 它会当成是你给了它一个 http 状态码，所以我们明确给 String</span></span><br><span class="line">    res.send(<span class="built_in">String</span>(fibonacci(n)));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 如果 fibonacci 抛错的话，错误信息会记录在 err 对象的 .message 属性中。</span></span><br><span class="line">    <span class="comment">// 拓展阅读：https://www.joyent.com/developers/node/design/errors</span></span><br><span class="line">    res</span><br><span class="line">      .status(<span class="number">500</span>)</span><br><span class="line">      .send(e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露 app 出去。module.exports 与 exports 的区别请看《深入浅出 Node.js》</span></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;app is listening at port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>好了，启动一下看看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node app.js</span></span><br></pre></td></tr></table></figure>

<p>然后访问 <code>http://localhost:3000/fib?n=10</code>，看到 55 就说明启动成功了。再访问 <code>http://localhost:3000/fib?n=111</code>，会看到 <code>n should &lt;= 10</code>。</p>
<p>对了，大家去装个 <code>nodemon</code> <a target="_blank" rel="noopener" href="https://github.com/remy/nodemon">https://github.com/remy/nodemon</a> 。</p>
<p><code>$ npm i -g nodemon</code></p>
<p>这个库是专门调试时候使用的，它会自动检测 node.js 代码的改动，然后帮你自动重启应用。在调试时可以完全用 nodemon 命令代替 node 命令。</p>
<p><code>$ nodemon app.js</code> 启动我们的应用试试，然后随便改两行代码，就可以看到 nodemon 帮我们重启应用了。</p>
<p>那么 app 写完了，接着开始测试，测试代码在 test/app.test.js。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">&#x27;../app&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> supertest = <span class="built_in">require</span>(<span class="string">&#x27;supertest&#x27;</span>);</span><br><span class="line"><span class="comment">// 看下面这句，这是关键一句。得到的 request 对象可以直接按照</span></span><br><span class="line"><span class="comment">// superagent 的 API 进行调用</span></span><br><span class="line"><span class="keyword">var</span> request = supertest(app);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> should = <span class="built_in">require</span>(<span class="string">&#x27;should&#x27;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;test/app.test.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我们的第一个测试用例，好好理解一下</span></span><br><span class="line">  it(<span class="string">&#x27;should return 55 when n is 10&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 之所以这个测试的 function 要接受一个 done 函数，是因为我们的测试内容</span></span><br><span class="line">    <span class="comment">// 涉及了异步调用，而 mocha 是无法感知异步调用完成的。所以我们主动接受它提供</span></span><br><span class="line">    <span class="comment">// 的 done 函数，在测试完毕时，自行调用一下，以示结束。</span></span><br><span class="line">    <span class="comment">// mocha 可以感知到我们的测试函数是否接受 done 参数。js 中，function</span></span><br><span class="line">    <span class="comment">// 对象是有长度的，它的长度由它的参数数量决定</span></span><br><span class="line">    <span class="comment">// (function (a, b, c, d) &#123;&#125;).length === 4</span></span><br><span class="line">    <span class="comment">// 所以 mocha 通过我们测试函数的长度就可以确定我们是否是异步测试。</span></span><br><span class="line"></span><br><span class="line">    request.get(<span class="string">&#x27;/fib&#x27;</span>)</span><br><span class="line">    <span class="comment">// .query 方法用来传 querystring，.send 方法用来传 body。</span></span><br><span class="line">    <span class="comment">// 它们都可以传 Object 对象进去。</span></span><br><span class="line">    <span class="comment">// 在这里，我们等于访问的是 /fib?n=10</span></span><br><span class="line">      .query(&#123;<span class="attr">n</span>: <span class="number">10</span>&#125;)</span><br><span class="line">      .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 由于 http 返回的是 String，所以我要传入 &#x27;55&#x27;。</span></span><br><span class="line">        res.text.should.equal(<span class="string">&#x27;55&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// done(err) 这种用法写起来很鸡肋，是因为偷懒不想测 err 的值</span></span><br><span class="line">        <span class="comment">// 如果勤快点，这里应该写成</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        should.not.exist(err);</span></span><br><span class="line"><span class="comment">        res.text.should.equal(&#x27;55&#x27;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        done(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面我们对于各种边界条件都进行测试，由于它们的代码雷同，</span></span><br><span class="line">  <span class="comment">// 所以我抽象出来了一个 testFib 方法。</span></span><br><span class="line">  <span class="keyword">var</span> testFib = <span class="function"><span class="keyword">function</span> (<span class="params">n, statusCode, expect, done</span>) </span>&#123;</span><br><span class="line">    request.get(<span class="string">&#x27;/fib&#x27;</span>)</span><br><span class="line">      .query(&#123;<span class="attr">n</span>: n&#125;)</span><br><span class="line">      .expect(statusCode)</span><br><span class="line">      .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        res.text.should.equal(expect);</span><br><span class="line">        done(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  it(<span class="string">&#x27;should return 0 when n === 0&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    testFib(<span class="number">0</span>, <span class="number">200</span>, <span class="string">&#x27;0&#x27;</span>, done);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should equal 1 when n === 1&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    testFib(<span class="number">1</span>, <span class="number">200</span>, <span class="string">&#x27;1&#x27;</span>, done);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should equal 55 when n === 10&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    testFib(<span class="number">10</span>, <span class="number">200</span>, <span class="string">&#x27;55&#x27;</span>, done);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should throw when n &gt; 10&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    testFib(<span class="number">11</span>, <span class="number">500</span>, <span class="string">&#x27;n should &lt;= 10&#x27;</span>, done);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should throw when n &lt; 0&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    testFib(-<span class="number">1</span>, <span class="number">500</span>, <span class="string">&#x27;n should &gt;= 0&#x27;</span>, done);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should throw when n isnt Number&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    testFib(<span class="string">&#x27;good&#x27;</span>, <span class="number">500</span>, <span class="string">&#x27;n should be a Number&#x27;</span>, done);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单独测试一下返回码 500</span></span><br><span class="line">  it(<span class="string">&#x27;should status 500 when error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    request.get(<span class="string">&#x27;/fib&#x27;</span>)</span><br><span class="line">      .query(&#123;<span class="attr">n</span>: <span class="number">100</span>&#125;)</span><br><span class="line">      .expect(<span class="number">500</span>)</span><br><span class="line">      .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        done(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>完。</p>
<h2 id="关于-cookie-持久化"><a href="#关于-cookie-持久化" class="headerlink" title="关于 cookie 持久化"></a>关于 cookie 持久化</h2><p>有两种思路</p>
<ol>
<li><p>在 supertest 中，可以通过 <code>var agent = supertest.agent(app)</code> 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。agent 对象在被多次调用 <code>get</code> 和 <code>post</code> 之后，可以一路把 cookie 都保存下来。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> supertest = <span class="built_in">require</span>(<span class="string">&#x27;supertest&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> agent = supertest.agent(app);</span><br><span class="line"></span><br><span class="line">agent.post(<span class="string">&#x27;login&#x27;</span>).end(...);</span><br><span class="line"><span class="comment">// then ..</span></span><br><span class="line">agent.post(<span class="string">&#x27;create_topic&#x27;</span>).end(...); <span class="comment">// 此时的 agent 中有用户登陆后的 cookie</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在发起请求时，调用 <code>.set(&#39;Cookie&#39;, &#39;a cookie string&#39;)</code> 这样的方式。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> supertest = <span class="built_in">require</span>(<span class="string">&#x27;supertest&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> userCookie;</span><br><span class="line">supertest.post(<span class="string">&#x27;login&#x27;</span>).end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    userCookie = res.headers[<span class="string">&#x27;set-cookie&#x27;</span>]</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// then ..</span></span><br><span class="line"></span><br><span class="line">supertest.post(<span class="string">&#x27;create_topic&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;cookie&#x27;</span>, userCookie)</span><br><span class="line">  .end(...)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这里有个相关讨论：<a target="_blank" rel="noopener" href="https://github.com/tj/supertest/issues/46">https://github.com/tj/supertest/issues/46</a></p>
<h2 id="拓展学习"><a href="#拓展学习" class="headerlink" title="拓展学习"></a>拓展学习</h2><p>Nodeclub 里面的测试使用的技术跟前面介绍的是一样的，should mocha supertest 那套，应该是很容易看懂的:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js">https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js</a></p>
<h1 id="《正则表达式》"><a href="#《正则表达式》" class="headerlink" title="《正则表达式》"></a>《正则表达式》</h1><h2 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> web_development = <span class="string">&quot;python php ruby javascript jsonp perhapsphpisoutdated&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>找出其中 包含 <code>p</code> 但不包含 <code>ph</code> 的所有单词，即</p>
<p><code>[ &#39;python&#39;, &#39;javascript&#39;, &#39;jsonp&#39; ]</code></p>
<h2 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>正则表达式的使用</li>
<li>js 中的正则表达式与 pcre(<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions">http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions</a> ) 的区别</li>
</ol>
<h2 id="课程内容-7"><a href="#课程内容-7" class="headerlink" title="课程内容"></a>课程内容</h2><p>开始这门课之前，大家先去看两篇文章。</p>
<p>《正则表达式30分钟入门教程》：<a target="_blank" rel="noopener" href="http://deerchao.net/tutorials/regex/regex.htm">http://deerchao.net/tutorials/regex/regex.htm</a></p>
<p>上面这篇介绍了正则表达式的基础知识，但是对于零宽断言没有展开来讲，零宽断言看下面这篇：</p>
<p>《正则表达式之：零宽断言不『消费』》：<a target="_blank" rel="noopener" href="http://fxck.it/post/50558232873">http://fxck.it/post/50558232873</a></p>
<p>好了。</p>
<p>在很久很久以前，有一门语言一度是字符串处理领域的王者，叫 perl。</p>
<p>伴随着 perl，有一个类似正则表达式的标准被实现了出来，叫 pcre：Perl Compatible Regular Expressions。</p>
<p>不遗憾的是，js 里面的正则与 pcre 不是兼容的。很多语言都这样。</p>
<p>如果需要测试你自己写的正则表达式，建议上这里：<a target="_blank" rel="noopener" href="http://refiddle.com/">http://refiddle.com/</a> ，可以所见即所得地调试。</p>
<p>接下来我们主要讲讲 js 中需要注意的地方，至于正则表达式的内容，上面那两篇文章足够学习了。</p>
<p>第一，</p>
<p>js 中，对于四种零宽断言，只支持 零宽度正预测先行断言 和 零宽度负预测先行断言 这两种。</p>
<p>第二，</p>
<p>js 中，正则表达式后面可以跟三个 flag，比如 <code>/something/igm</code>。</p>
<p>他们的意义分别是，</p>
<ul>
<li>i 的意义是不区分大小写</li>
<li>g 的意义是，匹配多个</li>
<li>m 的意义是，是 <code>^</code> 和 <code>$</code> 可以匹配<strong>每</strong>一行的开头。</li>
</ul>
<p>分别举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/a/.test(<span class="string">&#x27;A&#x27;</span>) <span class="comment">// =&gt; false</span></span><br><span class="line">/a/i.test(<span class="string">&#x27;A&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;hello hell hoo&#x27;</span>.match(<span class="regexp">/h.*?\b/</span>) <span class="comment">// =&gt; [ &#x27;hello&#x27;, index: 0, input: &#x27;hello hell hoo&#x27; ]</span></span><br><span class="line"><span class="string">&#x27;hello hell hoo&#x27;</span>.match(<span class="regexp">/h.*?\b/g</span>) <span class="comment">// =&gt; [ &#x27;hello&#x27;, &#x27;hell&#x27;, &#x27;hoo&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;aaa\nbbb\nccc&#x27;</span>.match(<span class="regexp">/^[\s\S]*?$/g</span>) <span class="comment">// =&gt; [ &#x27;aaa\nbbb\nccc&#x27; ]</span></span><br><span class="line"><span class="string">&#x27;aaa\nbbb\nccc&#x27;</span>.match(<span class="regexp">/^[\s\S]*?$/gm</span>) <span class="comment">// =&gt; [ &#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>与 m 意义相关的，还有 <code>\A</code>, <code>\Z</code> 和 <code>\z</code></p>
<p>他们的意义分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\A  字符串开头(类似^，但不受处理多行选项的影响)</span><br><span class="line">\Z  字符串结尾或行尾(不受处理多行选项的影响)</span><br><span class="line">\z  字符串结尾(类似$，但不受处理多行选项的影响)</span><br></pre></td></tr></table></figure>

<p>在 js 中，g flag 会影响 <code>String.prototype.match()</code> 和 <code>RegExp.prototype.exec()</code> 的行为</p>
<p><code>String.prototype.match()</code> 中，返回数据的格式会不一样，加 g 会返回数组，不加 g 则返回比较详细的信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">&#x27;hello hell&#x27;</span>.match(<span class="regexp">/h(.*?)\b/g</span>)</span><br><span class="line">[ <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hell&#x27;</span> ]</span><br><span class="line"></span><br><span class="line">&gt; <span class="string">&#x27;hello hell&#x27;</span>.match(<span class="regexp">/h(.*?)\b/</span>)</span><br><span class="line">[ <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;ello&#x27;</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">&#x27;hello hell&#x27;</span> ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>RegExp.prototype.exec()</code> 中，加 g 之后，如果你的正则不是字面量的正则，而是存储在变量中的话，特么的这个变量就会变得有记忆！！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="regexp">/h(.*?)\b/g</span>.exec(<span class="string">&#x27;hello hell&#x27;</span>)</span><br><span class="line">[ <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;ello&#x27;</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">&#x27;hello hell&#x27;</span> ]</span><br><span class="line">&gt; <span class="regexp">/h(.*?)\b/g</span>.exec(<span class="string">&#x27;hello hell&#x27;</span>)</span><br><span class="line">[ <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;ello&#x27;</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">&#x27;hello hell&#x27;</span> ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">var</span> re = <span class="regexp">/h(.*?)\b/g</span>;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; re.exec(<span class="string">&#x27;hello hell&#x27;</span>)</span><br><span class="line">[ <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;ello&#x27;</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">&#x27;hello hell&#x27;</span> ]</span><br><span class="line">&gt; re.exec(<span class="string">&#x27;hello hell&#x27;</span>)</span><br><span class="line">[ <span class="string">&#x27;hell&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;ell&#x27;</span>,</span><br><span class="line">  index: <span class="number">6</span>,</span><br><span class="line">  input: <span class="string">&#x27;hello hell&#x27;</span> ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>第三，</p>
<p>大家知道，<code>.</code> 是不可以匹配 <code>\n</code> 的。如果我们想匹配的数据涉及到了跨行，比如下面这样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multiline = <span class="built_in">require</span>(<span class="string">&#x27;multiline&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = multiline.stripIndent(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    head</span></span><br></pre></td></tr></table></figure>
<pre><code>code code2 .code3```
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    foot</span><br><span class="line">*&#x2F;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre>
<p>如果我们想把两个 ``` 中包含的内容取出来，应该怎么办？</p>
<p>直接用 <code>.</code> 匹配不到 <code>\n</code>，所以我们需要找到一个原子，能匹配包括 <code>\n</code> 在内的所有字符。</p>
<p>这个原子的惯用写法就是 <code>[\s\S]</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> match1 = text.match(<span class="regexp">/^```[\s\S]+?^```/gm</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match1) <span class="comment">// =&gt; [ &#x27;```\ncode code2 code3```\n```&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里有一种很骚的写法，[^] 与 [\s\S] 等价</span></span><br><span class="line"><span class="keyword">var</span> match2 = text.match(<span class="regexp">/^```[^]+?^```/gm</span>)</span><br><span class="line"><span class="built_in">console</span>.log(match2) <span class="comment">// =&gt; [ &#x27;```\ncode code2 .code3```\n```&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>完。</p>
<h1 id="《benchmark-怎么写》"><a href="#《benchmark-怎么写》" class="headerlink" title="《benchmark 怎么写》"></a>《benchmark 怎么写》</h1><h2 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h2><p>有一个字符串 <code>var number = &#39;100&#39;</code>，我们要将它转换成 Number 类型的 100。</p>
<p>目前有三个选项：+, parseInt, Number</p>
<p>请测试哪个方法更快。</p>
<h2 id="知识点-9"><a href="#知识点-9" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>学习使用 benchmark 库</li>
<li>学习使用 <a target="_blank" rel="noopener" href="http://jsperf.com/">http://jsperf.com/</a> 分享你的 benchmark</li>
</ol>
<h2 id="课程内容-8"><a href="#课程内容-8" class="headerlink" title="课程内容"></a>课程内容</h2><p>首先去弄个 benchmark 库，<a target="_blank" rel="noopener" href="https://github.com/bestiejs/benchmark.js">https://github.com/bestiejs/benchmark.js</a> 。</p>
<p><del> 这个库已经两年没有更新了，两年前发了个 1.0.0 版本，直到现在。 </del></p>
<p>这个库的最新版本是 2.1.0</p>
<p>用法也特别简单，照着官网的 copy 下来就好。</p>
<p>我们先来实现这三个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> int1 = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> int2 = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(str, <span class="number">10</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> int3 = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Number</span>(str);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后照着官方的模板写 benchmark suite：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="string">&#x27;100&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加测试</span></span><br><span class="line">suite</span><br><span class="line">.add(<span class="string">&#x27;+&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  int1(number);</span><br><span class="line">&#125;)</span><br><span class="line">.add(<span class="string">&#x27;parseInt&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  int2(number);</span><br><span class="line">&#125;)</span><br><span class="line">.add(<span class="string">&#x27;Number&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  int3(number);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 每个测试跑完后，输出信息</span></span><br><span class="line">.on(<span class="string">&#x27;cycle&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target));</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">&#x27;complete&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Fastest is &#x27;</span> + <span class="built_in">this</span>.filter(<span class="string">&#x27;fastest&#x27;</span>).map(<span class="string">&#x27;name&#x27;</span>));</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里的 async 不是 mocha 测试那个 async 的意思，这个选项与它的时间计算有关，默认勾上就好了。</span></span><br><span class="line">.run(&#123; <span class="string">&#x27;async&#x27;</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>直接运行：</p>
<p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson10/1.png"></p>
<p>可以看到，parseInt 是最快的。</p>
<h3 id="在线分享"><a href="#在线分享" class="headerlink" title="在线分享"></a>在线分享</h3><p>如果想要在线分享你的 js benchmark，用这个网站：<a target="_blank" rel="noopener" href="http://jsperf.com/">http://jsperf.com/</a> 。</p>
<p>比如我在上面测试 <code>Math.log</code> 的效率：</p>
<p><a target="_blank" rel="noopener" href="http://jsperf.com/math-perf-alsotang">http://jsperf.com/math-perf-alsotang</a></p>
<p>进入之后点击那个 <code>Run tests</code> 按钮，就可以在浏览器中看到它们的效率差异了，毕竟浏览器也是可以跑 js 的。</p>
<p>点击这里：<a target="_blank" rel="noopener" href="http://jsperf.com/math-perf-alsotang/edit">http://jsperf.com/math-perf-alsotang/edit</a> ，就可以看到这个 benchmark 是怎么配置的，很简单。</p>
<h1 id="《作用域与闭包：this，var，-function-》"><a href="#《作用域与闭包：this，var，-function-》" class="headerlink" title="《作用域与闭包：this，var，(function () {})》"></a>《作用域与闭包：this，var，(function () {})》</h1><h2 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h2><p>无具体目标</p>
<h2 id="知识点-10"><a href="#知识点-10" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>理解 js 中 var 的作用域</li>
<li>了解闭包的概念</li>
<li>理解 this 的指向</li>
</ol>
<h2 id="课程内容-9"><a href="#课程内容-9" class="headerlink" title="课程内容"></a>课程内容</h2><h3 id="var-作用域"><a href="#var-作用域" class="headerlink" title="var 作用域"></a>var 作用域</h3><p>先来看个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;parent_name&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> child = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;child_name&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> childAge = <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =&gt; child_name 13 0.3</span></span><br><span class="line">    <span class="built_in">console</span>.log(name, age, childAge);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  child();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// will throw Error</span></span><br><span class="line">  <span class="comment">// ReferenceError: childAge is not defined</span></span><br><span class="line">  <span class="built_in">console</span>.log(name, age, childAge);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent();</span><br></pre></td></tr></table></figure>

<p>直觉地，内部函数可以访问外部函数的变量，外部不能访问内部函数的变量。上面的例子中内部函数 child 可以访问变量 age，而外部函数 parent 不可以访问 child 中的变量 childAge，因此会抛出没有定义变量的异常。</p>
<p>有个重要的事，如果忘记var，那么变量就被声明为全局变量了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  value = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 输出hello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">global</span>.value) <span class="comment">// 输出hello</span></span><br></pre></td></tr></table></figure>

<p>这个例子可以很正常的输出 <code>hello</code>，是因为 <code>value</code> 变量在定义时，没有使用 <code>var</code> 关键词，所以被定义成了全局变量。在 Node 中，全局变量会被定义在 <code>global</code> 对象下；在浏览器中，全局变量会被定义在 <code>window</code> 对象下。</p>
<p>如果你确实要定义一个全局变量的话，请显示地定义在 <code>global</code> 或者 <code>window</code> 对象上。</p>
<p>这类不小心定义全局变量的问题可以被 jshint 检测出来，如果你使用 sublime 编辑器的话，记得装一个 <code>SublimeLinter</code> 插件，这是插件支持多语言的语法错误检测，js 的检测是原生支持的。</p>
<p>JavaScript 中，变量的局部作用域是函数级别的。不同于 C 语言，在 C 语言中，作用域是块级别的。<br>JavaScript 中没有块级作用域。</p>
<p>js 中，函数中声明的变量在整个函数中都有定义。比如如下代码段，变量 i 和 value 虽然是在 for 循环代码块中被定义，但在代码块外仍可以访问 i 和 value。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//输出10</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);<span class="comment">//输出hello world</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>所以有种说法是：应该提前声明函数中需要用到的变量，即，在函数体的顶部声明可能用到的变量，这样就可以避免出现一些奇奇怪怪怪的 bug。</p>
<p>但我个人不喜欢遵守这一点，一般都是现用现声明的。这类错误的检测交给 jshint 来做就好了。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包这个概念，在函数式编程里很常见，简单的说，就是使内部函数可以访问定义在外部函数中的变量。</p>
<p>假如我们要实现一系列的函数：add10，add20，它们的定义是 <code>int add10(int n)</code>。</p>
<p>为此我们构造了一个名为 adder 的构造器，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> base = x;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n + base;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = adder(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add20 = adder(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add20(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p>每次调用 adder 时，adder 都会返回一个函数给我们。我们传给 adder 的值，会保存在一个名为 base 的变量中。由于返回的函数在其中引用了 base 的值，于是 base 的引用计数被 +1。当返回函数不被垃圾回收时，则 base 也会一直存在。</p>
<p>我暂时想不出什么实用的例子来，如果想深入理解这块，可以看看这篇 <a target="_blank" rel="noopener" href="http://coolshell.cn/articles/6731.html">http://coolshell.cn/articles/6731.html</a></p>
<h4 id="闭包的一个坑"><a href="#闭包的一个坑" class="headerlink" title="闭包的一个坑"></a>闭包的一个坑</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个代码块会打印五个 <code>5</code> 出来，而我们预想的结果是打印 0 1 2 3 4。</p>
<p>之所以会这样，是因为 setTimeout 中的 i 是对外层 i 的引用。当 setTimeout 的代码被解释的时候，运行时只是记录了 i 的引用，而不是值。而当 setTimeout 被触发时，五个 setTimeout 中的 i 同时被取值，由于它们都指向了外层的同一个 i，而那个 i 的值在迭代完成时为 5，所以打印了五次 <code>5</code>。</p>
<p>为了得到我们预想的结果，我们可以把 i 赋值成一个局部的变量，从而摆脱外层迭代的影响。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">idx</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(idx);</span><br><span class="line">    &#125;, <span class="number">5</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。</p>
<p>在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是：</p>
<ul>
<li>有对象就指向调用对象</li>
<li>没调用对象就指向全局对象</li>
<li>用new构造就指向新对象</li>
<li>通过 apply 或 call 或 bind 来改变 this 的所指。</li>
</ul>
<p>1）函数有所属对象时：指向所属对象</p>
<p>函数有所属对象时，通常通过 <code>.</code> 表达式调用，这时 <code>this</code> 自然指向所属对象。比如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">value</span>: <span class="number">100</span>&#125;;</span><br><span class="line">myObject.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);  <span class="comment">// 输出 100</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出 &#123; value: 100, getValue: [Function] &#125;，</span></span><br><span class="line">  <span class="comment">// 其实就是 myObject 对象本身</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.getValue()); <span class="comment">// =&gt; 100</span></span><br></pre></td></tr></table></figure>

<p><code>getValue()</code> 属于对象 <code>myObject</code>，并由 <code>myOjbect</code> 进行 <code>.</code> 调用，因此 <code>this</code> 指向对象 <code>myObject</code>。</p>
<ol start="2">
<li>函数没有所属对象：指向全局对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">value</span>: <span class="number">100</span>&#125;;</span><br><span class="line">myObject.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value) <span class="comment">// =&gt; undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// 输出全局对象 global</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  foo();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.getValue()); <span class="comment">// =&gt; 100</span></span><br></pre></td></tr></table></figure>

<p>在上述代码块中，<code>foo</code> 函数虽然定义在 <code>getValue</code> 的函数体内，但实际上它既不属于 <code>getValue</code> 也不属于 <code>myObject</code>。<code>foo</code> 并没有被绑定在任何对象上，所以当调用时，它的 <code>this</code> 指针指向了全局对象 <code>global</code>。</p>
<p>据说这是个设计错误。</p>
<p>3）构造器中的 this：指向新对象</p>
<p>js 中，我们通过 <code>new</code> 关键词来调用构造函数，此时 this 会绑定在该新对象上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> SomeClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myCreate = <span class="keyword">new</span> SomeClass();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCreate.value); <span class="comment">// 输出100</span></span><br></pre></td></tr></table></figure>

<p>顺便说一句，在 js 中，构造函数、普通函数、对象方法、闭包，这四者没有明确界线。界线都在人的心中。</p>
<ol start="4">
<li>apply 和 call 调用以及 bind 绑定：指向绑定的对象</li>
</ol>
<p>apply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。</p>
<p>call() 方法第一个参数的意义与 apply() 方法相同，只是其他的参数需要一个个列举出来。</p>
<p>简单来说，call 的方式更接近我们平时调用函数，而 apply 需要我们传递 Array 形式的数组给它。它们是可以互相转换的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">value</span>: <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 全局变量 global</span></span><br><span class="line">foo.apply(myObject); <span class="comment">// &#123; value: 100 &#125;</span></span><br><span class="line">foo.call(myObject); <span class="comment">// &#123; value: 100 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newFoo = foo.bind(myObject);</span><br><span class="line">newFoo(); <span class="comment">// &#123; value: 100 &#125;</span></span><br></pre></td></tr></table></figure>

<p>完。</p>
<h1 id="《线上部署：heroku》"><a href="#《线上部署：heroku》" class="headerlink" title="《线上部署：heroku》"></a>《线上部署：heroku》</h1><h2 id="目标-11"><a href="#目标-11" class="headerlink" title="目标"></a>目标</h2><p>将 <a target="_blank" rel="noopener" href="https://github.com/Ricardo-Li/node-practice-2">https://github.com/Ricardo-Li/node-practice-2</a> (这个项目已经被删了。参照 <a target="_blank" rel="noopener" href="https://github.com/alsotang/node-lessons/tree/master/lesson3">https://github.com/alsotang/node-lessons/tree/master/lesson3</a> 的代码自己操作一下吧。)这个项目部署上 heroku，成为一个线上项目</p>
<p>我部署的在这里 <a target="_blank" rel="noopener" href="http://serene-falls-9294.herokuapp.com/">http://serene-falls-9294.herokuapp.com/</a></p>
<h2 id="知识点-11"><a href="#知识点-11" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>学习 heroku 的线上部署(<a target="_blank" rel="noopener" href="https://www.heroku.com/">https://www.heroku.com/</a> )</li>
</ol>
<h2 id="课程内容-10"><a href="#课程内容-10" class="headerlink" title="课程内容"></a>课程内容</h2><h3 id="什么是-heroku"><a href="#什么是-heroku" class="headerlink" title="什么是 heroku"></a>什么是 heroku</h3><p>heroku 是弄 ruby 的 paas 起家，现在支持多种语言环境，更甚的是它强大的 add-on 服务。</p>
<p>paas 平台相信大家都不陌生。Google 有 gae，国内新浪有 sae。paas 平台相对 vps 来说，不需要你配置服务器，不需要装数据库，也不需要理会负载均衡。这一切都可以在平台上直接获取。</p>
<p>你只要专注自己的业务，把应用的逻辑写好，然后发布上去，应用自然就上线了。数据库方面，如果你用 mysql，那么你可以从平台商那里得到一个 mysql 的地址、账号和密码，直接连接就能用。如果应用的流量增大，需要横向拓展，则只用去到 paas 平台的管理页面，增大服务器实例的数量即可，负载均衡会自动帮你完成。</p>
<p>说起来，我之所以对于 web 开发产生兴趣也是因为当年 gae 的关系。那时候除了 gae 之外，没有别的 paas 平台，gae 是横空出世的。有款翻墙的软件，叫 gappproxy(<a target="_blank" rel="noopener" href="https://code.google.com/p/gappproxy/">https://code.google.com/p/gappproxy/</a> )——可以认为是 goagent 的前身——就是搭建在 gae 上面的，不仅快，而且免费。于是我就很想弄懂这样一个程序是如何开发的。好在 gappproxy 是开源的，于是我下了源码来看，那时候才大一，只学过 c，看到那些 python 代码就凌乱了。于是转头也去学 python，后来渐渐发现了 web 开发的乐趣，于是 ruby 和 node.js 也碰碰。后来 goagent 火起来了，我又去看了看它的代码，发现非常难看，就自己写了个 <a target="_blank" rel="noopener" href="https://github.com/alsotang/keepagent">https://github.com/alsotang/keepagent</a> 。不过现在回想起来，还是 goagent 的实现比较稳定以及效率高。</p>
<p>heroku 的免费额度还是足够的，对于 demo 应用来说，放上去是绰绰有余的。各位搞 web 开发的大学生朋友，一定要试着让你开发的项目尽可能早地去线上跑，这样你的项目可以被其他人看到，能够促使你更有热情地进行进一步开发。这回我们放的是 cnode 社区的爬虫上去，你其实可以试着为你们学院或者学校的新闻站点写个爬虫，提供 json api，然后去申请个微信公共平台，每天推送学院网站的新闻。这东西辅导员是有需求的，可以做个给他们用。</p>
<p>好了，我们先 clone <a target="_blank" rel="noopener" href="https://github.com/Ricardo-Li/node-practice-2">https://github.com/Ricardo-Li/node-practice-2</a> 这个项目。由于我们这回讲部署，所以代码就用现成的了，代码的内容就是 lesson 3（<a target="_blank" rel="noopener" href="https://github.com/alsotang/node-lessons/tree/master/lesson3">https://github.com/alsotang/node-lessons/tree/master/lesson3</a> ） 里面的那个爬虫。</p>
<p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson12/1.png"></p>
<p>clone 下来以后，我们去看看代码。代码中有两个特殊的地方，</p>
<p>一个是一个叫 Procfile 的文件，内容是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web: node app.js</span><br></pre></td></tr></table></figure>

<p>一个是 app.js 里面，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.listen(process.env.PORT || <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>这两者都是为了部署 heroku 所做的。</p>
<p>大家有没有想过，当部署一个应用上 paas 平台以后，paas 要为我们干些什么？</p>
<p>首先，平台要有我们语言的运行时；</p>
<p>然后，对于 node.js 来说，它要帮我们安装 package.json 里面的依赖；</p>
<p>然后呢？然后需要启动我们的项目；</p>
<p>然后把外界的流量导入我们的项目，让我们的项目提供服务。</p>
<p>上面那两处特殊的地方，一个是启动项目的，一个是导流量的。</p>
<p>heroku 虽然能推测出你的应用是 node.js 应用，但它不懂你的主程序是哪个，所以我们提供了 Procfile 来指导它启动我们的程序。</p>
<p>而我们的程序，本来是监听 5000 端口的，但是 heroku 并不知道。当然，你也可以在 Procfile 中告诉 heroku，可如果大家都监听 5000 端口，这时候不就有冲突了吗？所以这个地方，heroku 使用了主动的策略，主动提供一个环境变量 <code>process.env.PORT</code> 来供我们监听。</p>
<p>这样的话，一个简单 app 的配置就完成了。</p>
<p>我们去 <a target="_blank" rel="noopener" href="https://www.heroku.com/">https://www.heroku.com/</a> 申请个账号，然后下载它的工具包 <a target="_blank" rel="noopener" href="https://toolbelt.heroku.com/">https://toolbelt.heroku.com/</a> ，然后再在命令行里面，通过 <code>heroku login</code> 来登录。</p>
<p>上述步骤完成后，我们进入 <code>node-practice-2</code> 的目录，执行 <code>heroku create</code>。这时候，heroku 会为我们随机取一个应用名字，并提供一个 git 仓库给我们。</p>
<p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson12/2.png"></p>
<p>接着，往 heroku 这个远端地址推送我们的 master 分支：</p>
<p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson12/3.png"></p>
<p>heroku 会自动检测出我们是 node.js 程序，并安装依赖，然后按照 Procfile 进行启动。</p>
<p>push 完成后，在命令键入 <code>heroku open</code>，则 heroku 会自动打开浏览器带我们去到相应的网址：</p>
<p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson12/4.png"></p>
<p>到此课程也就结束了。</p>
<p>随便聊聊 heroku 的 addon 吧。这个 addon 确实是个神奇的东西，反正在 heroku 之外我还没怎么见到这类概念。这些 addon 提供商，有些提供 redis 的服务，有些提供 mongodb，有些提供 mysql。你可以直接在 heroku 上面进行购买，然后 heroku 就会提供一段相应服务的地址和账号密码给你用来连接。</p>
<p>大家可以去 <a target="_blank" rel="noopener" href="https://addons.heroku.com/">https://addons.heroku.com/</a> 这个页面看看，玲琅满目各种应用可以方便接入。之所以这类服务有市场，也是因为亚马逊的 aws 非常牛逼。为什么这么说呢，因为网络速度啊。如果现在在国内，你在 ucloud 买个主机，然后用个阿里云的 rds，那么应用的响应速度会因为 mysql 连接的问题卡得动不了。但在 heroku 这里，提供商们，包括 heroku 自己，都是构建在 aws 上面，这样一来，各种服务的互通其实走的是内网，速度很可以接受，于是各种 addon 提供商就做起来了。</p>
<p>国内的话，其实在阿里云上面也可以考虑这么搞一搞。</p>
<p>完。</p>
<h1 id="《持续集成平台：travis》"><a href="#《持续集成平台：travis》" class="headerlink" title="《持续集成平台：travis》"></a>《持续集成平台：travis》</h1><h2 id="目标-12"><a href="#目标-12" class="headerlink" title="目标"></a>目标</h2><p>无明确目标</p>
<h2 id="知识点-12"><a href="#知识点-12" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>学习使用 travis-ci 对项目进行持续集成测试 (<a target="_blank" rel="noopener" href="https://travis-ci.org/">https://travis-ci.org/</a> )</li>
</ol>
<h2 id="课程内容-11"><a href="#课程内容-11" class="headerlink" title="课程内容"></a>课程内容</h2><p>首先来看看这个项目：<a target="_blank" rel="noopener" href="https://github.com/Ricardo-Li/node-practice-3">https://github.com/Ricardo-Li/node-practice-3</a></p>
<p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson13/1.png"></p>
<p>（图1）</p>
<p>类似这样的 badges，在很多项目中都可以看到。前者是告诉我们，这个项目的测试目前是通过的；后者是告诉我们，这个测试的行覆盖率是多少。行覆盖率当然是越多越好。测试的重要性我就不说了。</p>
<p>为什么要使用 travis 这样的平台，是因为它可以让你明白自己的项目在一个“空白环境”中，是否能正确运行；也可以让你知道，用不同的 Node.js 版本运行的话，有没有兼容性问题。</p>
<p>当你在自己的机器上跑测试的时候，你用着特定的 Node.js 版本，比如 0.10，如果测试过了，你也还是不懂在 0.11 下，你的测试能不能通过。你可以手动地切换 node 版本再跑一次，也可以选择让 travis 帮你把不同的 node 版本跑一次。而且有时候，我们 npm 安装了某个包，但却忘记将它写入 package.json 里面了，在自己的机器上，测试没问题，但当别的用户安装你的包时，会发现有依赖缺失。</p>
<p>travis 应该是把虚拟机的技术玩得比较好，它每次跑测试时，都会提供一个空白的环境。这个环境只有 Linux 基本的 <code>build-essential</code> 和 <code>wget</code>、<code>git</code> 那些依赖。连 Node.js 的运行时都是现跑现安装的。</p>
<p>travis 默认带有的那些依赖，都是每个用户的机器上都会有的，所以一旦你的应用在 travis 上面能够跑通，那么就不用担心别的用户安装不上了。</p>
<p>我们来讲讲接入 travis 的步骤。</p>
<p>travis 的价格是免费的，对于 github 上的开源项目来说。它默认当然不可能帮 github 的每个用户都跑测试，所以你需要去注册一下 travis，然后告诉它你需要开启集成测试的仓库。</p>
<p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson13/2.png"></p>
<p>比如上图，可以看到我帮自己的 <code>alsohosts</code> 项目以及 <code>adsf</code> 项目开启了测试。</p>
<p>当你在 travis 授权了仓库之后，每当你 push 代码到 github，travis 都会自动帮你跑测试。</p>
<p>travis 通过授权，可以知道你的项目在什么地方，于是它就可以把项目 clone 过去。但问题又来了，它不懂你的测试怎么跑啊。用 <code>npm test</code> 还是 <code>make test</code> 还是 <code>jake test</code> 呢？</p>
<p>所以我们需要给出一些配置信息，配置信息以 <code>.travis.yml</code> 文件的形式放在项目根目录，比如一个简单的 <code>.travis.yml</code>。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&#x27;0.8&#x27;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&#x27;0.10&#x27;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&#x27;0.11&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span> <span class="string">make</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>这个文件传递的信息是：</p>
<ul>
<li>这是一个 node.js 应用</li>
<li>这个测试需要用 0.8、0.10 以及 0.11 三个版本来跑</li>
<li>跑测试的命令是 <code>make test</code></li>
</ul>
<p>将这个文件添加到项目的根目录下，再 push 上 github，这时候 travis 就会被触发了。</p>
<p>travis 接着会做的事情是：</p>
<ol>
<li>安装一个 node.js 运行时。由于我们指定了三个不同版本，于是 travis 会使用三个机器，分别安装三个版本的 node.js</li>
<li>这些机器在完成运行时安装后，会进入项目目录执行 <code>npm install</code> 来安装依赖。</li>
<li>当依赖安装完成后，执行我们指定的 script，在这里也就是 <code>make test</code></li>
</ol>
<p>如果测试通过的话，make 命令的返回码会是 0（如果不懂什么是返回码，则需要补补 shell 的知识），则测试通过；如果测试有不通过的 case，则返回码不会为 0，travis 则判断测试失败。</p>
<p>每一个 travis 上面的项目，都可以得到一个图片地址，这个地址上的图片会显示你项目当前的测试通过状态，把这个图片添加到自己项目的 README 中，就可以得到我们图1的那种逼格了。</p>
<p>对了，行覆盖率的那个 badge 是由一个叫 coveralls(<a target="_blank" rel="noopener" href="https://coveralls.io/">https://coveralls.io/</a> ) 的服务提供的。大家可以试着自己接入。</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明:"></a>补充说明:</h2><p>如果你的应用有使用到数据库, 需要在 <code>.travis.yml</code> 中添加一些内容.</p>
<p>以 MongoDB 为例:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="string">mongodb</span></span><br></pre></td></tr></table></figure>

<p>其它数据库详细内容参考<a target="_blank" rel="noopener" href="http://docs.travis-ci.com/user/database-setup/">travis 官方文档</a></p>
<h1 id="《js-中的那些最佳实践》"><a href="#《js-中的那些最佳实践》" class="headerlink" title="《js 中的那些最佳实践》"></a>《js 中的那些最佳实践》</h1><h2 id="JavaScript-语言精粹"><a href="#JavaScript-语言精粹" class="headerlink" title="JavaScript 语言精粹"></a>JavaScript 语言精粹</h2><p><a target="_blank" rel="noopener" href="http://book.douban.com/subject/3590768/">http://book.douban.com/subject/3590768/</a></p>
<p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson14/1.png"></p>
<p>这本书很薄，只有 155 页，但该讲的几乎都讲了。大家想办法搞来看看吧（我总不能很没节操地给个电子版 PDF 链接在这里吧）。</p>
<p>js 这门语言，水很浅。没有太复杂的地方可以钻，但特么的坑又多。</p>
<p>上面的那本书是一定要看的。这本书专注在讲 js 语法，其他 js 的书都过多地涉及了浏览器知识。</p>
<h2 id="JavaScript-之美"><a href="#JavaScript-之美" class="headerlink" title="JavaScript 之美"></a>JavaScript 之美</h2><ul>
<li>其一：<a target="_blank" rel="noopener" href="http://fxck.it/post/72326363595">http://fxck.it/post/72326363595</a></li>
<li>其二：<a target="_blank" rel="noopener" href="http://fxck.it/post/73513189448">http://fxck.it/post/73513189448</a></li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>js 前端不懂有什么好办法，后端的话，很方便。</p>
<p>用 node 官方的 <code>util</code> 库，下面是直接从官网摘抄来的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&quot;util&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyStream</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    events.EventEmitter.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(MyStream, events.EventEmitter);</span><br><span class="line"></span><br><span class="line">MyStream.prototype.write = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.emit(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> MyStream();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stream <span class="keyword">instanceof</span> events.EventEmitter); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(MyStream.super_ === events.EventEmitter); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Received data: &quot;&#x27;</span> + data + <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">stream.write(<span class="string">&quot;It works!&quot;</span>); <span class="comment">// Received data: &quot;It works!&quot;</span></span><br></pre></td></tr></table></figure>

<p>js 是面向对象的，但是是“基于原型的面向对象”，没有类。没有多重继承，没有接口。没有结构体，没有枚举类型。</p>
<p>但它的字面量哈希和 function 都足够灵活，拼拼凑凑，上面那些东西都能“模拟”着用。</p>
<p>说到没有类的这个问题，很多人总是要纠正其他人关于 js 原型的理解的。我觉得这是没有必要的。基于原型又不是很牛逼，ES6不是照样给出了 class 关键字吗。不管类还是原型都是为了抽象，烂的东西始终烂，不好理解的始终不好理解。</p>
<p>最近学习 ios 的 swift，看见里面有不少相比 objc 舒服的改进。比如 objc 的“方法调用”，学的是 smalltalk 那一套，那不叫方法调用，而是消息传递。结果 swift 里面不照样是方法调用的形式？</p>
<h2 id="callback-hell"><a href="#callback-hell" class="headerlink" title="callback hell"></a>callback hell</h2><p>用 eventproxy 和 async 已经能解决大部分问题。剩下的小部分问题，肯定是设计错误。：）</p>
<p>参见：</p>
<ul>
<li>《使用 eventproxy 控制并发》：<a target="_blank" rel="noopener" href="https://github.com/alsotang/node-lessons/tree/master/lesson4">https://github.com/alsotang/node-lessons/tree/master/lesson4</a></li>
<li>《使用 async 控制并发》：<a target="_blank" rel="noopener" href="https://github.com/alsotang/node-lessons/tree/master/lesson5">https://github.com/alsotang/node-lessons/tree/master/lesson5</a></li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>写 js 很少去定义类。Object 的便利在多数其他语言需要定义类的场景下都能直接用。</p>
<p>js 中，用好 Number，String，Array，Object 和 Function 就够了。有时用用 RegExp。</p>
<p>用于 js 这门语言本身的残废，大多数时候都采用“约定胜于配置”的思想来交互合作。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>很常规，C 语言那套。</p>
<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><p>C 语言那套。二进制操作并不会降低效率，V8 很聪明的。</p>
<h2 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h2><p>也就是帮一个对象的属性定义 get 和 set 方法，通过 <code>obj.value</code> 和 <code>obj.value=</code> 的形式来调用。</p>
<p>koa(<a target="_blank" rel="noopener" href="http://koajs.com/">http://koajs.com/</a> ) 把这套玩得炉火纯青。</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>无</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>手动帮你需要转换的类型的类定义 <code>.toxxx</code> 方法，比如 <code>.toString</code>，<code>.toJSON</code>，<code>toNumber</code>。</p>
<p>js 的隐式类型转换用一次坑一次。</p>
<h2 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h2><p>在 js 中，务必使用 <code>===</code> 三个等于号来比较对象，或者自定义方法来比较，不要使用 <code>==</code>。</p>
<p>我最近做一个项目，从数据库中取出的数据，虽然应该是字符型的，但有时它们是 String 的表示，有时是 Number 的表示。为了省事，会有人直接用 <code>==</code> 来对它们进行比较。这种时候，建议在比较时，把它们都转成 String 类型，然后用 <code>===</code> 来比较。</p>
<p>比如 <code>var x = 31243; var y = &#39;31243&#39;</code>，比较时，这么做：<code>String(x) === String(y)</code></p>
<h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>随便弄。</p>
<p>function 构造函数、闭包、字面量哈希，都可以混在一起写，多少层都行，无限制。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>当无法接触一个类的源码，又想帮这个类新增方法的时候。操作它的 prototype 就好了。但不推荐！</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>js 中，匿名函数非常的方便，有效利用函数式编程的特性可以使人写代码时心情愉悦。</p>
<p>使用 lodash：<a target="_blank" rel="noopener" href="https://lodash.com/docs">https://lodash.com/docs</a></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>类型都经常忽略还泛型！every parammeter is 泛型 in js</p>
<h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>类定义中，没有 public private 等关键词，都靠约定。而且经常有人突破约定。</p>
<p>有些 http 方面的库，时不时就去 stub 原生 http 库的方法，0.11 时的 node.js 完全不按章法出牌，所以很多这些库都出现兼容性问题。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>《解密设计模式-王垠》</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alsotang/node-lessons/blob/master/lesson14/%E8%A7%A3%E5%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8E%8B%E5%9E%A0.md">https://github.com/alsotang/node-lessons/blob/master/lesson14/%E8%A7%A3%E5%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8E%8B%E5%9E%A0.md</a></p>
<h2 id="构建大型项目"><a href="#构建大型项目" class="headerlink" title="构建大型项目"></a>构建大型项目</h2><p>从 npm 上面寻找质量高的库，并用质量高的方式拼凑起来。</p>
<h1 id="Mongodb-与-Mongoose-的使用"><a href="#Mongodb-与-Mongoose-的使用" class="headerlink" title="Mongodb 与 Mongoose 的使用"></a>Mongodb 与 Mongoose 的使用</h1><h2 id="目标-13"><a href="#目标-13" class="headerlink" title="目标"></a>目标</h2><p>无明确目标</p>
<h2 id="知识点-13"><a href="#知识点-13" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>了解 mongodb (<a target="_blank" rel="noopener" href="http://www.mongodb.org/">http://www.mongodb.org/</a> )</li>
<li>学习 mongoose 的使用 (<a target="_blank" rel="noopener" href="http://mongoosejs.com/">http://mongoosejs.com/</a> )</li>
</ol>
<h2 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h2><p>mongodb 这个名词相信大家不会陌生吧。有段时间 nosql 的概念炒得特别火，其中 hbase redis mongodb couchdb 之类的名词都相继进入了大众的视野。</p>
<p>hbase 和 redis 和 mongodb 和 couchdb 虽然都属于 nosql 的大范畴。但它们关注的领域是不一样的。hbase 是存海量数据的，redis 用来做缓存，而 mongodb 和 couchdb 则试图取代一些使用 mysql 的场景。</p>
<p>mongodb 的官网是这样介绍自己的：</p>
<blockquote>
<p>MongoDB (from “humongous”) is an open-source document database, and the leading NoSQL database. Written in C++</p>
</blockquote>
<p>开源、文档型、nosql。</p>
<p>其中<strong>文档型</strong>是个重要的概念需要理解。</p>
<p>在 sql 中，我们的数据层级是：数据库（db） -&gt; 表（table） -&gt; 记录（record）-&gt; 字段；在 mongodb 中，数据的层级是：数据库 -&gt; collection -&gt; document -&gt; 字段。这四个概念可以对应得上。</p>
<p>文档型数据这个名字中，“文档”两个字很容易误解。其实这个文档就是 bson 的意思。bson 是 json 的超集，比如 json 中没法储存二进制类型，而 bson 拓展了类型，提供了二进制支持。mongodb 中存储的一条条记录都可以用 bson 来表示。所以你也可以认为，mongodb 是个存 bson 数据的数据库，或是存哈希数据的数据库。</p>
<p>mongodb 相对于它的竞争对手们来说——比如 couchdb，它的一大优势就是尽可能提供与 sql 对应的概念。之前说了，sql 中的记录对应 mongodb 中的 document，记录这东西是一维的，而 document 可以嵌套很多层。在某些场景下，比如存储一个文章的 tags，mongodb 中的字段可以轻松存储数组类型，而 sql 中就需要设计个一对多的表关系出来。</p>
<p>假设有一个 blog 应用，其中有张 Post 表，表中有用户发表的一些博客内容（post）。</p>
<p>这些 post 文档的样子大概会是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> post = &#123;</span><br><span class="line">  title: <span class="string">&#x27;呵呵的一天&#x27;</span>,</span><br><span class="line">  author: <span class="string">&#x27;alsotang&#x27;</span>,</span><br><span class="line">  content: <span class="string">&#x27;今天网速很差&#x27;</span>,</span><br><span class="line">  tags: [<span class="string">&#x27;呵呵&#x27;</span>, <span class="string">&#x27;网速&#x27;</span>, <span class="string">&#x27;差&#x27;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mongodb 中有个最亮眼的特性，就是 <strong>Auto-Sharding</strong>，sharding 的意思可以理解成我们 scale sql 时的分表。</p>
<p>在 mongodb 中，表与表之间是没有联系的，不像 sql 中一样，可以设定外键，可以进行表连接。mongodb 中，也无法支持事务。</p>
<p>所以这样的表，无债一身轻。可以很轻易地 scale 至多个实例（假设实例都有不同的物理位置）上。在 mongodb 中，实时的那些查询，也就只能进行条件查询：某某大于一个值或某某等于一个值。而 sql 中，如果一张表的数据存在了多个实例上的话，当与其他表 join 时候，表之间的运来运去会是个很慢的过程，具体我也不太懂。</p>
<p>反正使用 mongodb 时，一定要思考的两点就是：表 join 到底要不要，事务支持到底要不要。</p>
<p>mongodb 中的索引特性跟 sql 中差不多，只是它对于嵌套的数据类型也提供了支持。在建立复合索引时，mongodb 可以指定不同字段的排序，比如两个字段 <code>is_top</code>（置顶） 和 <code>create_time</code>（创建时间） 要建立复合索引，我们可以指定 is_top 按正序排，create_time 按逆序排。mysql 说是有计划支持这个特性，不过目前也没什么消息。不过这点不重要。</p>
<p>mongodb 中，collection 是 schema-less 的。在 sql 中，我们需要用建表语句来表明数据应该具有的形式，而 mongodb 中，可以在同一张里存各种各样不同的形式的数据。同一个 collection 中，可以有些 document 具有 100 个字段，而另一些，则只具有 5 个字段。如果你分不清这个特性的使用场景，那么请像使用 sql 一样的，尽可能保证一个 collection 中数据格式是统一的。这个 schema-less 的特性，有个比较典型的场景是用来存储日志类型的数据，可以搜搜看这方面的典型场景。</p>
<p>mongodb 和 mysql 要我选的话，无关紧要的应用我会选择 mongodb，就当个简单的存 json 数据的数据库来用；如果是线上应用，肯定还是会选择 mysql。毕竟 sql 比较成熟，而且各种常用场景的最佳实践都有先例了。</p>
<p>我所在的阿里巴巴数据平台，有各种各样的大数据系统。有些做离线计算，一算就是几个小时，算出来的结果被缓存起来，查询时候就可以实时得到结果，只是数据一致性上，不可避免会有 delay；有些做实时运算，可以在 1s 内从几千万条数据中算出一个复杂条件的结果。但它们都提供了 sql 的接口，也就是说，无论底层他们是如何让几百台机器 mapreduce，都让你可以用已有的 sql 知识进行查询。所以还是选择 sql 省事啊。</p>
<p>这里还有个很好玩的网站：<a target="_blank" rel="noopener" href="http://www.mongodb-is-web-scale.com/">http://www.mongodb-is-web-scale.com/</a></p>
<p>顺便说说 mongodb 与 redis 的不同。mongodb 是用来存非临时数据的，可以认为是存在硬盘上，而 redis 的数据可以认为都在内存中，存储临时数据，丢了也无所谓。对于稍微复杂的查询，redis 支持的查询方式太少太少了，几乎可以认为是 key-value 的。据说 instagram 的数据就全部存在 redis 中，用了好几个几十 G 内存的 aws ec2 机器在存。redis 也是支持把数据写入硬盘的，aof 貌似都过时了，好久没关注了。</p>
<p>mongodb 与 hbase 的区别。如果说你已经在考虑使用 hbase 了的话，应该也不用我介绍它们的区别了吧..</p>
<p>主题所限，就不展开讲了。这之间的选择和权衡，说起来真的是个很大的话题。</p>
<p>我对这方面的话题很感兴趣，如果要讨论这方面话题的话，可以去 <a target="_blank" rel="noopener" href="https://cnodejs.org/">https://cnodejs.org/</a> 发个帖，详细描述一下场景然后 at 我（@alsotang）。</p>
<p>mongodb 的官网中有一些特性介绍：</p>
<p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson15/1.png"></p>
<p>其中标有箭头的是基本概念，圆圈的是进阶概念，画叉的不必了解。</p>
<h3 id="安装-mongodb"><a href="#安装-mongodb" class="headerlink" title="安装 mongodb"></a>安装 mongodb</h3><p>课程到这，一直忘记说 mongodb 的安装了。</p>
<p>ubuntu: <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/">http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/</a></p>
<p>mac: <code>$ brew install mongodb</code></p>
<p>装好以后，在命令行 <code>$ mongod</code>，然后另外开个 shell 窗口，输入 <code>$ mongo</code> 就能使用了。</p>
<h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><p>mongoose 是个 odm。odm 的概念对应 sql 中的 orm。也就是 ruby on rails 中的 activerecord 那一层。orm 全称是 <code>Object-Relational Mapping</code>，对象关系映射；而 odm 是 <code>Object-Document Mapping</code>，对象文档映射。</p>
<p>它的作用就是，在程序代码中，定义一下数据库中的数据格式，然后取数据时通过它们，可以把数据库中的 document 映射成程序中的一个对象，这个对象有 .save .update 等一系列方法，和 .title .author 等一系列属性。在调用这些方法时，odm 会根据你调用时所用的条件，自动转换成相应的 mongodb shell 语句帮你发送出去。自然地，在程序中链式调用一个个的方法要比手写数据库操作语句具有更大的灵活性和便利性。</p>
<p>mongoose 的官网给出了类似这样一个示例，我改造了一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 mongoose 这个模块</span></span><br><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"><span class="comment">// 然后连接对应的数据库：mongodb://localhost/test</span></span><br><span class="line"><span class="comment">// 其中，前面那个 mongodb 是 protocol scheme 的名称；localhost 是 mongod 所在的地址；</span></span><br><span class="line"><span class="comment">// 端口号省略则默认连接 27017；test 是数据库的名称</span></span><br><span class="line"><span class="comment">// mongodb 中不需要建立数据库，当你需要连接的数据库不存在时，会自动创建一个出来。</span></span><br><span class="line"><span class="comment">// 关于 mongodb 的安全性，mongodb 我印象中安全机制很残废，用户名密码那套都做得不好，更</span></span><br><span class="line"><span class="comment">// 别提细致的用户权限控制了。不过不用担心，mongodb 的默认配置只接受来自本机的请求，内网都连不上。</span></span><br><span class="line"><span class="comment">// 当需要在内网中为其他机器提供 mongodb 服务时，或许可以去看看 iptables 相关的东西。</span></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面说了，我推荐在同一个 collection 中使用固定的数据形式。</span></span><br><span class="line"><span class="comment">// 在这里，我们创建了一个名为 Cat 的 model，它在数据库中的名字根据传给 mongoose.model 的第一个参数决定，mongoose 会将名词变为复数，在这里，collection 的名字会是 `cats`。</span></span><br><span class="line"><span class="comment">// 这个 model 的定义是，有一个 String 类型的 name，String 数组类型的 friends，Number 类型的 age。</span></span><br><span class="line"><span class="comment">// mongodb 中大多数的数据类型都可以用 js 的原生类型来表示。至于说 String 的长度是多少，Number 的精度是多少。String 的最大限度是 16MB，Number 的整型是 64-bit，浮点数的话，js 中 `0.1 + 0.2` 的结果都是乱来的。。就不指望什么了。。</span></span><br><span class="line"><span class="comment">// 这里可以看到各种示例：http://mongoosejs.com/docs/schematypes.html</span></span><br><span class="line"><span class="keyword">var</span> Cat = mongoose.model(<span class="string">&#x27;Cat&#x27;</span>, &#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  friends: [<span class="built_in">String</span>],</span><br><span class="line">  age: <span class="built_in">Number</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 一个新对象，名叫 kitty</span></span><br><span class="line"><span class="comment">// 接着为 kitty 的属性们赋值</span></span><br><span class="line"><span class="keyword">var</span> kitty = <span class="keyword">new</span> Cat(&#123; <span class="attr">name</span>: <span class="string">&#x27;Zildjian&#x27;</span>, <span class="attr">friends</span>: [<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;jerry&#x27;</span>]&#125;);</span><br><span class="line">kitty.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 .save 方法后，mongoose 会去你的 mongodb 中的 test 数据库里，存入一条记录。</span></span><br><span class="line">kitty.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;meow&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们可以验证一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mongo</span></span><br><span class="line">MongoDB shell version: 2.6.4</span><br><span class="line">connecting to: test</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show dbs</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> use <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show collections</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.cats.find()</span></span><br></pre></td></tr></table></figure>

<p>会发现里面就有一条记录了。</p>
<h3 id="设计个简单博客程序"><a href="#设计个简单博客程序" class="headerlink" title="设计个简单博客程序"></a>设计个简单博客程序</h3><p>如果要写个博客程序练手。数据库可以这样设计</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Post = mongoose.model(<span class="string">&#x27;Post&#x27;</span>, &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  content: <span class="built_in">String</span>,</span><br><span class="line">  author: <span class="built_in">String</span>,</span><br><span class="line">  create_at: <span class="built_in">Date</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>评论就不要自己做了，接入多说：<a target="_blank" rel="noopener" href="http://duoshuo.com/">http://duoshuo.com/</a></p>
<p>编辑器就纯文本好了，用 markdown 写。</p>
<p>用户系统也不做，硬编码几个管理员账号在配置文件中，然后用 http basic auth：<a target="_blank" rel="noopener" href="https://github.com/jshttp/basic-auth">https://github.com/jshttp/basic-auth</a> 来做验证。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cnodejs/nodeclub">https://github.com/cnodejs/nodeclub</a></p>
<p>完。</p>
<h1 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h1><p>众所周知，HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？</p>
<p>比如在淘宝的某个页面中，你进行了登陆操作。当你跳转到商品页时，服务端如何知道你是已经登陆的状态？</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>首先产生了 cookie 这门技术来解决这个问题，cookie 是 http 协议的一部分，它的处理分为如下几步：</p>
<ul>
<li>服务器向客户端发送 cookie。<ul>
<li>通常使用 HTTP 协议规定的 set-cookie 头操作。</li>
<li>规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。</li>
</ul>
</li>
<li>浏览器将 cookie 保存。</li>
<li>每次请求浏览器都会将 cookie 发向服务器。</li>
</ul>
<p>其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种：</p>
<ul>
<li>path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。</li>
<li>expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。</li>
<li>secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</li>
<li>httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。</li>
</ul>
<h3 id="express-中的-cookie"><a href="#express-中的-cookie" class="headerlink" title="express 中的 cookie"></a>express 中的 cookie</h3><p>express 在 4.x 版本之后，session管理和cookies等许多模块都不再直接包含在express中，而是需要单独添加相应模块。</p>
<p>express4 中操作 cookie 使用 <code>cookie-parser</code> 模块(<a target="_blank" rel="noopener" href="https://github.com/expressjs/cookie-parser">https://github.com/expressjs/cookie-parser</a> )。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 首先引入 cookie-parser 这个模块</span></span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 cookieParser 中间件，cookieParser(secret, options)</span></span><br><span class="line"><span class="comment">// 其中 secret 用来加密 cookie 字符串（下面会提到 signedCookies）</span></span><br><span class="line"><span class="comment">// options 传入上面介绍的 cookie 可选参数</span></span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果请求中的 cookie 存在 isVisit, 则输出 cookie</span></span><br><span class="line">  <span class="comment">// 否则，设置 cookie 字段 isVisit, 并设置过期时间为1分钟</span></span><br><span class="line">  <span class="keyword">if</span> (req.cookies.isVisit) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.cookies);</span><br><span class="line">    res.send(<span class="string">&quot;再次欢迎访问&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.cookie(<span class="string">&#x27;isVisit&#x27;</span>, <span class="number">1</span>, &#123;<span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">1000</span>&#125;);</span><br><span class="line">    res.send(<span class="string">&quot;欢迎第一次访问&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率。为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。</p>
<p>session 的运作通过一个 <code>session_id</code> 来进行。<code>session_id</code> 通常是存放在客户端的 cookie 中，比如在 express 中，默认是 <code>connect.sid</code> 这个字段，当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。</p>
<p>这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 <code>connect.sid</code> 字段中。当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低。</p>
<p>session 可以存放在 1）内存、2）cookie本身、3）redis 或 memcached 等缓存中，或者4）数据库中。线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐；cookie session 有安全性问题，下面会提到。</p>
<p>express 中操作 session 要用到 <code>express-session</code> (<a target="_blank" rel="noopener" href="https://github.com/expressjs/session">https://github.com/expressjs/session</a> ) 这个模块，主要的方法就是 <code>session(options)</code>，其中 options 中包含可选参数，主要有：</p>
<ul>
<li>name: 设置 cookie 中，保存 session 的字段名称，默认为 <code>connect.sid</code> 。</li>
<li>store: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等。express 生态中都有相应模块的支持。</li>
<li>secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。</li>
<li>cookie: 设置存放 session id 的 cookie 的相关选项，默认为<ul>
<li>(default: { path: ‘/‘, httpOnly: true, secure: false, maxAge: null })</li>
</ul>
</li>
<li>genid: 产生一个新的 session_id 时，所使用的函数， 默认使用 <code>uid2</code> 这个 npm 包。</li>
<li>rolling: 每个请求都重新设置一个 cookie，默认为 false。</li>
<li>resave: 即使 session 没有被修改，也保存 session 值，默认为 true。</li>
</ul>
<p>1） 在内存中存储 session</p>
<p><code>express-session</code> 默认使用内存来存 session，对于开发调试来说很方便。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 首先引入 express-session 这个模块</span></span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照上面的解释，设置 session 的可选参数</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret: <span class="string">&#x27;recommand 128 bytes random string&#x27;</span>, <span class="comment">// 建议使用 128 个字符的随机字符串</span></span><br><span class="line">  cookie: &#123; <span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">1000</span> &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查 session 中的 isVisit 字段</span></span><br><span class="line">  <span class="comment">// 如果存在则增加一次，否则为 session 设置 isVisit 字段，并初始化为 1。</span></span><br><span class="line">  <span class="keyword">if</span>(req.session.isVisit) &#123;</span><br><span class="line">    req.session.isVisit++;</span><br><span class="line">    res.send(<span class="string">&#x27;&lt;p&gt;第 &#x27;</span> + req.session.isVisit + <span class="string">&#x27;次来此页面&lt;/p&gt;&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    req.session.isVisit = <span class="number">1</span>;</span><br><span class="line">    res.send(<span class="string">&quot;欢迎第一次来这里&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(req.session);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2） 在 redis 中存储 session</p>
<p>session 存放在内存中不方便进程间共享，因此可以使用 redis 等缓存来存储 session。</p>
<p>假设你的机器是 4 核的，你使用了 4 个进程在跑同一个 node web 服务，当用户访问进程1时，他被设置了一些数据当做 session 存在内存中。而下一次访问时，他被负载均衡到了进程2，则此时进程2的内存中没有他的信息，认为他是个新用户。这就会导致用户在我们服务中的状态不一致。</p>
<p>使用 redis 作为缓存，可以使用 <code>connect-redis</code> 模块(<a target="_blank" rel="noopener" href="https://github.com/tj/connect-redis">https://github.com/tj/connect-redis</a> )来得到 redis 连接实例，然后在 session 中设置存储方式为该实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> redisStore = <span class="built_in">require</span>(<span class="string">&#x27;connect-redis&#x27;</span>)(session);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  <span class="comment">// 假如你不想使用 redis 而想要使用 memcached 的话，代码改动也不会超过 5 行。</span></span><br><span class="line">  <span class="comment">// 这些 store 都遵循着统一的接口，凡是实现了那些接口的库，都可以作为 session 的 store 使用，比如都需要实现 .get(keyString) 和 .set(keyString, value) 方法。</span></span><br><span class="line">  <span class="comment">// 编写自己的 store 也很简单</span></span><br><span class="line">  store: <span class="keyword">new</span> redisStore(),</span><br><span class="line">  secret: <span class="string">&#x27;somesecrettoken&#x27;</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(req.session.isVisit) &#123;</span><br><span class="line">    req.session.isVisit++;</span><br><span class="line">    res.send(<span class="string">&#x27;&lt;p&gt;第 &#x27;</span> + req.session.isVisit + <span class="string">&#x27;次来到此页面&lt;/p&gt;&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    req.session.isVisit = <span class="number">1</span>;</span><br><span class="line">    res.send(<span class="string">&#x27;欢迎第一次来这里&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们可以运行 <code>redis-cli</code> 查看结果，如图可以看到 redis 中缓存结果。</p>
<p><img src="https://github.com/Ricardo-Li/node-lessons/blob/master/lesson16/1.png"></p>
<h2 id="各种存储的利弊"><a href="#各种存储的利弊" class="headerlink" title="各种存储的利弊"></a>各种存储的利弊</h2><p>上面我们说到，session 的 store 有四个常用选项：1）内存 2）cookie 3）缓存 4）数据库</p>
<p>其中，开发环境存内存就好了。一般的小程序为了省事，如果不涉及状态共享的问题，用内存 session 也没问题。但内存 session 除了省事之外，没有别的好处。</p>
<p>cookie session 我们下面会提到，现在说说利弊。用 cookie session 的话，是不用担心状态共享问题的，因为 session 的 data 不是由服务器来保存，而是保存在用户浏览器端，每次用户访问时，都会主动带上他自己的信息。当然在这里，安全性之类的，只要遵照最佳实践来，也是有保证的。它的弊端是增大了数据量传输，利端是方便。</p>
<p>缓存方式是最常用的方式了，即快，又能共享状态。相比 cookie session 来说，当 session data 比较大的时候，可以节省网络传输。推荐使用。</p>
<p>数据库 session。除非你很熟悉这一块，知道自己要什么，否则还是老老实实用缓存吧。</p>
<h3 id="signedCookie"><a href="#signedCookie" class="headerlink" title="signedCookie"></a>signedCookie</h3><p>上面都是讲基础，现在讲一些专业点的。</p>
<p>上面有提到</p>
<blockquote>
<p>cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造</p>
</blockquote>
<p>其实不是这样的，那只是为了方便理解才那么写。要知道，计算机领域有个名词叫 <strong>签名</strong>，专业点说，叫 <strong>信息摘要算法</strong>。</p>
<p>比如我们现在面临着一个菜鸟开发的网站，他用 cookie 来记录登陆的用户凭证。相应的 cookie 长这样：<code>dotcom_user=alsotang</code>，它说明现在的用户是 alsotang 这个用户。如果我在浏览器中装个插件，把它改成 <code>dotcom_user=ricardo</code>，服务器一读取，就会误认为我是 ricardo。然后我就可以进行 ricardo 才能进行的操作了。之前 web 开发不成熟的时候，用这招甚至可以黑个网站下来，把 cookie 改成 <code>dotcom_user=admin</code> 就行了，唉，那是个玩黑客的黄金年代啊。</p>
<p>OK，现在我有一些数据，不想存在 session 中，想存在 cookie 中，怎么保证不被篡改呢？答案很简单，签个名。</p>
<p>假设我的服务器有个秘密字符串，是 <code>this_is_my_secret_and_fuck_you_all</code>，我为用户 cookie 的 <code>dotcom_user</code> 字段设置了个值 <code>alsotang</code>。cookie 本应是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">dotcom_user</span>: <span class="string">&#x27;alsotang&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这样的。</p>
<p>而如果我们签个名，比如把 <code>dotcom_user</code> 的值跟我的 secret_string 做个 sha1</p>
<p><code>sha1(&#39;this_is_my_secret_and_fuck_you_all&#39; + &#39;alsotang&#39;) === &#39;4850a42e3bc0d39c978770392cbd8dc2923e3d1d&#39;</code></p>
<p>然后把 cookie 变成这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  dotcom_user: <span class="string">&#x27;alsotang&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;dotcom_user.sig&#x27;</span>: <span class="string">&#x27;4850a42e3bc0d39c978770392cbd8dc2923e3d1d&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，用户就没法伪造信息了。一旦它更改了 cookie 中的信息，则服务器会发现 hash 校验的不一致。</p>
<p>毕竟他不懂我们的 secret_string 是什么，而暴力破解哈希值的成本太高。</p>
<h3 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie-session"></a>cookie-session</h3><del>
上面一直提到 session 可以存在 cookie 中，现在来讲讲具体的思路。这里所涉及的专业名词叫做 对称加密。

<p>假设我们想在用户的 cookie 中存 session data，使用一个名为 <code>session_data</code> 的字段。</p>
<p>存</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sessionData = &#123;<span class="attr">username</span>: <span class="string">&#x27;alsotang&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">company</span>: <span class="string">&#x27;alibaba&#x27;</span>, <span class="attr">location</span>: <span class="string">&#x27;hangzhou&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这段信息的话，可以将 <code>sessionData</code> 与我们的 <code>secret_string</code> 一起做个对称加密，存到 cookie 的 <code>session_data</code> 字段中，只要你的 <code>secret_string</code> 足够长，那么攻击者也是无法获取实际 session 内容的。对称加密之后的内容对于攻击者来说相当于一段乱码。</p>
<p>而当用户下次访问时，我们就可以用 <code>secret_string</code> 来解密 <code>sessionData</code>，得到我们需要的 session data。</p>
<p>signedCookies 跟 cookie-session 还是有区别的：</p>
<p>1）是前者信息可见不可篡改，后者不可见也不可篡改</p>
<p>2）是前者一般是长期保存，而后者是 session cookie<br></del></p>
<p>cookie-session 的实现跟 signedCookies 差不多。</p>
<p>不过 cookie-session 我个人建议不要使用，有受到回放攻击的危险。</p>
<p>回放攻击指的是，比如一个用户，它现在有 100 积分，积分存在 session 中，session 保存在 cookie 中。他先复制下现在的这段 cookie，然后去发个帖子，扣掉了 20 积分，于是他就只有 80 积分了。而他现在可以将之前复制下的那段 cookie 再粘贴回去浏览器中，于是服务器在一些场景下会认为他又有了 100 积分。</p>
<p>如果避免这种攻击呢？这就需要引入一个第三方的手段来验证 cookie session，而验证所需的信息，一定不能存在 cookie 中。这么一来，避免了这种攻击后，使用 cookie session 的好处就荡然无存了。如果为了避免攻击而引入了缓存使用的话，那不如把 cookie session 也一起放进缓存中。</p>
<h3 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session cookie"></a>session cookie</h3><p>初学者容易犯的一个错误是，忘记了 session_id 在 cookie 中的存储方式是 session cookie。即，当用户一关闭浏览器，浏览器 cookie 中的 session_id 字段就会消失。</p>
<p>常见的场景就是在开发用户登陆状态保持时。</p>
<p>假如用户在之前登陆了你的网站，你在他对应的 session 中存了信息，当他关闭浏览器再次访问时，你还是不懂他是谁。所以我们要在 cookie 中，也保存一份关于用户身份的信息。</p>
<p>比如有这样一个用户</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">username</span>: <span class="string">&#x27;alsotang&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">company</span>: <span class="string">&#x27;alibaba&#x27;</span>, <span class="attr">location</span>: <span class="string">&#x27;hangzhou&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以考虑把这四个字段的信息都存在 session 中，而在 cookie，我们用 signedCookies 来存个 username。</p>
<p>登陆的检验过程伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req.session.user) &#123;</span><br><span class="line">  <span class="comment">// 获取 user 并进行下一步</span></span><br><span class="line">  next()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.signedCookies[<span class="string">&#x27;username&#x27;</span>]) &#123;</span><br><span class="line">  <span class="comment">// 如果存在则从数据库中获取这个 username 的信息，并保存到 session 中</span></span><br><span class="line">  getuser(<span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">    req.session.user = user;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 当做为登陆用户处理</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="etag-当做-session，保存-http-会话"><a href="#etag-当做-session，保存-http-会话" class="headerlink" title="etag 当做 session，保存 http 会话"></a>etag 当做 session，保存 http 会话</h3><p>很黑客的一种玩法：<a target="_blank" rel="noopener" href="https://cnodejs.org/topic/5212d82d0a746c580b43d948">https://cnodejs.org/topic/5212d82d0a746c580b43d948</a></p>
<h1 id="《使用-promise-替代回调函数》"><a href="#《使用-promise-替代回调函数》" class="headerlink" title="《使用 promise 替代回调函数》"></a>《使用 promise 替代回调函数》</h1><h2 id="知识点-14"><a href="#知识点-14" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>理解 Promise 概念，为什么需要 promise</li>
<li>学习 q 的 API，利用 q 来替代回调函数(<a target="_blank" rel="noopener" href="https://github.com/kriskowal/q">https://github.com/kriskowal/q</a> )</li>
</ol>
<h2 id="课程内容-12"><a href="#课程内容-12" class="headerlink" title="课程内容"></a>课程内容</h2><p>第五课(<a target="_blank" rel="noopener" href="https://github.com/alsotang/node-lessons/tree/master/lesson5">https://github.com/alsotang/node-lessons/tree/master/lesson5</a> )讲述了如何使用 async 来控制并发。async 的本质是一个流程控制。其实在异步编程中，还有一个更为经典的模型，叫做 Promise/Deferred 模型。</p>
<p>本节我们就来学习这个模型的代表实现：<a target="_blank" rel="noopener" href="https://github.com/kriskowal/q">q</a></p>
<p>首先，我们思考一个典型的异步编程模型，考虑这样一个题目：读取一个文件，在控制台输出这个文件内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>看起来很简单，再进一步: 读取两个文件，在控制台输出这两个文件内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;sample01.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">	fs.readFile(<span class="string">&#x27;sample02.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>要是读取更多的文件呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;sample01.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">	fs.readFile(<span class="string">&#x27;sample02.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">		fs.readFile(<span class="string">&#x27;sample03.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">			fs.readFile(<span class="string">&#x27;sample04.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码就是臭名昭著的邪恶金字塔(Pyramid of Doom)。可以使用async来改善这段代码，但是在本课中我们要用promise/defer来改善它。</p>
<h2 id="promise基本概念"><a href="#promise基本概念" class="headerlink" title="promise基本概念"></a>promise基本概念</h2><p>先学习promise的基本概念。</p>
<ul>
<li>promise只有三种状态，未完成，完成(fulfilled)和失败(rejected)。</li>
<li>promise的状态可以由未完成转换成完成，或者未完成转换成失败。</li>
<li>promise的状态转换只发生一次</li>
</ul>
<p>promise有一个then方法，then方法可以接受3个函数作为参数。前两个函数对应promise的两种状态fulfilled, rejected的回调函数。第三个函数用于处理进度信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promiseSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//当promise状态变成fulfilled时，调用此函数</span></span><br><span class="line">	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//当promise状态变成rejected时，调用此函数</span></span><br><span class="line">	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">progress</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//当返回进度信息时，调用此函数</span></span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<p>学习一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取初始promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInitialPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为promise设置三种状态的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getInitialPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">success</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(success);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">progress</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(progress);</span><br><span class="line">&#125;);</span><br><span class="line">defer.notify(<span class="string">&#x27;in progress&#x27;</span>);<span class="comment">//控制台打印in progress</span></span><br><span class="line">defer.resolve(<span class="string">&#x27;resolve&#x27;</span>);   <span class="comment">//控制台打印resolve</span></span><br><span class="line">defer.reject(<span class="string">&#x27;reject&#x27;</span>);		<span class="comment">//没有输出。promise的状态只能改变一次</span></span><br></pre></td></tr></table></figure>

<h2 id="promise的传递"><a href="#promise的传递" class="headerlink" title="promise的传递"></a>promise的传递</h2><p>then方法会返回一个promise，在下面这个例子中，我们用outputPromise指向then返回的promise。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span> (<span class="params">fulfilled</span>) </span>&#123;</span><br><span class="line">	&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">rejected</span>) </span>&#123;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<p>现在outputPromise就变成了受 <code>function(fulfilled)</code> 或者 <code>function(rejected)</code>控制状态的promise了。怎么理解这句话呢？</p>
<ul>
<li>当function(fulfilled)或者function(rejected)返回一个值，比如一个字符串，数组，对象等等，那么outputPromise的状态就会变成fulfilled。</li>
</ul>
<p>在下面这个例子中，我们可以看到，当我们把inputPromise的状态通过defer.resovle()变成fulfilled时，控制台输出fulfilled.</p>
<p>当我们把inputPromise的状态通过defer.reject()变成rejected，控制台输出rejected</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</span></span><br><span class="line"><span class="comment"> * 将then返回的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * function(fulfilled) 和 function(rejected) 通过返回字符串将outputPromise的状态由</span></span><br><span class="line"><span class="comment"> * 未完成改变为fulfilled</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)，控制台打印&#x27;fulfilled: fulfilled&#x27;。</span></span><br><span class="line"><span class="comment"> * 当outputPromise状态由未完成变成rejected, 调用function(rejected), 控制台打印&#x27;rejected: rejected&#x27;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.reject(); <span class="comment">//输出 fulfilled: rejected</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.resolve(); //输出 fulfilled: fulfilled</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当function(fulfilled)或者function(rejected)抛出异常时，那么outputPromise的状态就会变成rejected</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</span></span><br><span class="line"><span class="comment"> * 将then返回的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * function(fulfilled) 和 function(rejected) 通过抛出异常将outputPromise的状态由</span></span><br><span class="line"><span class="comment"> * 未完成改变为reject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fulfilled&#x27;</span>);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)。</span></span><br><span class="line"><span class="comment"> * 当outputPromise状态由未完成变成rejected, 调用function(rejected)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.reject();     <span class="comment">//控制台打印 rejected [Error:rejected]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.resolve(); //控制台打印 rejected [Error:fulfilled]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当function(fulfilled)或者function(rejected)返回一个promise时，outputPromise就会成为这个新的promise.</li>
</ul>
<p>这样做有什么意义呢? 主要在于聚合结果(Q.all)，管理延时，异常恢复等等</p>
<p>比如说我们想要读取一个文件的内容，然后把这些内容打印出来。可能会写出这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的写法</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	fs.readFile(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然而这样写是错误的，因为function(fulfilled)并没有返回任何值。需要下面的方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</span></span><br><span class="line"><span class="comment"> * 将then返回的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * function(fulfilled)将新的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * 未完成改变为reject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> myDefer = Q.defer();</span><br><span class="line">	fs.readFile(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!err &amp;&amp; data) &#123;</span><br><span class="line">			myDefer.resolve(data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> myDefer.promise;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)，控制台打印test.txt文件内容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.reject();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.resolve(); <span class="comment">//控制台打印出 test.txt 的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="方法传递"><a href="#方法传递" class="headerlink" title="方法传递"></a>方法传递</h2><p>方法传递有些类似于Java中的try和catch。当一个异常没有响应的捕获时，这个异常会接着往下传递。</p>
<p>方法传递的含义是当一个状态没有响应的回调函数，就会沿着then往下找。</p>
<ul>
<li>没有提供function(rejected)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>如果inputPromise的状态由未完成变成rejected, 此时对rejected的处理会由outputPromise来完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，这个rejected会传向outputPromise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.reject(<span class="string">&#x27;inputpromise rejected&#x27;</span>); <span class="comment">//控制台打印rejected: inputpromise rejected</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.resolve();</span></span><br></pre></td></tr></table></figure>

<ul>
<li>没有提供function(fulfilled)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="literal">null</span>,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>如果inputPromise的状态由未完成变成fulfilled, 此时对fulfil的处理会由outputPromise来完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，传递给outputPromise</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</span></span><br><span class="line"><span class="comment"> * function(fulfilled)将新的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * 未完成改变为reject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="literal">null</span>,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.reject(&#x27;inputpromise rejected&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.resolve(<span class="string">&#x27;inputpromise fulfilled&#x27;</span>); <span class="comment">//控制台打印fulfilled: inputpromise fulfilled</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用fail(function(error))来专门针对错误处理，而不是使用then(null,function(error))</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().fail(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>看这个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，调用then(function(fulfilled))</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用fail(function(error))</span></span><br><span class="line"><span class="comment"> * function(fulfilled)将新的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * 未完成改变为reject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fulfilled;</span><br><span class="line">&#125;).fail(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;fail: &#x27;</span> + error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.reject(<span class="string">&#x27;inputpromise rejected&#x27;</span>);<span class="comment">//控制台打印fail: inputpromise rejected</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.resolve(&#x27;inputpromise fulfilled&#x27;);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用progress(function(progress))来专门针对进度信息进行处理，而不是使用 <code>then(function(success)&#123;&#125;,function(error)&#123;&#125;,function(progress)&#123;&#125;)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取初始promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInitialPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为promise设置progress信息处理函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInitialPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">success</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).progress(<span class="function"><span class="keyword">function</span>(<span class="params">progress</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(progress);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">defer.notify(<span class="number">1</span>);</span><br><span class="line">defer.notify(<span class="number">2</span>); <span class="comment">//控制台打印1，2</span></span><br></pre></td></tr></table></figure>

<h2 id="promise链"><a href="#promise链" class="headerlink" title="promise链"></a>promise链</h2><p>promise链提供了一种让函数顺序执行的方法。</p>
<p>函数顺序执行是很重要的一个功能。比如知道用户名，需要根据用户名从数据库中找到相应的用户，然后将用户信息传给下一个函数进行处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个模拟数据库</span></span><br><span class="line"><span class="keyword">var</span> users = [&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;andrew&#x27;</span>,<span class="string">&#x27;passwd&#x27;</span>:<span class="string">&#x27;password&#x27;</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsername</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">username</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user;</span><br><span class="line">	users.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(element.name === username) &#123;</span><br><span class="line">			user = element;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//promise链</span></span><br><span class="line">getUsername().then(<span class="function"><span class="keyword">function</span>(<span class="params">username</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> getUser(username);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">defer.resolve(<span class="string">&#x27;andrew&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>我们通过两个then达到让函数顺序执行的目的。</p>
<p>then的数量其实是没有限制的。当然，then的数量过多，要手动把他们链接起来是很麻烦的。比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(initialVal).then(bar).then(baz).then(qux)</span><br></pre></td></tr></table></figure>

<p>这时我们需要用代码来动态制造promise链</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [foo,bar,baz,qux]</span><br><span class="line"><span class="keyword">var</span> result = Q(initialVal)</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">	result = result.then(func)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>当然，我们可以再简洁一点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [foo,bar,baz,qux]</span><br><span class="line">funcs.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,current</span>),<span class="title">Q</span>(<span class="params">initialVal</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pre.then(current)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>看一个具体的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result);</span><br><span class="line">	<span class="keyword">return</span> result+result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手动链接</span></span><br><span class="line">Q(<span class="string">&#x27;hello&#x27;</span>).then(foo).then(foo).then(foo); 									<span class="comment">//控制台输出： hello</span></span><br><span class="line">																			<span class="comment">//			   hellohello</span></span><br><span class="line">																			<span class="comment">//			   hellohellohello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态链接</span></span><br><span class="line"><span class="keyword">var</span> funcs = [foo,foo,foo];</span><br><span class="line"><span class="keyword">var</span> result = Q(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">	result = result.then(func);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//精简后的动态链接</span></span><br><span class="line">funcs.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,current</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> prev.then(current);</span><br><span class="line">&#125;,Q(<span class="string">&#x27;hello&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>对于promise链，最重要的是需要理解为什么这个链能够顺序执行。如果能够理解这点，那么以后自己写promise链可以说是轻车熟路啊。</p>
<h2 id="promise组合"><a href="#promise组合" class="headerlink" title="promise组合"></a>promise组合</h2><p>回到我们一开始读取文件内容的例子。如果现在让我们把它改写成promise链，是不是很简单呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>),</span><br><span class="line">	fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFileContent</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> defer = Q.defer();</span><br><span class="line">		fs.readFile(fileName,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">		  <span class="keyword">if</span>(!err &amp;&amp; data) &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(data);</span><br><span class="line">			defer.resolve();</span><br><span class="line">		  &#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> defer.promise;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手动链接</span></span><br><span class="line">printFileContent(<span class="string">&#x27;sample01.txt&#x27;</span>)()</span><br><span class="line">	.then(printFileContent(<span class="string">&#x27;sample02.txt&#x27;</span>))</span><br><span class="line">	.then(printFileContent(<span class="string">&#x27;sample03.txt&#x27;</span>))</span><br><span class="line">	.then(printFileContent(<span class="string">&#x27;sample04.txt&#x27;</span>));   <span class="comment">//控制台顺序打印sample01到sample04的内容</span></span><br></pre></td></tr></table></figure>

<p>很有成就感是不是。然而如果仔细分析，我们会发现为什么要他们顺序执行呢，如果他们能够并行执行不是更好吗? 我们只需要在他们都执行完成之后，得到他们的执行结果就可以了。</p>
<p>我们可以通过Q.all([promise1,promise2…])将多个promise组合成一个promise返回。<br>注意：</p>
<ol>
<li>当all里面所有的promise都fulfil时，Q.all返回的promise状态变成fulfil</li>
<li>当任意一个promise被reject时，Q.all返回的promise状态立即变成reject</li>
</ol>
<p>我们来把上面读取文件内容的例子改成并行执行吧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *读取文件内容</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFileContent</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//Todo: 这段代码不够简洁。可以使用Q.denodeify来简化</span></span><br><span class="line">		<span class="keyword">var</span> defer = Q.defer();</span><br><span class="line">		fs.readFile(fileName,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">		  <span class="keyword">if</span>(!err &amp;&amp; data) &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(data);</span><br><span class="line">			defer.resolve(fileName + <span class="string">&#x27; success &#x27;</span>);</span><br><span class="line">		  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			defer.reject(fileName + <span class="string">&#x27; fail &#x27;</span>);</span><br><span class="line">		  &#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q.all([printFileContent(<span class="string">&#x27;sample01.txt&#x27;</span>),printFileContent(<span class="string">&#x27;sample02.txt&#x27;</span>),printFileContent(<span class="string">&#x27;sample03.txt&#x27;</span>),printFileContent(<span class="string">&#x27;sample04.txt&#x27;</span>)])</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">success</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(success);</span><br><span class="line">	&#125;); <span class="comment">//控制台打印各个文件内容 顺序不一定</span></span><br></pre></td></tr></table></figure>

<p>现在知道Q.all会在任意一个promise进入reject状态后立即进入reject状态。如果我们需要等到所有的promise都发生状态后(有的fulfil, 有的reject)，再转换Q.all的状态, 这时我们可以使用Q.allSettled</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>),</span><br><span class="line">	fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *读取文件内容</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFileContent</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//Todo: 这段代码不够简洁。可以使用Q.denodeify来简化</span></span><br><span class="line">	<span class="keyword">var</span> defer = Q.defer();</span><br><span class="line">	fs.readFile(fileName,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">	  <span class="keyword">if</span>(!err &amp;&amp; data) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data);</span><br><span class="line">		defer.resolve(fileName + <span class="string">&#x27; success &#x27;</span>);</span><br><span class="line">	  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		defer.reject(fileName + <span class="string">&#x27; fail &#x27;</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q.allSettled([printFileContent(<span class="string">&#x27;nosuchfile.txt&#x27;</span>),printFileContent(<span class="string">&#x27;sample02.txt&#x27;</span>),printFileContent(<span class="string">&#x27;sample03.txt&#x27;</span>),printFileContent(<span class="string">&#x27;sample04.txt&#x27;</span>)])</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">		results.forEach(</span><br><span class="line">			<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(result.state);</span><br><span class="line">			&#125;</span><br><span class="line">		);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="结束promise链"><a href="#结束promise链" class="headerlink" title="结束promise链"></a>结束promise链</h2><p>通常，对于一个promise链，有两种结束的方式。第一种方式是返回最后一个promise</p>
<p>如 <code>return foo().then(bar);</code></p>
<p>第二种方式就是通过done来结束promise链</p>
<p>如 <code>foo().then(bar).done()</code></p>
<p>为什么需要通过done来结束一个promise链呢? 如果在我们的链中有错误没有被处理，那么在一个正确结束的promise链中，这个没被处理的错误会通过异常抛出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params">msg,timeout,opt</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> defer = Q.defer();</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(msg);</span><br><span class="line">		<span class="keyword">if</span>(opt)</span><br><span class="line">			defer.reject(msg);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			defer.resolve(msg);</span><br><span class="line">	&#125;,timeout);</span><br><span class="line">	<span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *没有用done()结束的promise链</span></span><br><span class="line"><span class="comment"> *由于getPromse(&#x27;2&#x27;,2000,&#x27;opt&#x27;)返回rejected, getPromise(&#x27;3&#x27;,1000)就没有执行</span></span><br><span class="line"><span class="comment"> *然后这个异常并没有任何提醒，是一个潜在的bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getPromise(<span class="string">&#x27;1&#x27;</span>,<span class="number">3000</span>)</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">&#x27;2&#x27;</span>,<span class="number">2000</span>,<span class="string">&#x27;opt&#x27;</span>)&#125;)</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">&#x27;3&#x27;</span>,<span class="number">1000</span>)&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *用done()结束的promise链</span></span><br><span class="line"><span class="comment"> *有异常抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getPromise(<span class="string">&#x27;1&#x27;</span>,<span class="number">3000</span>)</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">&#x27;2&#x27;</span>,<span class="number">2000</span>,<span class="string">&#x27;opt&#x27;</span>)&#125;)</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">&#x27;3&#x27;</span>,<span class="number">1000</span>)&#125;)</span><br><span class="line">	.done();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>当你理解完上面所有的知识点时，你就会正确高效的使用promise了。本节只是讲了promise的原理和几个基本的API，不过你掌握了这些之后，再去看q的文档，应该很容易就能理解各个api的意图。</p>
<h1 id="《何为-connect-中间件》"><a href="#《何为-connect-中间件》" class="headerlink" title="《何为 connect 中间件》"></a>《何为 connect 中间件》</h1><h2 id="目标-14"><a href="#目标-14" class="headerlink" title="目标"></a>目标</h2><ol>
<li>理解中间件的概念</li>
<li>了解 Connect 的实现</li>
</ol>
<h2 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h2><ol>
<li>原生 httpServer 遇到的问题</li>
<li>中间件思想</li>
<li>Connect 实现</li>
<li>Express 简介</li>
</ol>
<p>这是从 httpServer 到 Express 的升级过程。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>Nodejs 的经典 httpServer 代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(requestHandler);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">&#x27;hello visitor!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>里面的函数 <code>requestHandler</code> 就是所有http请求的响应函数，即所有的请求都经过这个函数的处理，是所有请求的入口函数。</p>
<p>通过 requestHandler 函数我们能写一些简单的 http 逻辑，比如上面的例子，所有请求都返回 <code>hello visitor!</code>。</p>
<p>然而，我们的业务逻辑不可能这么简单。例如：需要实现一个接口，要做的是当请求过来时，先判断来源的请求是否包含请求体，然后判断请求体中的id是不是在数据库中存在，最后若存在则返回true，不存在则返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 检测请求中请求体是否存在，若存在则解析请求体；</span><br><span class="line">1. 查看请求体中的id是否存在，若存在则去数据库查询；</span><br><span class="line">1. 根据数据库结果返回约定的值；</span><br></pre></td></tr></table></figure>

<p>我们首先想到的，抽离函数，每个逻辑一个函数，简单好实现低耦合好维护。</p>
<p>实现代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseBody</span>(<span class="params">req, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//根据http协议从req中解析body</span></span><br><span class="line">  callback(<span class="literal">null</span>, body);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIdInDatabase</span>(<span class="params">body, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//根据body.id在Database中检测，返回结果</span></span><br><span class="line">  callback(<span class="literal">null</span>, dbResult);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnResult</span>(<span class="params">dbResult, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dbResult &amp;&amp; dbResult.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;false&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  parseBody(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</span><br><span class="line">    checkIdInDatabase(body, <span class="function"><span class="keyword">function</span>(<span class="params">err, dbResult</span>) </span>&#123;</span><br><span class="line">      returnResult(dbResult, res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的解决方案解决了包含三个步骤的业务问题，出现了3个 <code>&#125;);</code> 还有3个 <code>err</code> 需要处理，上面的写法可以得达到预期效果。</p>
<p>然而，业务逻辑越来越复杂，会出发展成30个回调逻辑，那么就出现了30个 <code>&#125;);</code> 及30个 <code>err</code>异常。更严重的是，到时候写代码根本看不清自己写的逻辑在30层中的哪一层，极其容易出现 <strong>多次返回</strong> 或返回地方不对等问题，这就是 <strong>回调金字塔</strong> 问题了。</p>
<p>大多数同学应该能想到解决回调金字塔的办法，朴灵的《深入浅出Node.js》里讲到的三种方法。下面列举了这三种方法加上ES6新增的Generator，共四种解决办法。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/JacksonTian/eventproxy">EventProxy</a> —— 事件发布订阅模式(第四课讲到)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/petkaantonov/bluebird">BlueBird</a> —— Promise方案(第十七课讲到)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/caolan/async">Async</a> —— 异步流程控制库(第五课讲到)</li>
<li><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/generator">Generator</a> —— ES6原生Generator</li>
</ul>
<p>理论上，这四种都能解决回调金字塔问题。而Connect和Express用的是 <code>类似异步流程控制的思想</code> 。</p>
<p><a name="next"></a><br>关于异步流程控制库下面简要介绍下，或移步<a target="_blank" rel="noopener" href="https://github.com/alsotang/node-lessons/tree/master/lesson5">@第五课</a>。<br>异步流程控制库首先要求用户传入待执行的函数列表，记为funlist。流程控制库的任务是让这些函数 <strong>顺序执行</strong> 。</p>
<p>callback是控制顺序执行的关键，funlist里的函数每当调用callback会执行下一个funlist里的函数</p>
<p>我们动手实现一个类似的链式调用，其中 <code>funlist</code> 更名为 <code>middlewares</code>、<code>callback</code> 更名为 <code>next</code>，码如下：</p>
<p><a name="middlewares" comment="middlewares锚点"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> middlewares = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    parseBody(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">      req.body = body;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    checkIdInDatabase(req.body.id, <span class="function"><span class="keyword">function</span>(<span class="params">err, rows</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">      res.dbResult = rows;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.dbResult &amp;&amp; res.dbResult.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      res.end(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res.end(<span class="string">&#x27;false&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//由middlewares链式调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.end(<span class="string">&#x27;error:&#x27;</span>, err.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i&lt;middlewares.length) &#123;</span><br><span class="line">      middlewares[i++](req, res, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//触发第一个middleware</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用middlewares+next完成了业务逻辑的 <code>链式调用</code>，而middlewares里的每个函数，都是一个 <code>中间件</code>。</p>
<p>整体思路是：</p>
<ol>
<li>将所有 <code>处理逻辑函数(中间件)</code> 存储在一个list中；</li>
<li>请求到达时 <code>循环调用</code> list中的 <code>处理逻辑函数(中间件)</code>；</li>
</ol>
<h1 id="Connect的实现"><a href="#Connect的实现" class="headerlink" title="Connect的实现"></a><a target="_blank" rel="noopener" href="https://github.com/senchalabs/connect">Connect</a>的实现</h1><p>Connect的思想跟上面阐述的思想基本一样，先将处理逻辑存起来，然后循环调用。</p>
<p>Connect中主要有五个函数<br>PS: Connect的核心代码是200+行，建议对照<a href="https://github.com/senchalabs/connect/blob/master/index.js" target="_blank">源码</a>看下面的函数介绍。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td>createServer</td>
<td align="center">包装httpServer形成app</td>
</tr>
<tr>
<td>listen</td>
<td align="center">监听端口函数</td>
</tr>
<tr>
<td>use</td>
<td align="center">向middlewares里面放入业务逻辑</td>
</tr>
<tr>
<td>handle</td>
<td align="center">上一章的requestHandler函数增强版</td>
</tr>
<tr>
<td>call</td>
<td align="center">业务逻辑的真正执行者</td>
</tr>
</tbody></table>
<h2 id="createServer"><a href="#createServer" class="headerlink" title="createServer()"></a>createServer()</h2><p><strong>输入</strong>:</p>
<p>无</p>
<p><strong>执行过程</strong>:</p>
<ol>
<li>app是一个函数对象(包含handle方法)</li>
<li>app具有Event所有属性(详见<a target="_blank" rel="noopener" href="https://github.com/jaredhanson/utils-merge">utils-merge</a>，十行代码)</li>
<li>app有route属性(路由)、和stack属性(用于存储中间件，类似上面的<a href="#middlewares">middlewares</a>)</li>
</ol>
<p><strong>输出</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     app is function(req, res, next) &#123;...&#125;;</span><br><span class="line">      |</span><br><span class="line">  +---+---+</span><br><span class="line">  |  has  |</span><br><span class="line">route   stack</span><br></pre></td></tr></table></figure>

<h2 id="app-use-route-fn"><a href="#app-use-route-fn" class="headerlink" title="app.use(route, fn)"></a>app.use(route, fn)</h2><p>作用是向stack中添加 <code>逻辑处理函数</code> (中间件)。</p>
<p><strong>输入</strong>:</p>
<ol>
<li>route 可省略，默认’/‘</li>
<li>fn 具体的业务处理逻辑</li>
</ol>
<p><strong>tips:</strong></p>
<p>上面的fn表示处理逻辑，它可以是</p>
<ol>
<li>一个普通的 <code>function(req,res[,next])&#123;&#125;</code>；</li>
<li>一个<a target="_blank" rel="noopener" href="https://lodejs.org/api/http.html#http_class_http_server">httpServer</a>；</li>
<li>另一个connect的app对象(<strong>sub app特性</strong>)；</li>
</ol>
<p>由于它们的本质都是 <code>处理逻辑</code>，都可以用一个 <code>function(req,res,next)&#123;&#125;</code>将它们概括起来，Connect把他们都转化为这个函数，然后把它们存起来。</p>
<p>如何将这三种分别转换为 function(req, res, next) {}的形式呢？</p>
<ol>
<li>不用转换；</li>
<li>httpServer的定义是“对事件’request’后handler的对象”，我们可以从httpServer.listeners(‘request’)中得到这个函数；</li>
<li>另一个connect对象，而connect()返回的app就是function(req, res, out) {}；</li>
</ol>
<p><strong>执行过程</strong>:</p>
<ol>
<li>将三种<code>处理逻辑</code>统一转换为<code>function(req,res,next)&#123;&#125;</code>的形式表示。</li>
<li>把这个<code>处理逻辑</code>与route一起，放入<code>stack</code>中(存储处理逻辑，route用来匹配路由)</li>
</ol>
<p>核心代码片段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//route是路由路径，handle是一个`function(req, res, next) &#123;...&#125;`形式的业务逻辑</span></span><br><span class="line"><span class="built_in">this</span>.stack.push(&#123; <span class="attr">route</span>: path, <span class="attr">handle</span>: handle &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>返回</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回自己，可以完成链式调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br></pre></td></tr></table></figure>

<p><strong>总结:</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.use(<span class="string">&#x27;/api&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.stack.push(&#123;<span class="attr">route</span>: <span class="string">&#x27;/api&#x27;</span>, <span class="attr">handle</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>最后，app.stack里 <strong>顺序存储</strong> 了所有的 <strong>逻辑处理函数</strong> (中间件)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.stack = [function1, function2, function3, ... function30];</span><br></pre></td></tr></table></figure>

<h2 id="app-handle-req-res-out"><a href="#app-handle-req-res-out" class="headerlink" title="app.handle(req, res, out)"></a>app.handle(req, res, out)</h2><p>这个函数就是请求到达时，负责 <code>顺序调用</code> 我们存储在stack中的 <code>逻辑处理函数</code> (中间件)函数，类似上一章的requestHandler。</p>
<p><strong>输入:</strong></p>
<ol>
<li>req是Nodejs本身的可读流，不做过多介绍</li>
<li>res是Nodejs本身的可写流，不做过多介绍</li>
<li>out是为了Connect的 <strong>sub app特性</strong> 而设计的参数，这个特性可以暂时忽略，这个参数我们暂时不关心</li>
</ol>
<p><strong>处理过程:</strong></p>
<p>可以回头看一下上面的<a href="#middlewares">requestHandler函数</a>，handle的实现是这个函数的增强版</p>
<ol>
<li>取得stack(存储<code>逻辑处理函数</code>列表)，index(列表下标)</li>
<li>构建next函数，next的作用是执行下一个<code>逻辑处理函数</code></li>
<li>触发第一个next，触发链式调用</li>
</ol>
<p><strong>next函数实现:</strong></p>
<p>next函数实现在handle函数体内，用来<code>顺序执行处理逻辑</code>，它是异步流程控制库的核心，不明白它的作用请看<a href="#next">上面的异步流程控制库简介</a></p>
<p>path是请求路径，route是<code>逻辑处理函数</code>自带的属性。</p>
<ol>
<li>取得下一个<code>逻辑处理函数</code>;</li>
<li>若路由不匹配，跳过此逻辑;</li>
<li>若路由匹配<a href="#call">下面的call</a>执行匹配到的<code>逻辑处理函数</code></li>
</ol>
<p>tips: 跟上一章最后的代码一样，每个<code>逻辑处理函数</code>调用<code>next</code>来让后面的函数执行，存储在stack中的函数就实现了<code>链式调用</code>。不一定所有的函数都在返回的时候才调用<code>next</code>，为了不影响效率，有的函数可能先调用next，然而自己还没有返回，继续做自己的事情。</p>
<p>核心代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取下一个逻辑逻辑处理函数</span></span><br><span class="line"><span class="number">1</span>:  <span class="keyword">var</span> layer = stack[index++];</span><br><span class="line"><span class="comment">//不匹配时跳过</span></span><br><span class="line"><span class="number">2</span>:  <span class="keyword">if</span> (path.toLowerCase().substr(<span class="number">0</span>, route.length) !== route.toLowerCase()) &#123;</span><br><span class="line">      <span class="keyword">return</span> next(err);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//匹配时执行</span></span><br><span class="line"><span class="number">3</span>:  call(layer.handle, route, err, req, res, next);</span><br></pre></td></tr></table></figure>

<p><strong>返回:</strong></p>
<p>无</p>
<p><strong>总结:</strong></p>
<p>画图总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">request come</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware1 :  不匹配路由，skip</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware2 :  匹配路由，执行</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware3 :  匹配路由，执行</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware4 :  不匹配路由，skip</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p><a name="call"></a></p>
<h2 id="call-handle-route-err-req-res-next"><a href="#call-handle-route-err-req-res-next" class="headerlink" title="call(handle, route, err, req, res, next)"></a>call(handle, route, err, req, res, next)</h2><blockquote>
<p>这里有个比较有趣的知识，<code>console.log(Function.length)</code>会返回函数定义的参数个数。值跟在函数体内执行<code>arguments.length</code>一样。</p>
</blockquote>
<p>Connect中规定<code>function(err, req, res, next) &#123;&#125;</code>形式为错误处理函数，<code>function(req, res, next) &#123;&#125;</code>为正常的业务逻辑处理函数。那么，可以根据Function.length以判断它是否为错误处理函数。</p>
<p><strong>输入:</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>handle</td>
<td align="center">逻辑处理函数</td>
</tr>
<tr>
<td>route</td>
<td align="center">路由</td>
</tr>
<tr>
<td>err</td>
<td align="center">是否发生过错误</td>
</tr>
<tr>
<td>req</td>
<td align="center">Nodejs对象</td>
</tr>
<tr>
<td>res</td>
<td align="center">Nodejs对象</td>
</tr>
<tr>
<td>next</td>
<td align="center">next函数</td>
</tr>
</tbody></table>
<p><strong>处理过程:</strong></p>
<ol>
<li>是否有错误，本次handle是否是错误处理函数;</li>
<li>若有错误且handle为错误处理函数，则执行handle，本函数返回;</li>
<li>若没错误且handle不是错误处理函数，则执行handle，本函数返回;</li>
<li>如果上面两个都不满足，不执行handle，本函数调用next，返回;</li>
</ol>
<p><strong>返回:</strong></p>
<p>无</p>
<p><strong>总结:</strong></p>
<p>call函数是一个执行者，根据当前<code>错误情况</code>和<code>handle类型</code>决定<code>是否执行</code>当前的handle。</p>
<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><p>创建一个httpServer，将Connect自己的业务逻辑作为requestHandler，监听端口</p>
<p>代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<h2 id="图解Connect"><a href="#图解Connect" class="headerlink" title="图解Connect"></a>图解Connect</h2><p>Connect将中间件存储在app.stack中，通过构造handle中的next函数在请求到来时依次调用这些中间件。</p>
<p>图形总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">request               app(out)</span><br><span class="line">   |                          yes</span><br><span class="line">   +------------------&gt;match?-----&gt;middleware1</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        next&lt;----------+</span><br><span class="line">                         |</span><br><span class="line">                         v    yes</span><br><span class="line">                      match?------&gt;middleware2</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        next&lt;----------+</span><br><span class="line">                         |</span><br><span class="line">                         v    yes</span><br><span class="line">                      match?------&gt;middleware3</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        out&lt;-----------+</span><br><span class="line">                         |</span><br><span class="line">   +---------------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">  end(response在处理过程中已经返回了)</span><br></pre></td></tr></table></figure>

<h2 id="Connect的subapp特性"><a href="#Connect的subapp特性" class="headerlink" title="Connect的subapp特性"></a>Connect的subapp特性</h2><p>我们再看看Connect是怎么实现subapp的，比较有趣。</p>
<p>什么是subapp?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var sub_app &#x3D; connect();</span><br><span class="line">var app &#x3D; connect();</span><br><span class="line"></span><br><span class="line">app.use(&#39;&#x2F;route1&#39;, sub_app);</span><br><span class="line">&#x2F;&#x2F; request path: &#39;&#x2F;route1&#x2F;route2&#39;</span><br><span class="line">&#x2F;&#x2F; 由app接收到请求后，切割 path为&#39;&#x2F;route2&#39;转交给sub_app的处理逻辑处理</span><br><span class="line">&#x2F;&#x2F; 再由sub_app返回到app，由app继续向下执行处理逻辑</span><br></pre></td></tr></table></figure>

<p>结合上面的函数画图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">request               app(out1)                 sub_app(out2)</span><br><span class="line">   |</span><br><span class="line">   +---------------&gt;middleware1     +------------&gt;middleware1</span><br><span class="line">                         |          |                 |</span><br><span class="line">                        next        |                next</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                    middleware2-----+            middleware2</span><br><span class="line">                                                      |</span><br><span class="line">                       next&lt;--------+                next</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                     middleware3    |            middleware3</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                        out1        |                out2</span><br><span class="line">                         |          |                 |</span><br><span class="line">   +---------------------+          +-----------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">  end(response在处理过程中已经返回了)</span><br></pre></td></tr></table></figure>

<p>完成上面的sub_app只需要做到两点：</p>
<ol>
<li>从app的调用链进入到sub_app的调用链中;</li>
<li>从sub_app的逻辑回到app的调用链中;</li>
</ol>
<p>connect在handle函数中的第三个参数<code>out</code>为这个特性实现提供可能。<code>out</code>的特点是<code>在middlewares链式调用完成以后调用</code>。<strong>那么将app的next作为sub_app的out传入sub_app的handle中</strong>可以做到sub_app自己的业务逻辑处理完后调用<code>out</code>，即处理权回到了本app的<code>next</code>手里。</p>
<p>上面图中的<code>sub_app.out2===app.next</code>，所以能完成逻辑的交接和sub app调用。</p>
<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a><a target="_blank" rel="noopener" href="https://github.com/strongloop/express">Express</a></h1><p>大家都知道Express是Connect的升级版。</p>
<p>Express不只是Connect的升级版，它还封装了很多对象来方便业务逻辑处理。Express里的Router是Connect的升级版。</p>
<p>Express大概可以分为几个模块</p>
<table>
<thead>
<tr>
<th>模块</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>router</td>
<td align="center">路由模块是Connect升级版</td>
</tr>
<tr>
<td>request</td>
<td align="center">经过Express封装的req对象</td>
</tr>
<tr>
<td>response</td>
<td align="center">经过Express封装的res对象</td>
</tr>
<tr>
<td>application</td>
<td align="center">app上面的各种默认设置</td>
</tr>
</tbody></table>
<p>简要介绍一下每个模块</p>
<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>在Connect中间件特性的基础上，加入了如下特性，是Connect的升级版</p>
<ol>
<li>正则匹配route;</li>
<li>进行将http的方法在route中分解开;</li>
</ol>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>在Request中集成了http.IncomingMessage(可读流+事件)，并在其上增加了新的属性，方便使用，我们最常用的应该是<br>req.param。</p>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>在Response中集成了http.ServerResponse(可写流+事件)，并在其上增加了很多方便返回的函数，有我们熟悉的res.json、<br>res.render、res.redirect、res.sendFile等等。</p>
<p>我们可以拓展它写一个res.sendPersonInfoById。</p>
<blockquote>
<p>关于流的题外话：req.pipe(res)的形式可以“完成发什么就返回什么”，而req.pipe(mylogic).pipe(res)可以添加自己的逻辑，<br>我们的业务逻辑是把流读为String/Object再进行逻辑处理，处理完再推送给另一个stream，有没有可能在流的层面进行逻辑解<br>耦提供服务呢？求大神解答了…至少这种写法在大流量、逻辑简单的情况下是有用的。</p>
</blockquote>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>除了上面的三个模块以外，还需要有个地方存储整个app的属性、设置等。比较常用的是app.engine函数设置模板引擎。</p>
<h2 id="Express小结"><a href="#Express小结" class="headerlink" title="Express小结"></a>Express小结</h2><p>Express是一个中间件机制的httpServer框架，它本身实现了中间件机制，它也包含了中间件。比如3.x版本的Express<br>本身自带bodyParser、cookieSession等中间件，而在4.x中去掉了。包括TJ也写了很多中间件，比如node-querystring、<br>connect-redis等。</p>
<p>实现业务逻辑解耦时，中间件是从纵向的方面进行的逻辑分解，前面的中间件处理的结果可以给后面用，比如bodyParser把解析<br>body的结果放在req.body中，后面的逻辑都可以从req.body中取值。由于中间件是顺序执行的，errHandler一般都放在最后，而log类的中间件则放在比较前面。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Connect用流程控制库的回调函数及中间件的思想来解耦回调逻辑；<br><a target="_blank" rel="noopener" href="https://github.com/koajs/koa">Koa</a>用Generator方法解决回调问题；</p>
<p>我们应该也可以用事件、Promise的方式实现；</p>
<p>PS: 用事件来实现的话还挺期待的，能形成网状的相互调用。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"># javascript</a>
              <a href="/tags/node-js/" rel="tag"># node.js</a>
              <a href="/tags/async/" rel="tag"># async</a>
              <a href="/tags/express/" rel="tag"># express</a>
              <a href="/tags/mocha/" rel="tag"># mocha</a>
              <a href="/tags/session/" rel="tag"># session</a>
              <a href="/tags/cookie/" rel="tag"># cookie</a>
              <a href="/tags/%E5%8C%85%E6%95%99%E4%B8%8D%E4%BC%9A/" rel="tag"># 包教不会</a>
              <a href="/tags/module/" rel="tag"># module</a>
              <a href="/tags/shoule/" rel="tag"># shoule</a>
              <a href="/tags/istanbul/" rel="tag"># istanbul</a>
              <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag"># 正则表达式</a>
              <a href="/tags/benchmark/" rel="tag"># benchmark</a>
              <a href="/tags/this/" rel="tag"># this</a>
              <a href="/tags/%E9%97%AD%E5%8C%85/" rel="tag"># 闭包</a>
              <a href="/tags/Mongodb/" rel="tag"># Mongodb</a>
              <a href="/tags/Mongoose/" rel="tag"># Mongoose</a>
              <a href="/tags/promise/" rel="tag"># promise</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/09/20/ubuntu/" rel="prev" title="ubuntu">
      <i class="fa fa-chevron-left"></i> ubuntu
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/10/01/Node%E5%85%A5%E9%97%A8/" rel="next" title="Node入门">
      Node入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-express-%E5%BA%94%E7%94%A8%E3%80%8B"><span class="nav-number">1.</span> <span class="nav-text">《一个最简单的 express 应用》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87"><span class="nav-number">1.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%91%E6%88%98"><span class="nav-number">1.2.</span> <span class="nav-text">挑战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">1.3.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9"><span class="nav-number">1.4.</span> <span class="nav-text">课程内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-npm"><span class="nav-number">1.4.1.</span> <span class="nav-text">包管理器 npm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6-Express"><span class="nav-number">1.4.2.</span> <span class="nav-text">框架 Express</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86"><span class="nav-number">1.5.</span> <span class="nav-text">补充知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.5.1.</span> <span class="nav-text">端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL"><span class="nav-number">1.5.2.</span> <span class="nav-text">URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E5%A3%B0"><span class="nav-number">1.5.3.</span> <span class="nav-text">尾声</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9D%97%E3%80%8B"><span class="nav-number">2.</span> <span class="nav-text">《学习使用外部模块》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-1"><span class="nav-number">2.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%91%E6%88%98-1"><span class="nav-number">2.2.</span> <span class="nav-text">挑战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-1"><span class="nav-number">2.3.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-1"><span class="nav-number">2.4.</span> <span class="nav-text">课程内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D"><span class="nav-number">2.5.</span> <span class="nav-text">题外话</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E4%BD%BF%E7%94%A8-superagent-%E4%B8%8E-cheerio-%E5%AE%8C%E6%88%90%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%E3%80%8B"><span class="nav-number">3.</span> <span class="nav-text">《使用 superagent 与 cheerio 完成简单爬虫》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-2"><span class="nav-number">3.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%91%E6%88%98-2"><span class="nav-number">3.2.</span> <span class="nav-text">挑战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-2"><span class="nav-number">3.3.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-2"><span class="nav-number">3.4.</span> <span class="nav-text">课程内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E4%BD%BF%E7%94%A8-eventproxy-%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E3%80%8B"><span class="nav-number">4.</span> <span class="nav-text">《使用 eventproxy 控制并发》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-3"><span class="nav-number">4.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%91%E6%88%98-3"><span class="nav-number">4.2.</span> <span class="nav-text">挑战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-3"><span class="nav-number">4.3.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-3"><span class="nav-number">4.4.</span> <span class="nav-text">课程内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E4%BD%BF%E7%94%A8-async-%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E3%80%8B"><span class="nav-number">5.</span> <span class="nav-text">《使用 async 控制并发》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-4"><span class="nav-number">5.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-4"><span class="nav-number">5.2.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-4"><span class="nav-number">5.3.</span> <span class="nav-text">课程内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%EF%BC%9Amocha%EF%BC%8Cshould%EF%BC%8Cistanbul%E3%80%8B"><span class="nav-number">6.</span> <span class="nav-text">《测试用例：mocha，should，istanbul》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-5"><span class="nav-number">6.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-5"><span class="nav-number">6.2.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-5"><span class="nav-number">6.3.</span> <span class="nav-text">课程内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E6%B5%8B%E8%AF%95%EF%BC%9Amocha%EF%BC%8Cchai%EF%BC%8Cphantomjs%E3%80%8B"><span class="nav-number">7.</span> <span class="nav-text">《浏览器端测试：mocha，chai，phantomjs》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-6"><span class="nav-number">7.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-6"><span class="nav-number">7.2.</span> <span class="nav-text">知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E8%84%9A%E6%9C%AC%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">7.2.1.</span> <span class="nav-text">前端脚本单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E6%89%A7%E8%A1%8C"><span class="nav-number">7.2.1.1.</span> <span class="nav-text">浏览器环境执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%8F%8D%E9%A6%88"><span class="nav-number">7.2.1.2.</span> <span class="nav-text">测试反馈</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%EF%BC%9Asupertest%E3%80%8B"><span class="nav-number">8.</span> <span class="nav-text">《测试用例：supertest》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-7"><span class="nav-number">8.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-7"><span class="nav-number">8.2.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-6"><span class="nav-number">8.3.</span> <span class="nav-text">课程内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-cookie-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">8.4.</span> <span class="nav-text">关于 cookie 持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0"><span class="nav-number">8.5.</span> <span class="nav-text">拓展学习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%8B"><span class="nav-number">9.</span> <span class="nav-text">《正则表达式》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-8"><span class="nav-number">9.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-8"><span class="nav-number">9.2.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-7"><span class="nav-number">9.3.</span> <span class="nav-text">课程内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8Abenchmark-%E6%80%8E%E4%B9%88%E5%86%99%E3%80%8B"><span class="nav-number">10.</span> <span class="nav-text">《benchmark 怎么写》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-9"><span class="nav-number">10.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-9"><span class="nav-number">10.2.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-8"><span class="nav-number">10.3.</span> <span class="nav-text">课程内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E5%88%86%E4%BA%AB"><span class="nav-number">10.3.1.</span> <span class="nav-text">在线分享</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%EF%BC%9Athis%EF%BC%8Cvar%EF%BC%8C-function-%E3%80%8B"><span class="nav-number">11.</span> <span class="nav-text">《作用域与闭包：this，var，(function () {})》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-10"><span class="nav-number">11.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-10"><span class="nav-number">11.2.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-9"><span class="nav-number">11.3.</span> <span class="nav-text">课程内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#var-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">11.3.1.</span> <span class="nav-text">var 作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">11.3.2.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91"><span class="nav-number">11.3.2.1.</span> <span class="nav-text">闭包的一个坑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">11.3.3.</span> <span class="nav-text">this</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2%EF%BC%9Aheroku%E3%80%8B"><span class="nav-number">12.</span> <span class="nav-text">《线上部署：heroku》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-11"><span class="nav-number">12.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-11"><span class="nav-number">12.2.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-10"><span class="nav-number">12.3.</span> <span class="nav-text">课程内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-heroku"><span class="nav-number">12.3.1.</span> <span class="nav-text">什么是 heroku</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B9%B3%E5%8F%B0%EF%BC%9Atravis%E3%80%8B"><span class="nav-number">13.</span> <span class="nav-text">《持续集成平台：travis》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-12"><span class="nav-number">13.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-12"><span class="nav-number">13.2.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-11"><span class="nav-number">13.3.</span> <span class="nav-text">课程内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="nav-number">13.4.</span> <span class="nav-text">补充说明:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8Ajs-%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B"><span class="nav-number">14.</span> <span class="nav-text">《js 中的那些最佳实践》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9"><span class="nav-number">14.1.</span> <span class="nav-text">JavaScript 语言精粹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-%E4%B9%8B%E7%BE%8E"><span class="nav-number">14.2.</span> <span class="nav-text">JavaScript 之美</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">14.3.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#callback-hell"><span class="nav-number">14.4.</span> <span class="nav-text">callback hell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">14.5.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">14.6.</span> <span class="nav-text">控制流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">14.7.</span> <span class="nav-text">基本运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%9E%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">14.8.</span> <span class="nav-text">计算型属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">14.9.</span> <span class="nav-text">运算符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">14.10.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83"><span class="nav-number">14.11.</span> <span class="nav-text">相等比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">14.12.</span> <span class="nav-text">嵌套类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-number">14.13.</span> <span class="nav-text">拓展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">14.14.</span> <span class="nav-text">函数式编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">14.15.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="nav-number">14.16.</span> <span class="nav-text">权限控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">14.17.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE"><span class="nav-number">14.18.</span> <span class="nav-text">构建大型项目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mongodb-%E4%B8%8E-Mongoose-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">15.</span> <span class="nav-text">Mongodb 与 Mongoose 的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-13"><span class="nav-number">15.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-13"><span class="nav-number">15.2.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mongodb"><span class="nav-number">15.3.</span> <span class="nav-text">mongodb</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-mongodb"><span class="nav-number">15.3.1.</span> <span class="nav-text">安装 mongodb</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mongoose"><span class="nav-number">15.4.</span> <span class="nav-text">mongoose</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%AA%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2%E7%A8%8B%E5%BA%8F"><span class="nav-number">15.4.1.</span> <span class="nav-text">设计个简单博客程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-number">15.5.</span> <span class="nav-text">示例程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cookie-%E5%92%8C-session"><span class="nav-number">16.</span> <span class="nav-text">cookie 和 session</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie"><span class="nav-number">16.1.</span> <span class="nav-text">cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#express-%E4%B8%AD%E7%9A%84-cookie"><span class="nav-number">16.1.1.</span> <span class="nav-text">express 中的 cookie</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session"><span class="nav-number">16.2.</span> <span class="nav-text">session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="nav-number">16.3.</span> <span class="nav-text">各种存储的利弊</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#signedCookie"><span class="nav-number">16.3.1.</span> <span class="nav-text">signedCookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie-session"><span class="nav-number">16.3.2.</span> <span class="nav-text">cookie-session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session-cookie"><span class="nav-number">16.3.3.</span> <span class="nav-text">session cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#etag-%E5%BD%93%E5%81%9A-session%EF%BC%8C%E4%BF%9D%E5%AD%98-http-%E4%BC%9A%E8%AF%9D"><span class="nav-number">16.3.4.</span> <span class="nav-text">etag 当做 session，保存 http 会话</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E4%BD%BF%E7%94%A8-promise-%E6%9B%BF%E4%BB%A3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E3%80%8B"><span class="nav-number">17.</span> <span class="nav-text">《使用 promise 替代回调函数》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-14"><span class="nav-number">17.1.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9-12"><span class="nav-number">17.2.</span> <span class="nav-text">课程内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">17.3.</span> <span class="nav-text">promise基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-number">17.4.</span> <span class="nav-text">promise的传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92"><span class="nav-number">17.5.</span> <span class="nav-text">方法传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise%E9%93%BE"><span class="nav-number">17.6.</span> <span class="nav-text">promise链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise%E7%BB%84%E5%90%88"><span class="nav-number">17.7.</span> <span class="nav-text">promise组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9D%9Fpromise%E9%93%BE"><span class="nav-number">17.8.</span> <span class="nav-text">结束promise链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="nav-number">17.9.</span> <span class="nav-text">结束语</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E4%BD%95%E4%B8%BA-connect-%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%8B"><span class="nav-number">18.</span> <span class="nav-text">《何为 connect 中间件》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-14"><span class="nav-number">18.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E7%AE%80%E4%BB%8B"><span class="nav-number">18.2.</span> <span class="nav-text">本章简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">18.3.</span> <span class="nav-text">HTTP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Connect%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">19.</span> <span class="nav-text">Connect的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#createServer"><span class="nav-number">19.1.</span> <span class="nav-text">createServer()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#app-use-route-fn"><span class="nav-number">19.2.</span> <span class="nav-text">app.use(route, fn)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#app-handle-req-res-out"><span class="nav-number">19.3.</span> <span class="nav-text">app.handle(req, res, out)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call-handle-route-err-req-res-next"><span class="nav-number">19.4.</span> <span class="nav-text">call(handle, route, err, req, res, next)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#listen"><span class="nav-number">19.5.</span> <span class="nav-text">listen</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3Connect"><span class="nav-number">19.6.</span> <span class="nav-text">图解Connect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Connect%E7%9A%84subapp%E7%89%B9%E6%80%A7"><span class="nav-number">19.7.</span> <span class="nav-text">Connect的subapp特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Express"><span class="nav-number">20.</span> <span class="nav-text">Express</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Router"><span class="nav-number">20.1.</span> <span class="nav-text">Router</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Request"><span class="nav-number">20.2.</span> <span class="nav-text">Request</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Response"><span class="nav-number">20.3.</span> <span class="nav-text">Response</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Application"><span class="nav-number">20.4.</span> <span class="nav-text">Application</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Express%E5%B0%8F%E7%BB%93"><span class="nav-number">20.5.</span> <span class="nav-text">Express小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">20.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xuefeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuefeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
