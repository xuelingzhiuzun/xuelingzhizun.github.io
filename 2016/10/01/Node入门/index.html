<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Node入门">
<meta property="og:url" content="http://example.com/2016/10/01/Node%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="XFNOTES">
<meta property="og:description" content="本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-10-01T13:52:27.000Z">
<meta property="article:modified_time" content="2018-01-07T11:40:14.000Z">
<meta property="article:author" content="xuefeng">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="node.js">
<meta property="article:tag" content="入门">
<meta property="article:tag" content="language">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2016/10/01/Node%E5%85%A5%E9%97%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Node入门 | XFNOTES</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XFNOTES</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-ategories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>ategories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/10/01/Node%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xuefeng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XFNOTES">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Node入门
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-01 21:52:27" itemprop="dateCreated datePublished" datetime="2016-10-01T21:52:27+08:00">2016-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-01-07 19:40:14" itemprop="dateModified" datetime="2018-01-07T19:40:14+08:00">2018-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node-js/" itemprop="url" rel="index"><span itemprop="name">node.js</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。</p>
<a id="more"></a>

<h1 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h1><p>作者： Manuel Kiessling<br>翻译： goddyzhao &amp; GrayZhang &amp; MondayChen</p>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。</p>
<p>本书中的代码案例都在Node.js 0.6.11版本中测试过，可以正确工作。</p>
<h2 id="读者对象"><a href="#读者对象" class="headerlink" title="读者对象"></a>读者对象</h2><p>本书最适合与我有相似技术背景的读者： 至少对一门诸如Ruby、Python、PHP或者Java这样面向对象的语言有一定的经验；对JavaScript处于初学阶段，并且完全是一个Node.js的新手。</p>
<p>这里指的适合对其他编程语言有一定经验的开发者，意思是说，本书不会对诸如数据类型、变量、控制结构等等之类非常基础的概念作介绍。要读懂本书，这些基础的概念我都默认你已经会了。</p>
<p>然而，本书还是会对JavaScript中的函数和对象作详细介绍，因为它们与其他同类编程语言中的函数和对象有很大的不同。</p>
<h2 id="本书结构"><a href="#本书结构" class="headerlink" title="本书结构"></a>本书结构</h2><p>读完本书之后，你将完成一个完整的web应用，该应用允许用户浏览页面以及上传文件。</p>
<p>当然了，应用本身并没有什么了不起的，相比为了实现该功能书写的代码本身，我们更关注的是如何创建一个框架来对我们应用的不同模块进行干净地剥离。 是不是很玄乎？稍后你就明白了。</p>
<p>本书先从介绍在Node.js环境中进行JavaScript开发和在浏览器环境中进行JavaScript开发的差异开始。</p>
<p>紧接着，会带领大家完成一个最传统的“Hello World”应用，这也是最基础的Node.js应用。</p>
<p>最后，会和大家讨论如何设计一个“真正”完整的应用，剖析要完成该应用需要实现的不同模块，并一步一步介绍如何来实现这些模块。</p>
<p>可以确保的是，在这过程中，大家会学到JavaScript中一些高级的概念、如何使用它们以及为什么使用这些概念就可以实现而其他编程语言中同类的概念就无法实现。</p>
<p>该应用所有的源代码都可以通过 本书Github代码仓库.</p>
<h1 id="JavaScript与Node-js"><a href="#JavaScript与Node-js" class="headerlink" title="JavaScript与Node.js"></a>JavaScript与Node.js</h1><h2 id="JavaScript与你"><a href="#JavaScript与你" class="headerlink" title="JavaScript与你"></a>JavaScript与你</h2><p>抛开技术，我们先来聊聊你以及你和JavaScript的关系。本章的主要目的是想让你看看，对你而言是否有必要继续阅读后续章节的内容。</p>
<p>如果你和我一样，那么你很早就开始利用HTML进行“开发”，正因如此，你接触到了这个叫JavaScript有趣的东西，而对于JavaScript，你只会基本的操作——为web页面添加交互。</p>
<p>而你真正想要的是“干货”，你想要知道如何构建复杂的web站点 —— 于是，你学习了一种诸如PHP、Ruby、Java这样的编程语言，并开始书写“后端”代码。</p>
<p>与此同时，你还始终关注着JavaScript，随着通过一些对jQuery，Prototype之类技术的介绍，你慢慢了解到了很多JavaScript中的进阶技能，同时也感受到了JavaScript绝非仅仅是window.open() 那么简单。 .</p>
<p>不过，这些毕竟都是前端技术，尽管当想要增强页面的时候，使用jQuery总让你觉得很爽，但到最后，你顶多是个JavaScript用户，而非JavaScript开发者。</p>
<p>然后，出现了Node.js，服务端的JavaScript，这有多酷啊？</p>
<p>于是，你觉得是时候该重新拾起既熟悉又陌生的JavaScript了。但是别急，写Node.js应用是一件事情；理解为什么它们要以它们书写的这种方式来书写则意味着——你要懂JavaScript。这次是玩真的了。</p>
<p>问题来了： 由于JavaScript真正意义上以两种，甚至可以说是三种形态存在（从中世纪90年代的作为对DHTML进行增强的小玩具，到像jQuery那样严格意义上的前端技术，一直到现在的服务端技术），因此，很难找到一个“正确”的方式来学习JavaScript，使得让你书写Node.js应用的时候感觉自己是在真正开发它而不仅仅是使用它。</p>
<p>因为这就是关键： 你本身已经是个有经验的开发者，你不想通过到处寻找各种解决方案（其中可能还有不正确的）来学习新的技术，你要确保自己是通过正确的方式来学习这项技术。</p>
<p>当然了，外面不乏很优秀的学习JavaScript的文章。但是，有的时候光靠那些文章是远远不够的。你需要的是指导。</p>
<p>本书的目标就是给你提供指导。</p>
<h2 id="简短申明"><a href="#简短申明" class="headerlink" title="简短申明"></a>简短申明</h2><p>业界有非常优秀的JavaScript程序员。而我并非其中一员。</p>
<p>我就是上一节中描述的那个我。我熟悉如何开发后端web应用，但是对“真正”的JavaScript以及Node.js，我都只是新手。我也只是最近学习了一些JavaScript的高级概念，并没有实践经验。</p>
<p>因此，本书并不是一本“从入门到精通”的书，更像是一本“从初级入门到高级入门”的书。</p>
<p>如果成功的话，那么本书就是我当初开始学习Node.js最希望拥有的教程。</p>
<h2 id="服务端JavaScript"><a href="#服务端JavaScript" class="headerlink" title="服务端JavaScript"></a>服务端JavaScript</h2><p>JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。</p>
<p>Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。</p>
<p>要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。</p>
<p>除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。</p>
<p>因此，Node.js事实上既是一个运行时环境，同时又是一个库。</p>
<p>要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考官方的安装指南。安装完成后，继续回来阅读本书下面的内容。</p>
<h2 id="“Hello-World”"><a href="#“Hello-World”" class="headerlink" title="“Hello World”"></a>“Hello World”</h2><p>好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。</p>
<p>打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure>
<p>保存该文件，并通过Node.js来执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node helloworld.js</span><br></pre></td></tr></table></figure>
<p>正常的话，就会在终端输出<code>Hello World</code> 。</p>
<p>好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。</p>
<h1 id="一个完整的基于Node-js的web应用"><a href="#一个完整的基于Node-js的web应用" class="headerlink" title="一个完整的基于Node.js的web应用"></a>一个完整的基于Node.js的web应用</h1><p>##　用例</p>
<p>我们来把目标设定得简单点，不过也要够实际才行：</p>
<p>用户可以通过浏览器使用我们的应用。<br>当用户请求<code>http://domain/start</code>时，可以看到一个欢迎页面，页面上有一个文件上传的表单。<br>用户可以选择一个图片并提交表单，随后文件将被上传到<code>http://domain/upload</code>，该页面完成上传后会把图片显示在页面上。<br>差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。</p>
<p>更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。</p>
<h2 id="应用不同模块分析"><a href="#应用不同模块分析" class="headerlink" title="应用不同模块分析"></a>应用不同模块分析</h2><p>我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？</p>
<p>我们需要提供Web页面，因此需要一个<code>HTTP服务器</code><br>对于不同的请求，根据请求的<code>URL</code>，我们的服务器需要给予不同的响应，因此我们需要一个路由，用于把请求对应到请求处理程序<code>（request handler）</code><br>当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的请求处理程序<br>路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要请求数据处理功能<br>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器<br>最后，用户需要上传图片，所以我们需要上传处理功能来处理这方面的细节<br>我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。<br>从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。</p>
<p>不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。</p>
<p>听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。</p>
<p>现在我们就来开始实现之路，先从第一个部分–HTTP服务器着手。</p>
<h1 id="构建应用的模块"><a href="#构建应用的模块" class="headerlink" title="构建应用的模块"></a>构建应用的模块</h1><h2 id="一个基础的HTTP服务器"><a href="#一个基础的HTTP服务器" class="headerlink" title="一个基础的HTTP服务器"></a>一个基础的HTTP服务器</h2><p>当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。<br>我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？</p>
<p>实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。</p>
<p>这种方法允许你拥有一个干净的主文件<code>（main file）</code>，你可以用<code>Node.js</code>执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。</p>
<p>那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的<code>HTTP服务器</code>代码的模块。</p>
<p>在我的印象里，把主文件叫做<code>index.js</code>或多或少是个标准格式。把服务器模块放进叫<code>server.js</code>的文件里则很好理解。</p>
<p>让我们先从服务器模块开始。在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function(request, response) &#123;</span><br><span class="line">  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;&#125;);</span><br><span class="line">  response.write(&quot;Hello World&quot;);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;).listen(8888);</span><br></pre></td></tr></table></figure>
<p>搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure>
<p>接下来，打开浏览器访问<code>http://localhost:8888/</code>，你会看到一个写着<code>“Hello World”</code>的网页。</p>
<p>这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。</p>
<h2 id="分析HTTP服务器"><a href="#分析HTTP服务器" class="headerlink" title="分析HTTP服务器"></a>分析HTTP服务器</h2><p>那么接下来，让我们分析一下这个HTTP服务器的构成。</p>
<p>第一行请求<code>（require）</code>Node.js自带的 <code>http 模块</code>，并且把它赋值给 <code>http 变量</code>。</p>
<p>接下来我们调用<code>http模块</code>提供的函数： <code>createServer</code> 。这个函数会返回一个对象，这个对象有一个叫做 <code>listen </code>的方法，这个方法有一个数值参数，指定这个<code>HTTP服务器</code>监听的端口号。</p>
<p>咱们暂时先不管<code> http.createServer</code> 的括号里的那个函数定义。</p>
<p>我们本来可以用这样的代码来启动服务器并侦听<code>8888端口</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">var server &#x3D; http.createServer();</span><br><span class="line">server.listen(8888);</span><br></pre></td></tr></table></figure>
<p>这段代码只会启动一个侦听<code>8888端口</code>的服务器，它不做任何别的事情，甚至连请求都不会应答。</p>
<p>最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如<code>PHP</code>，它还很奇怪）的部分是<code> createServer()</code> 的第一个参数，一个函数定义。</p>
<p>实际上，这个函数定义是 <code>createServer()</code> 的第一个也是唯一一个参数。因为在<code>JavaScript</code>中，函数和其他变量一样都是可以被传递的。</p>
<h2 id="进行函数传递"><a href="#进行函数传递" class="headerlink" title="进行函数传递"></a>进行函数传递</h2><p>举例来说，你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function say(word) &#123;</span><br><span class="line">  console.log(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function execute(someFunction, value) &#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(say, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure>
<p>请仔细阅读这段代码！在这里，我们把<code>say</code>函数作为<code>execute函数</code>的第一个变量进行了传递。这里传递的不是 <code>say</code>的返回值，而是 <code>say</code>本身！</p>
<p>这样一来， <code>say</code> 就变成了<code>execute</code> 中的本地变量 <code>someFunction</code> ，<code>execute</code>可以通过调用 <code>someFunction()</code> （带括号的形式）来使用 <code>say 函数</code>。</p>
<p>当然，因为 <code>say</code> 有一个变量， <code>execute</code> 在调用 <code>omeFunction</code> 时可以传递这样一个变量。</p>
<p>我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function execute(someFunction, value) &#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(function(word)&#123; console.log(word) &#125;, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure>
<p>我们在 <code>execute</code> 接受第一个参数的地方直接定义了我们准备传递给 <code>execute</code> 的函数。</p>
<p>用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 匿名函数 。</p>
<p>这是我们和我所认为的“进阶”<code>JavaScript</code>的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在<code>JavaScript</code>中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>
<h2 id="函数传递是如何让HTTP服务器工作的"><a href="#函数传递是如何让HTTP服务器工作的" class="headerlink" title="函数传递是如何让HTTP服务器工作的"></a>函数传递是如何让<code>HTTP服务器</code>工作的</h2><p>带着这些知识，我们再来看看我们简约而不简单的<code>HTTP服务器</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function(request, response) &#123;</span><br><span class="line">  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;&#125;);</span><br><span class="line">  response.write(&quot;Hello World&quot;);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;).listen(8888);</span><br></pre></td></tr></table></figure>
<p>现在它看上去应该清晰了很多：我们向 <code>createServer 函数</code>传递了一个匿名函数。</p>
<p>用这样的代码也可以达到同样的目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">function onRequest(request, response) &#123;</span><br><span class="line">  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;&#125;);</span><br><span class="line">  response.write(&quot;Hello World&quot;);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(8888);</span><br></pre></td></tr></table></figure>
<p>也许现在我们该问这个问题了：我们为什么要用这种方式呢？</p>
<h2 id="基于事件驱动的回调"><a href="#基于事件驱动的回调" class="headerlink" title="基于事件驱动的回调"></a>基于事件驱动的回调</h2><p>这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。</p>
<p>你也许会想花点时间读一下Felix Geisendörfer的大作Understanding node.js，它介绍了一些背景知识。</p>
<p>这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。</p>
<p>当我们使用 <code>http.createServer</code> 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。</p>
<p>问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。</p>
<p>写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。</p>
<p>那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？</p>
<p>嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。</p>
<p>我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。</p>
<p>我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。</p>
<p>这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。</p>
<p>至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。</p>
<p>让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Request received.&quot;</span>);</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">  response.write(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Server has started.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注意：在 <code>onRequest</code> （我们的回调函数）触发的地方，我用 <code>console.log</code> 输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。</p>
<p>当我们与往常一样，运行它<code>node server.js</code>时，它会马上在命令行上输出<code>“Server has started.”</code>。当我们向服务器发出请求（在浏览器访问<code>http://localhost:8888/</code> ），<code>“Request received.”</code>这条消息就会在命令行中出现。</p>
<p>这就是事件驱动的异步服务器端JavaScript和它的回调啦！</p>
<p>（请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次<code>“Request received.”</code>。那是因为大部分浏览器都会在你访问 <code>http://localhost:8888/</code> 时尝试读取 <code>http://localhost:8888/favicon.ico</code> )</p>
<h2 id="服务器是如何处理请求的"><a href="#服务器是如何处理请求的" class="headerlink" title="服务器是如何处理请求的"></a>服务器是如何处理请求的</h2><p>好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 <code>onRequest()</code> 的主体部分。</p>
<p>当回调启动，我们的 <code>onRequest()</code> 函数被触发的时候，有两个参数被传入： <code>request</code> 和 <code>response</code> 。</p>
<p>它们是对象，你可以使用它们的方法来处理<code>HTTP请求</code>的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。</p>
<p>所以我们的代码就是：当收到请求时，使用 <code>response.writeHead()</code> 函数发送一个<code>HTTP状态200</code>和<code>HTTP头</code>的内容类型（content-type），使用<code>response.write()</code> 函数在HTTP相应主体中发送文本<code>&quot;Helllo world&quot;</code>.</p>
<p>最后，我们调用 <code>response.end()</code> 完成响应。</p>
<p>目前来说，我们对请求的细节并不在意，所以我们没有使用 <code>request 对象</code>。</p>
<h2 id="服务端的模块放在哪里"><a href="#服务端的模块放在哪里" class="headerlink" title="服务端的模块放在哪里"></a>服务端的模块放在哪里</h2><p>OK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 <code>server.js</code> 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 <code>index.js</code> 的文件去调用应用的其他模块（比如 <code>server.js</code> 中的HTTP服务器模块）来引导和启动应用。</p>
<p>我们现在就来谈谈怎么把<code>server.js</code>变成一个真正的<code>Node.js模块</code>，使它可以被我们（还没动工）的 <code>index.js</code> 主文件使用。</p>
<p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">http.createServer(...);</span><br></pre></td></tr></table></figure>
<p>Node.js中自带了一个叫做“<code>http</code>”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。<br>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p>
<p>给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">foo.createServer(...);</span><br></pre></td></tr></table></figure>
<p>很好，怎么使用<code>Node.js内部模块</code>已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？</p>
<p>等我们把 <code>server.js</code> 变成一个真正的模块，你就能搞明白了。</p>
<p>事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 导出 到请求这个模块的脚本。</p>
<p>目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。</p>
<p>我们把我们的服务器脚本放到一个叫做 <code>start</code> 的函数里，然后我们会导出这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    console.log(&quot;Request received.&quot;);</span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;Hello World&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log(&quot;Server has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start &#x3D; start;</span><br></pre></td></tr></table></figure>
<p>这样，我们现在就可以创建我们的主文件 <code>index.js</code> 并在其中启动我们的<code>HTTP</code>了，虽然服务器的代码还在 <code>server.js</code> 中。</p>
<p>创建 <code>index.js</code> 文件并写入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var server &#x3D; require(&quot;.&#x2F;server&quot;);</span><br><span class="line"></span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，我们可以像使用任何其他的内置模块一样使用<code>server模块</code>：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。</p>
<p>好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure>
<p>非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。</p>
<p>我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。</p>
<p>对于一个非常简单的应用来说，你可以直接在回调函数 <code>onRequest()</code> 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。</p>
<p>处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做 路由 的模块吧。</p>
<h2 id="如何来进行请求的“路由”"><a href="#如何来进行请求的“路由”" class="headerlink" title="如何来进行请求的“路由”"></a>如何来进行请求的“路由”</h2><p>我们要为路由提供请求的URL和其他需要的<code>GET及POST参数</code>，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。</p>
<p>因此，我们需要查看HTTP请求，从中提取出请求的URL以及<code>GET/POST参数</code>。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>
<p>我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。</p>
<pre><code>                               url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/start?foo=bar&amp;hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring(string)[&quot;foo&quot;]    |
                                            |
                         querystring(string)[&quot;hello&quot;]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。</span><br><span class="line"></span><br><span class="line">现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：</span><br></pre></td></tr></table></figure>
var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start() &#123;
  function onRequest(request, response) &#123;
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);
    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
    response.write(&quot;Hello World&quot;);
    response.end();
  &#125;

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
&#125;

exports.start = start;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">好了，我们的应用现在可以通过请求的URL路径来区别不同请求了--这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。</span><br><span class="line"></span><br><span class="line">在我们所要构建的应用中，这意味着来自&#x2F;start和&#x2F;upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</span><br><span class="line"></span><br><span class="line">现在我们可以来编写路由了，建立一个名为&#96;router.js&#96;的文件，添加以下内容：</span><br></pre></td></tr></table></figure>
function route(pathname) &#123;
  console.log(&quot;About to route a request for &quot; + pathname);
&#125;

exports.route = route;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</span><br><span class="line"></span><br><span class="line">我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读Martin Fowlers关于依赖注入的大作来作为背景知识）。</span><br><span class="line"></span><br><span class="line">首先，我们来扩展一下服务器的&#96;start()函数&#96;，以便将路由函数作为参数传递过去：</span><br></pre></td></tr></table></figure>
var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route) &#123;
  function onRequest(request, response) &#123;
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(pathname);

    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
    response.write(&quot;Hello World&quot;);
    response.end();
  &#125;

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
&#125;

exports.start = start;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：</span><br></pre></td></tr></table></figure>
var server = require(&quot;./server&quot;);
var router = require(&quot;./router&quot;);

server.start(router.route);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在这里，我们传递的函数依旧什么也没做。</span><br><span class="line"></span><br><span class="line">如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</span><br></pre></td></tr></table></figure>
bash$ node index.js
Request for /foo received.
About to route a request for /foo
（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">## 行为驱动执行</span><br><span class="line"></span><br><span class="line">请允许我再次脱离主题，在这里谈一谈函数式编程。</span><br><span class="line"></span><br><span class="line">将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。</span><br><span class="line"></span><br><span class="line">就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。嗨那个叫路由的东西，能帮我把这个路由一下吗？</span><br><span class="line"></span><br><span class="line">但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要名词，你需要动词。</span><br><span class="line"></span><br><span class="line">理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。</span><br><span class="line"></span><br><span class="line">我是在读了Steve Yegge的大作名词王国中的死刑之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。</span><br><span class="line"></span><br><span class="line">## 路由给真正的请求处理程序</span><br><span class="line"></span><br><span class="line">回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。</span><br><span class="line"></span><br><span class="line">当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理&#x2F;start的“业务逻辑”就应该和处理&#x2F;upload的不同。</span><br><span class="line"></span><br><span class="line">在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。</span><br><span class="line"></span><br><span class="line">我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。</span><br><span class="line"></span><br><span class="line">应用程序需要新的部件，因此加入新的模块 -- 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：</span><br></pre></td></tr></table></figure>
function start() &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);
&#125;

function upload() &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
&#125;

exports.start = start;
exports.upload = upload;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。</span><br><span class="line"></span><br><span class="line">在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。</span><br><span class="line"></span><br><span class="line">这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。</span><br><span class="line"></span><br><span class="line">那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆if request &#x3D;&#x3D; x then call handler y也使得系统丑陋不堪。</span><br><span class="line"></span><br><span class="line">仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎关联数组（associative array）能完美胜任。</span><br><span class="line"></span><br><span class="line">不过结果有点令人失望，JavaScript没提供关联数组 -- 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。</span><br><span class="line"></span><br><span class="line">在这方面，&#96;http:&#x2F;&#x2F;msdn.microsoft.com&#x2F;en-us&#x2F;magazine&#x2F;cc163419.aspx&#96;有一个不错的介绍，我在此摘录一段：</span><br><span class="line"></span><br><span class="line">在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键&#x2F;值对的集合 -- 你可以把JavaScript的对象想象成一个键为字符串类型的字典。</span><br><span class="line"></span><br><span class="line">但如果JavaScript的对象仅仅是键&#x2F;值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！</span><br><span class="line"></span><br><span class="line">好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。</span><br><span class="line"></span><br><span class="line">我们先将这个对象引入到主文件index.js中：</span><br></pre></td></tr></table></figure>
var server = require(&quot;./server&quot;);
var router = require(&quot;./router&quot;);
var requestHandlers = require(&quot;./requestHandlers&quot;);

var handle = &#123;&#125;
handle[&quot;/&quot;] = requestHandlers.start;
handle[&quot;/start&quot;] = requestHandlers.start;
handle[&quot;/upload&quot;] = requestHandlers.upload;

server.start(router.route, handle);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。</span><br><span class="line"></span><br><span class="line">正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为&quot;&#x2F;&quot;的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置&#x2F;start和&#x2F;的请求都交由start这一处理程序处理。</span><br><span class="line"></span><br><span class="line">在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下：</span><br></pre></td></tr></table></figure>
var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) &#123;
  function onRequest(request, response) &#123;
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(handle, pathname);

    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
    response.write(&quot;Hello World&quot;);
    response.end();
  &#125;

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
&#125;

exports.start = start;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。</span><br><span class="line"></span><br><span class="line">然后我们相应地在route.js文件中修改route()函数：</span><br></pre></td></tr></table></figure>
function route(handle, pathname) &#123;
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === &#39;function&#39;) &#123;
    handle[pathname]();
  &#125; else &#123;
    console.log(&quot;No request handler found for &quot; + pathname);
  &#125;
&#125;

exports.route = route;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handle[pathname]();的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。</span><br><span class="line"></span><br><span class="line">有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问http:&#x2F;&#x2F;localhost:8888&#x2F;start，以下日志可以说明系统调用了正确的请求处理程序：</span><br></pre></td></tr></table></figure>
Server has started.
Request for /start received.
About to route a request for /start
Request handler &#39;start&#39; was called.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并且在浏览器中打开&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;&#96;可以看到这个请求同样被start请求处理程序处理了：</span><br></pre></td></tr></table></figure>
Request for / received.
About to route a request for /
Request handler &#39;start&#39; was called.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">## 让请求处理程序作出响应</span><br><span class="line"></span><br><span class="line">很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”，那就更好了。</span><br><span class="line"></span><br><span class="line">这里要记住的是，浏览器发出请求后获得并显示的“Hello World”信息仍是来自于我们server.js文件中的onRequest函数。</span><br><span class="line"></span><br><span class="line">其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像onRequest函数那样可以和浏览器进行“对话”。</span><br><span class="line"></span><br><span class="line">### 不好的实现方式</span><br><span class="line"></span><br><span class="line">对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱： 看似有效，实则未必如此。</span><br><span class="line"></span><br><span class="line">这里我指的“直截了当的实现方式”意思是：让请求处理程序通过onRequest函数直接返回（return()）他们要展示给用户的信息。</span><br><span class="line"></span><br><span class="line">我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。</span><br><span class="line"></span><br><span class="line">让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将requestHandler.js修改为如下形式：</span><br></pre></td></tr></table></figure>
function start() &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);
  return &quot;Hello Start&quot;;
&#125;

function upload() &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  return &quot;Hello Upload&quot;;
&#125;

exports.start = start;
exports.upload = upload;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将router.js修改为如下形式：</span><br></pre></td></tr></table></figure>
function route(handle, pathname) &#123;
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === &#39;function&#39;) &#123;
    return handle[pathname]();
  &#125; else &#123;
    console.log(&quot;No request handler found for &quot; + pathname);
    return &quot;404 Not found&quot;;
  &#125;
&#125;

exports.route = route;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。</span><br><span class="line"></span><br><span class="line">最后，我们需要对我们的server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：</span><br></pre></td></tr></table></figure>
var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) &#123;
  function onRequest(request, response) &#123;
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
    var content = route(handle, pathname)
    response.write(content);
    response.end();
  &#125;

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
&#125;

exports.start = start;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果我们运行重构后的应用，一切都会工作的很好：请求&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;start&#96;,浏览器会输出“&#96;Hello Start&#96;”，请求&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;upload&#96;会输出“&#96;Hello Upload&#96;”,而请求&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;foo&#96; 会输出“&#96;404 Not found&#96;”。</span><br><span class="line"></span><br><span class="line">好，那么问题在哪里呢？简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。</span><br><span class="line"></span><br><span class="line">没理解？没关系，下面就来详细解释下。</span><br><span class="line"></span><br><span class="line">### 阻塞与非阻塞</span><br><span class="line"></span><br><span class="line">正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。</span><br><span class="line"></span><br><span class="line">我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。</span><br><span class="line"></span><br><span class="line">这里，我们来修改下start请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似sleep()这样的操作，所以这里只能够来点小Hack来模拟实现。</span><br><span class="line"></span><br><span class="line">让我们将requestHandlers.js修改成如下形式：</span><br></pre></td></tr></table></figure>
function start() &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  function sleep(milliSeconds) &#123;
    var startTime = new Date().getTime();
    while (new Date().getTime() &lt; startTime + milliSeconds);
  &#125;

  sleep(10000);
  return &quot;Hello Start&quot;;
&#125;

function upload() &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  return &quot;Hello Upload&quot;;
&#125;

exports.start = start;
exports.upload = upload;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">上述代码中，当函数&#96;start()&#96;被调用的时候，Node.js会先等待10秒，之后才会返回“&#96;Hello Start&#96;”。当调用&#96;upload()&#96;的时候，会和此前一样立即返回。</span><br><span class="line"></span><br><span class="line">（当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）</span><br><span class="line"></span><br><span class="line">接下来就让我们来看看，我们的改动带来了哪些变化。</span><br><span class="line"></span><br><span class="line">如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;start&#96;， 但是先不要打开它！</span><br><span class="line"></span><br><span class="line">在第二个浏览器窗口的地址栏中输入&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;upload&#96;， 同样的，先不要打开它！</span><br><span class="line"></span><br><span class="line">接下来，做如下操作：在第一个窗口中（“&#x2F;start”）按下回车，然后快速切换到第二个窗口中（“&#x2F;upload”）按下回车。</span><br><span class="line"></span><br><span class="line">注意，发生了什么： &#96;&#x2F;start URL&#96;加载花了10秒，这和我们预期的一样。但是，&#96;&#x2F;upload URL&#96;居然也花了10秒，而它在对应的请求处理程序中并没有类似于&#96;sleep()&#96;这样的操作！</span><br><span class="line"></span><br><span class="line">这到底是为什么呢？原因就是&#96;start()&#96;包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。</span><br><span class="line"></span><br><span class="line">这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。</span><br><span class="line"></span><br><span class="line">这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。</span><br><span class="line"></span><br><span class="line">然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。</span><br><span class="line"></span><br><span class="line">对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</span><br><span class="line"></span><br><span class="line">（如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——理解node.js的事件轮询。）</span><br><span class="line"></span><br><span class="line">接下来，我们会介绍一种错误的使用非阻塞操作的方式。</span><br><span class="line"></span><br><span class="line">和上次一样，我们通过修改我们的应用来暴露问题。</span><br><span class="line"></span><br><span class="line">这次我们还是拿start请求处理程序来“开刀”。将其修改成如下形式：</span><br></pre></td></tr></table></figure>
var exec = require(&quot;child_process&quot;).exec;

function start() &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);
  var content = &quot;empty&quot;;

  exec(&quot;ls -lah&quot;, function (error, stdout, stderr) &#123;
    content = stdout;
  &#125;);

  return content;
&#125;

function upload() &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  return &quot;Hello Upload&quot;;
&#125;

exports.start = start;
exports.upload = upload;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">上述代码中，我们引入了一个新的Node.js模块，&#96;child_process&#96;。之所以用它，是为了实现一个既简单又实用的非阻塞操作：&#96;exec()&#96;。</span><br><span class="line"></span><br><span class="line">&#96;exec()&#96;做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“&#96;ls -lah&#96;”）,然后，当&#96;&#x2F;start URL&#96;请求的时候将文件信息输出到浏览器中。</span><br><span class="line"></span><br><span class="line">上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。</span><br><span class="line"></span><br><span class="line">和往常一样，我们启动服务器，然后访问“&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;start&#96;” 。</span><br><span class="line"></span><br><span class="line">之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？</span><br><span class="line"></span><br><span class="line">这个时候，你可能大致已经猜到了，&#96;exec()&#96;在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。</span><br><span class="line"></span><br><span class="line">（如果想要证明这一点，可以将“ls -lah”换成比如“find &#x2F;”这样更耗时的操作来效果）。</span><br><span class="line"></span><br><span class="line">然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？</span><br><span class="line"></span><br><span class="line">好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。</span><br><span class="line"></span><br><span class="line">问题就在于，为了进行非阻塞工作，exec()使用了回调函数。</span><br><span class="line"></span><br><span class="line">在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数：</span><br></pre></td></tr></table></figure>
function (error, stdout, stderr) &#123;
  content = stdout;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行 return content ；在这个时候，content仍然是“empty”，因为传递给exec()的回调函数还未执行到——因为exec()的操作是异步的。</span><br><span class="line"></span><br><span class="line">我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。</span><br><span class="line"></span><br><span class="line">为了让效果更加明显，我们想象一个更耗时的命令： “find &#x2F;”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find &#x2F;”，当打开&#x2F;start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find &#x2F;”命令执行完成之后才会被调用。</span><br><span class="line"></span><br><span class="line">那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？</span><br><span class="line"></span><br><span class="line">好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。</span><br><span class="line"></span><br><span class="line">### 以非阻塞操作进行请求响应</span><br><span class="line"></span><br><span class="line">我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。</span><br><span class="line"></span><br><span class="line">不过，用Node.js就有这样一种实现方案： 函数传递。下面就让我们来具体看看如何实现。</span><br><span class="line"></span><br><span class="line">到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。</span><br><span class="line"></span><br><span class="line">现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。</span><br><span class="line"></span><br><span class="line">原理就是如此，接下来让我们来一步步实现这种方案。</span><br><span class="line"></span><br><span class="line">先从server.js开始：</span><br></pre></td></tr></table></figure>
var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) &#123;
  function onRequest(request, response) &#123;
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(handle, pathname, response);
  &#125;

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
&#125;

exports.start = start;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。</span><br><span class="line"></span><br><span class="line">下面就来看看我们的router.js:</span><br></pre></td></tr></table></figure>
function route(handle, pathname, response) &#123;
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === &#39;function&#39;) &#123;
    handle[pathname](response);
  &#125; else &#123;
    console.log(&quot;No request handler found for &quot; + pathname);
    response.writeHead(404, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
    response.write(&quot;404 Not found&quot;);
    response.end();
  &#125;
&#125;

exports.route = route;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。</span><br><span class="line"></span><br><span class="line">如果没有对应的请求处理器处理，我们就直接返回“404”错误。</span><br><span class="line"></span><br><span class="line">最后，我们将requestHandler.js修改为如下形式：</span><br></pre></td></tr></table></figure>
var exec = require(&quot;child_process&quot;).exec;

function start(response) &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  exec(&quot;ls -lah&quot;, function (error, stdout, stderr) &#123;
    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
    response.write(stdout);
    response.end();
  &#125;);
&#125;

function upload(response) &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
  response.write(&quot;Hello Upload&quot;);
  response.end();
&#125;

exports.start = start;
exports.upload = upload;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。</span><br><span class="line"></span><br><span class="line">start处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用response对象而已。</span><br><span class="line"></span><br><span class="line">这时再次我们启动应用（node index.js），一切都会工作的很好。</span><br><span class="line"></span><br><span class="line">如果想要证明&#96;&#x2F;start&#96;处理程序中耗时的操作不会阻塞对&#96;&#x2F;upload&#96;请求作出立即响应的话，可以将requestHandlers.js修改为如下形式：</span><br></pre></td></tr></table></figure>
var exec = require(&quot;child_process&quot;).exec;

function start(response) &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  exec(&quot;find /&quot;,
    &#123; timeout: 10000, maxBuffer: 20000*1024 &#125;,
    function (error, stdout, stderr) &#123;
      response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
      response.write(stdout);
      response.end();
    &#125;);
&#125;

function upload(response) &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
  response.write(&quot;Hello Upload&quot;);
  response.end();
&#125;

exports.start = start;
exports.upload = upload;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">这样一来，当请求&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;start&#96;的时候，会花10秒钟的时间才载入，而当请求&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;upload&#96;的时候，会立即响应，纵然这个时候&#96;&#x2F;start&#96;响应还在处理中。</span><br><span class="line"></span><br><span class="line"># 更有用的场景</span><br><span class="line"></span><br><span class="line">到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。</span><br><span class="line"></span><br><span class="line">服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。</span><br><span class="line"></span><br><span class="line">好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。</span><br><span class="line"></span><br><span class="line">要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。</span><br><span class="line"></span><br><span class="line">第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。 </span><br><span class="line">第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。</span><br><span class="line"></span><br><span class="line">## 处理POST请求</span><br><span class="line"></span><br><span class="line">考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。</span><br><span class="line"></span><br><span class="line">&#96;&#x2F;start&#96;请求处理程序用于生成带文本区的表单，因此，我们将&#96;requestHandlers.js&#96;修改为如下形式：</span><br></pre></td></tr></table></figure>
function start(response) &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  var body = &#39;&lt;html&gt;&#39;+
    &#39;&lt;head&gt;&#39;+
    &#39;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &#39;+
    &#39;charset=UTF-8&quot; /&gt;&#39;+
    &#39;&lt;/head&gt;&#39;+
    &#39;&lt;body&gt;&#39;+
    &#39;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&#39;+
    &#39;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&#39;+
    &#39;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&#39;+
    &#39;&lt;/form&gt;&#39;+
    &#39;&lt;/body&gt;&#39;+
    &#39;&lt;/html&gt;&#39;;

    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;);
    response.write(body);
    response.end();
&#125;

function upload(response) &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
  response.write(&quot;Hello Upload&quot;);
  response.end();
&#125;

exports.start = start;
exports.upload = upload;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;start&#96;就可以看到简单的表单了，要记得重启服务器哦！</span><br><span class="line"></span><br><span class="line">你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。</span><br><span class="line"></span><br><span class="line">余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发&#96;&#x2F;upload&#96;请求处理程序处理POST请求的问题。</span><br><span class="line"></span><br><span class="line">现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。</span><br><span class="line"></span><br><span class="line">这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。</span><br><span class="line"></span><br><span class="line">为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。</span><br><span class="line"></span><br><span class="line">我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。</span><br><span class="line"></span><br><span class="line">如下所示：</span><br></pre></td></tr></table></figure>
request.addListener(&quot;data&quot;, function(chunk) &#123;
  // called when a new chunk of data was received
&#125;);

request.addListener(&quot;end&quot;, function() &#123;
  // called when all chunks of data have been received
&#125;);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了request对象 —— 我们并没有像之前response对象那样，把 request 对象传递给请求路由和请求处理程序。</span><br><span class="line"></span><br><span class="line">在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。</span><br><span class="line"></span><br><span class="line">因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。</span><br><span class="line"></span><br><span class="line">还等什么，马上来实现。先从server.js开始：</span><br></pre></td></tr></table></figure>
var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) &#123;
  function onRequest(request, response) &#123;
    var postData = &quot;&quot;;
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    request.setEncoding(&quot;utf8&quot;);

    request.addListener(&quot;data&quot;, function(postDataChunk) &#123;
      postData += postDataChunk;
      console.log(&quot;Received POST data chunk &#39;&quot;+
      postDataChunk + &quot;&#39;.&quot;);
    &#125;);

    request.addListener(&quot;end&quot;, function() &#123;
      route(handle, pathname, response, postData);
    &#125;);

  &#125;

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
&#125;

exports.start = start;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给postData 变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。</span><br><span class="line"></span><br><span class="line">上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。</span><br><span class="line"></span><br><span class="line">我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。</span><br><span class="line"></span><br><span class="line">再来点酷的。我们接下来在&#x2F;upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：</span><br></pre></td></tr></table></figure>
function route(handle, pathname, response, postData) &#123;
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === &#39;function&#39;) &#123;
    handle[pathname](response, postData);
  &#125; else &#123;
    console.log(&quot;No request handler found for &quot; + pathname);
    response.writeHead(404, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
    response.write(&quot;404 Not found&quot;);
    response.end();
  &#125;
&#125;

exports.route = route;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后，在&#96;requestHandlers.js&#96;中，我们将数据包含在对upload请求的响应中：</span><br></pre></td></tr></table></figure>
function start(response, postData) &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  var body = &#39;&lt;html&gt;&#39;+
    &#39;&lt;head&gt;&#39;+
    &#39;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &#39;+
    &#39;charset=UTF-8&quot; /&gt;&#39;+
    &#39;&lt;/head&gt;&#39;+
    &#39;&lt;body&gt;&#39;+
    &#39;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&#39;+
    &#39;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&#39;+
    &#39;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&#39;+
    &#39;&lt;/form&gt;&#39;+
    &#39;&lt;/body&gt;&#39;+
    &#39;&lt;/html&gt;&#39;;

    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;);
    response.write(body);
    response.end();
&#125;

function upload(response, postData) &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
  response.write(&quot;You&#39;ve sent: &quot; + postData);
  response.end();
&#125;

exports.start = start;
exports.upload = upload;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。</span><br><span class="line"></span><br><span class="line">我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。</span><br><span class="line"></span><br><span class="line">我们可以使用此前介绍过的&#96;querystring模块&#96;来实现：</span><br></pre></td></tr></table></figure>
var querystring = require(&quot;querystring&quot;);

function start(response, postData) &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  var body = &#39;&lt;html&gt;&#39;+
    &#39;&lt;head&gt;&#39;+
    &#39;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &#39;+
    &#39;charset=UTF-8&quot; /&gt;&#39;+
    &#39;&lt;/head&gt;&#39;+
    &#39;&lt;body&gt;&#39;+
    &#39;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&#39;+
    &#39;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&#39;+
    &#39;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&#39;+
    &#39;&lt;/form&gt;&#39;+
    &#39;&lt;/body&gt;&#39;+
    &#39;&lt;/html&gt;&#39;;

    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;);
    response.write(body);
    response.end();
&#125;

function upload(response, postData) &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
  response.write(&quot;You&#39;ve sent the text: &quot;+
  querystring.parse(postData).text);
  response.end();
&#125;

exports.start = start;
exports.upload = upload;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">好了，以上就是关于处理POST数据的全部内容。</span><br><span class="line"></span><br><span class="line">## 处理文件上传</span><br><span class="line"></span><br><span class="line">最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。</span><br><span class="line"></span><br><span class="line">回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。</span><br><span class="line"></span><br><span class="line">这里我们要用到的外部模块是Felix Geisendörfer开发的node-formidable模块。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传“就是”处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。</span><br><span class="line"></span><br><span class="line">使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：</span><br></pre></td></tr></table></figure>
npm install formidable
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果终端输出如下内容：</span><br></pre></td></tr></table></figure>
npm info build Success: formidable@1.0.9
npm ok
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就说明模块已经安装成功了。</span><br><span class="line"></span><br><span class="line">现在我们就可以用&#96;formidable模块&#96;了——使用外部模块与内部模块类似，用require语句将其引入即可：</span><br></pre></td></tr></table></figure>
var formidable = require(&quot;formidable&quot;);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。</span><br></pre></td></tr></table></figure>
node-formidable官方的例子展示了这两部分是如何融合在一起工作的：

var formidable = require(&#39;formidable&#39;),
    http = require(&#39;http&#39;),
    util = require(&#39;util&#39;);

http.createServer(function(req, res) &#123;
  if (req.url == &#39;/upload&#39; &amp;&amp; req.method.toLowerCase() == &#39;post&#39;) &#123;
    // parse a file upload
    var form = new formidable.IncomingForm();
    form.parse(req, function(err, fields, files) &#123;
      res.writeHead(200, &#123;&#39;content-type&#39;: &#39;text/plain&#39;&#125;);
      res.write(&#39;received upload:\n\n&#39;);
      res.end(util.inspect(&#123;fields: fields, files: files&#125;));
    &#125;);
    return;
  &#125;

  // show a file upload form
  res.writeHead(200, &#123;&#39;content-type&#39;: &#39;text/html&#39;&#125;);
  res.end(
    &#39;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; &#39;+
    &#39;method=&quot;post&quot;&gt;&#39;+
    &#39;&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;&lt;br&gt;&#39;+
    &#39;&lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt;&lt;br&gt;&#39;+
    &#39;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;&#39;+
    &#39;&lt;/form&gt;&#39;
  );
&#125;).listen(8888);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用&#96;form.parse&#96;传递给回调函数的&#96;files对象&#96;的内容，如下所示：</span><br></pre></td></tr></table></figure>
received upload:

&#123; fields: &#123; title: &#39;Hello World&#39; &#125;,
  files:
   &#123; upload:
      &#123; size: 1558,
        path: &#39;/tmp/1c747974a27a6292743669e91f29350b&#39;,
        name: &#39;us-flag.png&#39;,
        type: &#39;image/png&#39;,
        lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT,
        _writeStream: [Object],
        length: [Getter],
        filename: [Getter],
        mime: [Getter] &#125; &#125; &#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在&#x2F;tmp目录中）显示到浏览器中。</span><br><span class="line"></span><br><span class="line">我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？</span><br><span class="line"></span><br><span class="line">显然，我们需要将该文件读取到我们的服务器中，使用一个叫&#96;fs&#96;的模块。</span><br><span class="line"></span><br><span class="line">我们来添加&#96;&#x2F;show URL&#96;的请求处理程序，该处理程序直接硬编码将文件&#96;&#x2F;tmp&#x2F;test.png&#96;内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。</span><br><span class="line"></span><br><span class="line">将&#96;requestHandlers.js&#96;修改为如下形式：</span><br></pre></td></tr></table></figure>
var querystring = require(&quot;querystring&quot;),
    fs = require(&quot;fs&quot;);

function start(response, postData) &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  var body = &#39;&lt;html&gt;&#39;+
    &#39;&lt;head&gt;&#39;+
    &#39;&lt;meta http-equiv=&quot;Content-Type&quot; &#39;+
    &#39;content=&quot;text/html; charset=UTF-8&quot; /&gt;&#39;+
    &#39;&lt;/head&gt;&#39;+
    &#39;&lt;body&gt;&#39;+
    &#39;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&#39;+
    &#39;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&#39;+
    &#39;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&#39;+
    &#39;&lt;/form&gt;&#39;+
    &#39;&lt;/body&gt;&#39;+
    &#39;&lt;/html&gt;&#39;;

    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;);
    response.write(body);
    response.end();
&#125;

function upload(response, postData) &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
  response.write(&quot;You&#39;ve sent the text: &quot;+
  querystring.parse(postData).text);
  response.end();
&#125;

function show(response, postData) &#123;
  console.log(&quot;Request handler &#39;show&#39; was called.&quot;);
  fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) &#123;
    if(error) &#123;
      response.writeHead(500, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
      response.write(error + &quot;\n&quot;);
      response.end();
    &#125; else &#123;
      response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;image/png&quot;&#125;);
      response.write(file, &quot;binary&quot;);
      response.end();
    &#125;
  &#125;);
&#125;

exports.start = start;
exports.upload = upload;
exports.show = show;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中：</span><br></pre></td></tr></table></figure>
var server = require(&quot;./server&quot;);
var router = require(&quot;./router&quot;);
var requestHandlers = require(&quot;./requestHandlers&quot;);

var handle = &#123;&#125;
handle[&quot;/&quot;] = requestHandlers.start;
handle[&quot;/start&quot;] = requestHandlers.start;
handle[&quot;/upload&quot;] = requestHandlers.upload;
handle[&quot;/show&quot;] = requestHandlers.show;

server.start(router.route, handle);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">重启服务器之后，通过访问&#96;http:&#x2F;&#x2F;localhost:8888&#x2F;show&#96;，就可以看到保存在&#96;&#x2F;tmp&#x2F;test.png&#96;的图片了。</span><br><span class="line"></span><br><span class="line">好，最后我们要的就是：</span><br><span class="line"></span><br><span class="line">在&#96;&#x2F;start&#96;表单中添加一个文件上传元素</span><br><span class="line">将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到&#96;&#x2F;tmp&#x2F;test.png&#96;</span><br><span class="line">将上传的图片内嵌到&#96;&#x2F;uploadURL&#96;输出的HTML中</span><br><span class="line">第一项很简单。只需要在HTML表单中，添加一个&#96;multipart&#x2F;form-data&#96;的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下&#96;requestHandler.js&#96;所示：</span><br></pre></td></tr></table></figure>
var querystring = require(&quot;querystring&quot;),
    fs = require(&quot;fs&quot;);

function start(response, postData) &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  var body = &#39;&lt;html&gt;&#39;+
    &#39;&lt;head&gt;&#39;+
    &#39;&lt;meta http-equiv=&quot;Content-Type&quot; &#39;+
    &#39;content=&quot;text/html; charset=UTF-8&quot; /&gt;&#39;+
    &#39;&lt;/head&gt;&#39;+
    &#39;&lt;body&gt;&#39;+
    &#39;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; &#39;+
    &#39;method=&quot;post&quot;&gt;&#39;+
    &#39;&lt;input type=&quot;file&quot; name=&quot;upload&quot;&gt;&#39;+
    &#39;&lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&gt;&#39;+
    &#39;&lt;/form&gt;&#39;+
    &#39;&lt;/body&gt;&#39;+
    &#39;&lt;/html&gt;&#39;;

    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;);
    response.write(body);
    response.end();
&#125;

function upload(response, postData) &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
  response.write(&quot;You&#39;ve sent the text: &quot;+
  querystring.parse(postData).text);
  response.end();
&#125;

function show(response, postData) &#123;
  console.log(&quot;Request handler &#39;show&#39; was called.&quot;);
  fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) &#123;
    if(error) &#123;
      response.writeHead(500, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
      response.write(error + &quot;\n&quot;);
      response.end();
    &#125; else &#123;
      response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;image/png&quot;&#125;);
      response.write(file, &quot;binary&quot;);
      response.end();
    &#125;
  &#125;);
&#125;

exports.start = start;
exports.upload = upload;
exports.show = show;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将&#96;request对象&#96;传递给&#96;node-formidable&#96;的&#96;form.parse函数&#96;。</span><br><span class="line"></span><br><span class="line">但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。</span><br><span class="line"></span><br><span class="line">到这里，我们可以将postData从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了request对象中的数据，这意味着，对于&#96;form.parse&#96;来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存）</span><br><span class="line"></span><br><span class="line">我们从&#96;server.js&#96;开始 —— 移除对&#96;postData&#96;的处理以及&#96;request.setEncoding&#96; （这部分node-formidable自身会处理），转而采用将&#96;request对象&#96;传递给请求路由的方式：</span><br></pre></td></tr></table></figure>
var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) &#123;
  function onRequest(request, response) &#123;
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);
    route(handle, pathname, response, request);
  &#125;

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
&#125;

exports.start = start;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象：</span><br></pre></td></tr></table></figure>
function route(handle, pathname, response, request) &#123;
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === &#39;function&#39;) &#123;
    handle[pathname](response, request);
  &#125; else &#123;
    console.log(&quot;No request handler found for &quot; + pathname);
    response.writeHead(404, &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;);
    response.write(&quot;404 Not found&quot;);
    response.end();
  &#125;
&#125;

exports.route = route;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地&#x2F;tmp目录中，而我们需要做的是确保该文件保存成&#96;&#x2F;tmp&#x2F;test.png&#96;。 没错，我们保持简单，并假设只允许上传PNG图片。</span><br><span class="line"></span><br><span class="line">这里采用&#96;fs.renameSync(path1,path2)&#96;来实现。要注意的是，正如其名，该方法是同步执行的， 也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。</span><br><span class="line"></span><br><span class="line">接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示：</span><br></pre></td></tr></table></figure>
var querystring = require(&quot;querystring&quot;),
    fs = require(&quot;fs&quot;),
    formidable = require(&quot;formidable&quot;);

function start(response) &#123;
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  var body = &#39;&lt;html&gt;&#39;+
    &#39;&lt;head&gt;&#39;+
    &#39;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &#39;+
    &#39;charset=UTF-8&quot; /&gt;&#39;+
    &#39;&lt;/head&gt;&#39;+
    &#39;&lt;body&gt;&#39;+
    &#39;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; &#39;+
    &#39;method=&quot;post&quot;&gt;&#39;+
    &#39;&lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt;&#39;+
    &#39;&lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&gt;&#39;+
    &#39;&lt;/form&gt;&#39;+
    &#39;&lt;/body&gt;&#39;+
    &#39;&lt;/html&gt;&#39;;

    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;);
    response.write(body);
    response.end();
&#125;

function upload(response, request) &#123;
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);

  var form = new formidable.IncomingForm();
  console.log(&quot;about to parse&quot;);
  form.parse(request, function(error, fields, files) &#123;
    console.log(&quot;parsing done&quot;);
    fs.renameSync(files.upload.path, &quot;/tmp/test.png&quot;);
    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;);
    response.write(&quot;received image:&lt;br/&gt;&quot;);
    response.write(&quot;&lt;img src=&#39;/show&#39; /&gt;&quot;);
    response.end();
  &#125;);
&#125;

function show(response) &#123;
  console.log(&quot;Request handler &#39;show&#39; was called.&quot;);
  fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) &#123;
    if(error) &#123;
      response.writeHead(500, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);
      response.write(error + &quot;\n&quot;);
      response.end();
    &#125; else &#123;
      response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;image/png&quot;&#125;);
      response.write(file, &quot;binary&quot;);
      response.end();
    &#125;
  &#125;);
&#125;

exports.start = start;
exports.upload = upload;
exports.show = show;
```
好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。

## 总结与展望

恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。

当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。

但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。

幸运的是，Node.js社区非常活跃（作个不恰当的比喻就是犹如一群有多动症小孩子在一起，能不活跃吗？）， 这意味着，有许多关于Node.js的资源，有什么问题都可以向社区寻求解答。 其中Node.js社区的wiki以及 NodeCloud就是最好的资源。


# 购买“Node入门”中文版电子书

$0.99  [立即购买](https://leanpub.com/nodebeginner-chinese)
本书共42页 
支持PDF格式，Kindle以及ePub格式 
直接下载，免费更新

“这是我读过最好的教程之一。此前作为一名Java程序员，我总觉得JavaScript像妖术，但在这教程中，你真的把它讲解的浅显易懂。”
“真的忍不住要感谢你这么好的node入门教程，内容非常精彩。”
“这是为数不多的让我认认真真完整读完的入门教程，只因实在写得太好了.</code></pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"># javascript</a>
              <a href="/tags/node-js/" rel="tag"># node.js</a>
              <a href="/tags/%E5%85%A5%E9%97%A8/" rel="tag"># 入门</a>
              <a href="/tags/language/" rel="tag"># language</a>
              <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"># 基础</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/09/25/bjbh/" rel="prev" title="Node.js 包教不会">
      <i class="fa fa-chevron-left"></i> Node.js 包教不会
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/10/02/%E5%85%AC%E9%92%A5%E4%B8%8E%E7%A7%81%E9%92%A5/" rel="next" title="公钥与私钥">
      公钥与私钥 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Instruction"><span class="nav-number">1.</span> <span class="nav-text">Instruction</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E"><span class="nav-number">1.1.</span> <span class="nav-text">关于</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.</span> <span class="nav-text">状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E8%80%85%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.</span> <span class="nav-text">读者对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E4%B9%A6%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.</span> <span class="nav-text">本书结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript%E4%B8%8ENode-js"><span class="nav-number">2.</span> <span class="nav-text">JavaScript与Node.js</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript%E4%B8%8E%E4%BD%A0"><span class="nav-number">2.1.</span> <span class="nav-text">JavaScript与你</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E7%9F%AD%E7%94%B3%E6%98%8E"><span class="nav-number">2.2.</span> <span class="nav-text">简短申明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFJavaScript"><span class="nav-number">2.3.</span> <span class="nav-text">服务端JavaScript</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9CHello-World%E2%80%9D"><span class="nav-number">2.4.</span> <span class="nav-text">“Hello World”</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9F%BA%E4%BA%8ENode-js%E7%9A%84web%E5%BA%94%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">一个完整的基于Node.js的web应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">应用不同模块分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="nav-number">4.</span> <span class="nav-text">构建应用的模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%9A%84HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">4.1.</span> <span class="nav-text">一个基础的HTTP服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">4.2.</span> <span class="nav-text">分析HTTP服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">4.3.</span> <span class="nav-text">进行函数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A9HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="nav-number">4.4.</span> <span class="nav-text">函数传递是如何让HTTP服务器工作的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%9B%9E%E8%B0%83"><span class="nav-number">4.5.</span> <span class="nav-text">基于事件驱动的回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84"><span class="nav-number">4.6.</span> <span class="nav-text">服务器是如何处理请求的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E6%A8%A1%E5%9D%97%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">4.7.</span> <span class="nav-text">服务端的模块放在哪里</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%AF%B7%E6%B1%82%E7%9A%84%E2%80%9C%E8%B7%AF%E7%94%B1%E2%80%9D"><span class="nav-number">4.8.</span> <span class="nav-text">如何来进行请求的“路由”</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xuefeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuefeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
