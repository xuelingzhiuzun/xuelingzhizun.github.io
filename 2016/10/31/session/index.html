<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Session一般译作会话，牛津词典对其的解释是进行某活动连续的一段时间。从不同的层面看待session，它有着类似但不全然相同的含义。">
<meta property="og:type" content="article">
<meta property="og:title" content="session">
<meta property="og:url" content="http://example.com/2016/10/31/session/index.html">
<meta property="og:site_name" content="XFNOTES">
<meta property="og:description" content="Session一般译作会话，牛津词典对其的解释是进行某活动连续的一段时间。从不同的层面看待session，它有着类似但不全然相同的含义。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-10-31T05:39:15.000Z">
<meta property="article:modified_time" content="2018-01-07T11:40:14.000Z">
<meta property="article:author" content="xuefeng">
<meta property="article:tag" content="node.js">
<meta property="article:tag" content="express">
<meta property="article:tag" content="session">
<meta property="article:tag" content="cookie">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2016/10/31/session/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>session | XFNOTES</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XFNOTES</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-ategories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>ategories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/10/31/session/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xuefeng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XFNOTES">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          session
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-31 13:39:15" itemprop="dateCreated datePublished" datetime="2016-10-31T13:39:15+08:00">2016-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-01-07 19:40:14" itemprop="dateModified" datetime="2018-01-07T19:40:14+08:00">2018-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node-js/" itemprop="url" rel="index"><span itemprop="name">node.js</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Session一般译作会话，牛津词典对其的解释是进行某活动连续的一段时间。从不同的层面看待session，它有着类似但不全然相同的含义。</p>
<a id="more"></a>
<h1 id="Session是什么"><a href="#Session是什么" class="headerlink" title="Session是什么"></a>Session是什么</h1><h2 id="与时俱进"><a href="#与时俱进" class="headerlink" title="与时俱进"></a>与时俱进</h2><ul>
<li><code>session</code> 在<code>express</code>中使用的时候需要安装中间件<code>express-session</code>，原本在<code>express</code>框架中使用<code>session</code>时是需要使用<code>cookie-parser</code>这个中间件的，但是在<code>express-session 1.5.0</code> 之后就不在需要了；如果额外使用了反而会造成一些错误。____本文下文叙述中还常常说明需要配合<code>cookie-parser</code>中间件，只需要忽略就好<h2 id="session-概述"><a href="#session-概述" class="headerlink" title="session 概述"></a>session 概述</h2></li>
</ul>
<p>Session一般译作会话，牛津词典对其的解释是进行某活动连续的一段时间。从不同的层面看待session，它有着类似但不全然相同的含义。比如，在web应用的用户看来，他打开浏览器访问一个电子商务网站，登录、并完成购物直到关闭浏览器，这是一个会话。而在web应用的开发者开来，用户登录时我需要创建一个数据结构以存储用户的登录信息，这个结构也叫做session。因此在谈论session的时候要注意上下文环境。而本文谈论的是一种基于HTTP协议的用以增强web应用能力的机制或者说一种方案，它不是单指某种特定的动态页面技术，而这种能力就是保持状态，也可以称作保持会话。</p>
<h2 id="为什么需要session"><a href="#为什么需要session" class="headerlink" title="为什么需要session"></a>为什么需要session</h2><p>谈及session一般是在web应用的背景之下，我们知道web应用是基于HTTP协议的，而HTTP协议恰恰是一种无状态协议。也就是说，用户从A页面跳转到B页面会重新发送一次HTTP请求，而服务端在返回响应的时候是无法获知该用户在请求B页面之前做了什么的。</p>
<p>** 对于HTTP的无状态性的原因，相关RFC里并没有解释，但联系到HTTP的历史以及应用场景，我们可以推测出一些理由： **</p>
<ol>
<li><p>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。那个时候没有动态页面技术，只有纯粹的静态HTML页面，因此根本不需要协议能保持状态；</p>
</li>
<li><p>用户在收到响应时，往往要花一些时间来阅读页面，因此如果保持客户端和服务端之间的连接，那么这个连接在大多数的时间里都将是空闲的，这是一种资源的无端浪费。所以HTTP原始的设计是默认短连接，即客户端和服务端完成一次请求和响应之后就断开TCP连接，服务器因此无法预知客户端的下一个动作，它甚至都不知道这个用户会不会再次访问，因此让HTTP协议来维护用户的访问状态也全然没有必要；</p>
</li>
<li><p>将一部分复杂性转嫁到以HTTP协议为基础的技术之上可以使得HTTP在协议这个层面上显得相对简单，而这种简单也赋予了HTTP更强的扩展能力。事实上，session技术从本质上来讲也是对HTTP协议的一种扩展。</p>
</li>
</ol>
<blockquote>
<p>总而言之，HTTP的无状态是由其历史使命而决定的。但随着网络技术的蓬勃发展，人们再也不满足于死板乏味的静态HTML，他们希望web应用能动起来，于是客户端出现了脚本和DOM技术，HTML里增加了表单，而服务端出现了CGI等等动态技术。</p>
</blockquote>
<p>而正是这种web动态化的需求，给HTTP协议提出了一个难题：一个无状态的协议怎样才能关联两次连续的请求呢？也就是说无状态的协议怎样才能满足有状态的需求呢？</p>
<p>此时有状态是必然趋势而协议的无状态性也是木已成舟，因此我们需要一些方案来解决这个矛盾，来保持HTTP连接状态，于是出现了cookie和session。</p>
<p>** 对于此部分内容，读者或许会有一些疑问，笔者在此先谈两点： **</p>
<p>** 1.无状态性和长连接可能有人会问，现在被广泛使用的HTTP1.1默认使用长连接，它还是无状态的吗？ **</p>
<p>连接方式和有无状态是完全没有关系的两回事。因为状态从某种意义上来讲就是数据，而连接方式只是决定了数据的传输方式，而不能决定数据。长连接是随着计算机性能的提高和网络环境的改善所采取的一种合理的性能上的优化，一般情况下，web服务器会对长连接的数量进行限制，以免资源的过度消耗。</p>
<p>** 2.无状态性和sessionSession是有状态的，而HTTP协议是无状态的，二者是否矛盾呢？ **</p>
<p>Session和HTTP协议属于不同层面的事物，后者属于ISO七层模型的最高层应用层，前者不属于后者，前者是具体的动态页面技术来实现的，但同时它又是基于后者的。在下文中笔者会分析Servlet/Jsp技术中的session机制，这会使你对此有更深刻的理解。<br>Cookie和Session</p>
<blockquote>
<p>上面提到解决HTTP协议自身无状态的方式有cookie和session。二者都能记录状态，前者是将状态数据保存在客户端，后者则保存在服务端。</p>
</blockquote>
<p>** 首先看一下cookie的工作原理，这需要有基本的HTTP协议基础。 **</p>
<p>cookie是在RFC2109（已废弃，被RFC2965取代）里初次被描述的，每个客户端最多保持三百个cookie，每个域名下最多20个Cookie（实际上一般浏览器现在都比这个多，如Firefox是50个），而每个cookie的大小为最多4K，不过不同的浏览器都有各自的实现。对于cookie的使用，最重要的就是要控制cookie的大小，不要放入无用的信息，也不要放入过多信息。</p>
<p>无论使用何种服务端技术，只要发送回的HTTP响应中包含如下形式的头，则视为服务器要求设置一个cookie：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-cookie:name&#x3D;name;expires&#x3D;date;path&#x3D;path;domain&#x3D;domain</span><br></pre></td></tr></table></figure>
<p>支持cookie的浏览器都会对此作出反应，即创建cookie文件并保存（也可能是内存cookie），用户以后在每次发出请求时，浏览器都要判断当前所有的cookie中有没有没失效（根据expires属性判断）并且匹配了path属性的cookie信息，如果有的话，会以下面的形式加入到请求头中发回服务端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: name&#x3D;&quot;zj&quot;; Path&#x3D;&quot;&#x2F;linkage&quot;</span><br></pre></td></tr></table></figure>
<p>服务端的动态脚本会对其进行分析，并做出相应的处理，当然也可以选择直接忽略。</p>
<p>这里牵扯到一个规范（或协议）与实现的问题，简单来讲就是规范规定了做成什么样子，那么实现就必须依据规范来做，这样才能互相兼容，但是各个实现所使用的方式却不受约束，也可以在实现了规范的基础上超出规范，这就称之为扩展了。无论哪种浏览器，只要想提供cookie的功能，那就必须依照相应的RFC规范来实现。所以这里服务器只管发Set-cookie头域，这也是HTTP协议无状态性的一种体现。</p>
<p>需要注意的是，出于安全性的考虑，cookie可以被浏览器禁用。</p>
<p>** 再看一下session的原理： **</p>
<p>笔者没有找到相关的RFC，因为session本就不是协议层面的事物。它的基本原理是服务端为每一个session维护一份会话信息数据，而客户端和服务端依靠一个全局唯一的标识来访问会话信息数据。用户访问web应用时，服务端程序决定何时创建session，创建session可以概括为三个步骤：</p>
<ol>
<li>生成全局唯一标识符（sessionid）；</li>
<li>开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务网站，这种事故会造成严重的后果。不过也可以写到文件里甚至存储在数据库中，这样虽然会增加I/O开销，但session可以实现某种程度的持久化，而且更有利于session的共享；</li>
<li>将session的全局唯一标示符发送给客户端。<br>问题的关键就在服务端如何发送这个session的唯一标识上。联系到HTTP协议，数据无非可以放到请求行、头域或Body里，基于此，一般来说会有两种常用的方式：cookie和URL重写。<ul>
<li>Cookie<br>读者应该想到了，对，服务端只要设置Set-cookie头就可以将session的标识符传送到客户端，而客户端此后的每一次请求都会带上这个标识符，由于cookie可以设置失效时间，所以一般包含session信息的cookie会设置失效时间为0，即浏览器进程有效时间。至于浏览器怎么处理这个0，每个浏览器都有自己的方案，但差别都不会太大（一般体现在新建浏览器窗口的时候）；</li>
<li>URL重写<br>所谓URL重写，顾名思义就是重写URL。试想，在返回用户请求的页面之前，将页面内所有的URL后面全部以get参数的方式加上session标识符（或者加在path info部分等等），这样用户在收到响应之后，无论点击哪个链接或提交表单，都会在再带上session的标识符，从而就实现了会话的保持。读者可能会觉得这种做法比较麻烦，确实是这样，但是，如果客户端禁用了cookie的话，URL重写将会是首选。</li>
</ul>
</li>
</ol>
<p>到这里，读者应该明白我前面为什么说session也算作是对HTTP的一种扩展了吧。如下两幅图是笔者在Firefox的Firebug插件中的截图，可以看到，当我第一次访问index.jsp时，响应头里包含了Set-cookie头，而请求头中没有。当我再次刷新页面时，图二显示在响应中不在有Set-cookie头，而在请求头中却有了Cookie头。注意一下Cookie的名字：jsessionid，顾名思义，就是session的标识符，另外可以看到两幅图中的jsessionid的值是相同的，原因笔者就不再多解释了。另外读者可能在一些网站上见过在最后附加了一段形如jsessionid=xxx的URL，这就是采用URL重写来实现的session。</p>




<p>** Cookie和session由于实现手段不同，因此也各有优缺点和各自的应用场景： **</p>
<ol>
<li>  应用场景<br>Cookie的典型应用场景是Remember Me服务，即用户的账户信息通过cookie的形式保存在客户端，当用户再次请求匹配的URL的时候，账户信息会被传送到服务端，交由相应的程序完成自动登录等功能。当然也可以保存一些客户端信息，比如页面布局以及搜索历史等等。<br>Session的典型应用场景是用户登录某网站之后，将其登录信息放入session，在以后的每次请求中查询相应的登录信息以确保该用户合法。当然还是有购物车等等经典场景；</li>
<li>  安全性<br>cookie将信息保存在客户端，如果不进行加密的话，无疑会暴露一些隐私信息，安全性很差，一般情况下敏感信息是经过加密后存储在cookie中，但很容易就会被窃取。而session只会将信息存储在服务端，如果存储在文件或数据库中，也有被窃取的可能，只是可能性比cookie小了太多。<br>Session安全性方面比较突出的是存在会话劫持的问题，这是一种安全威胁，这在下文会进行更详细的说明。总体来讲，session的安全性要高于cookie；</li>
<li>  性能<br>Cookie存储在客户端，消耗的是客户端的I/O和内存，而session存储在服务端，消耗的是服务端的资源。但是session对服务器造成的压力比较集中，而cookie很好地分散了资源消耗，就这点来说，cookie是要优于session的；</li>
<li>  时效性<br>Cookie可以通过设置有效期使其较长时间内存在于客户端，而session一般只有比较短的有效期（用户主动销毁session或关闭浏览器后引发超时）；</li>
<li>  其他<br>Cookie的处理在开发中没有session方便。而且cookie在客户端是有数量和大小的限制的，而session的大小却只以硬件为限制，能存储的数据无疑大了太多。</li>
</ol>
<h2 id="session-存储使用中各个中间件的配合"><a href="#session-存储使用中各个中间件的配合" class="headerlink" title="session 存储使用中各个中间件的配合"></a>session 存储使用中各个中间件的配合</h2><ul>
<li>connect-mongo    // MongoDB session store for Connect and Express (其实不止可以存储到mongDB中，也可以存储到其它位置，如内存什么的，这里默认选型为存储到mongoDB中，故选此中间件。而且此中间件默认搭配的session中间件为express-session，但是不必要基于mongoose，它也可以native-mongodb-native，详细资料见<a target="_blank" rel="noopener" href="https://github.com/jdesboeufs/connect-mongo#connect-mongo">官网</a>)</li>
<li>express-session  //基于express框专门用于处理session的中间件</li>
<li><a target="_blank" rel="noopener" href="http://xfnotes.oschina.io/2016/10/31/connect-flash/">connect-flash</a>    //flash属于session中的一块特殊的存储区域，本模块将在上述中间件的支持下用于一次性的消息提示</li>
</ul>
<h1 id="express框架之session"><a href="#express框架之session" class="headerlink" title="express框架之session"></a>express框架之session</h1><h2 id="session之内存存储（本小结不一定正确）"><a href="#session之内存存储（本小结不一定正确）" class="headerlink" title="session之内存存储（本小结不一定正确）"></a>session之内存存储（本小结不一定正确）</h2><p><code>express-session</code> 是基于express框专门用于处理session的中间件。这里不谈express-session怎么安装，只给出相应的实例代码。按照下面的代码获得的session，一般是被存在内存中的。另外，session的认证机制离不开cookie，需要同时使用cookieParser 中间件，有关的介绍可以专门参考<a target="_blank" rel="noopener" href="https://github.com/expressjs/session/blob/master/README.md">官网</a>，或者参考<a target="_blank" rel="noopener" href="http://blog.modulus.io/nodejs-and-express-sessions">博客</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var session &#x3D; require(&#39;express-session&#39;);</span><br><span class="line">var cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class="line"></span><br><span class="line">var app &#x3D; express();</span><br><span class="line"></span><br><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    secret: &#39;12345&#39;,</span><br><span class="line">    name: &#39;testapp&#39;,   &#x2F;&#x2F;这里的name值得是cookie的name，默认cookie的name是：connect.sid</span><br><span class="line">    cookie: &#123;maxAge: 80000 &#125;,  &#x2F;&#x2F;设置maxAge是80000ms，即80s后session和相应的cookie失效过期</span><br><span class="line">    resave: false,</span><br><span class="line">    saveUninitialized: true,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;awesome&#39;, function(req, res)&#123;</span><br><span class="line">    </span><br><span class="line">    if(req.session.lastPage) &#123;</span><br><span class="line">        console.log(&#39;Last page was: &#39; + req.session.lastPage + &quot;.&quot;);    </span><br><span class="line">    &#125;    </span><br><span class="line">    req.session.lastPage &#x3D; &#39;&#x2F;awesome&#39;; &#x2F;&#x2F;每一次访问时，session对象的lastPage会自动的保存或更新内存中的session中去。</span><br><span class="line">    res.send(&quot;You&#39;re Awesome. And the session expired time is: &quot; + req.session.cookie.maxAge);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;radical&#39;, function(req, res)&#123;</span><br><span class="line">    if (req.session.lastPage) &#123;</span><br><span class="line">        console.log(&#39;Last page was: &#39; + req.session.lastPage + &quot;.&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">    req.session.lastPage &#x3D; &#39;&#x2F;radical&#39;;  </span><br><span class="line">    res.send(&#39;What a radical visit! And the session expired time is: &#39; + req.session.cookie.maxAge);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;tubular&#39;, function(req, res)&#123;</span><br><span class="line">    if (req.session.lastPage)&#123;</span><br><span class="line">        console.log(&quot;Last page was: &quot; + req.session.lastPage + &quot;.&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.session.lastPage &#x3D; &#39;&#x2F;tubular&#39;;</span><br><span class="line">    res.send(&#39;Are you a suffer? And the session expired time is: &#39; + req.session.cookie.maxAge);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(5000);</span><br></pre></td></tr></table></figure>

<h2 id="express-session中间件的使用"><a href="#express-session中间件的使用" class="headerlink" title="express-session中间件的使用"></a>express-session中间件的使用</h2><p>只需要用express app的use方法将session挂载在‘/’路径即可，这样所有的路由都可以访问到session。可以给要挂载的session传递不同的option参数，来控制session的不同特性。具体可以参见官网：<a target="_blank" rel="noopener" href="https://github.com/expressjs/session/blob/master/README.md">https://github.com/expressjs/session/blob/master/README.md</a></p>
<h2 id="session内容的存储和更改-应用到express中"><a href="#session内容的存储和更改-应用到express中" class="headerlink" title="session内容的存储和更改(应用到express中)"></a>session内容的存储和更改(应用到express中)</h2><blockquote>
<p>To store or access session data, simply use the request property req.session, which is (generally) serialized as JSON by the store, so nested objects are typically fine.</p>
</blockquote>
<p>一旦我们将express-session中间件用use挂载后，我们可以很方便的通过req参数来存储和访问session对象的数据。req.session是一个JSON格式的JavaScript对象，我们可以在使用的过程中随意的增加成员，这些成员会自动的被保存到option参数指定的地方，默认即为内存中去。</p>
<h2 id="session之mongoose存储"><a href="#session之mongoose存储" class="headerlink" title="session之mongoose存储"></a>session之mongoose存储</h2><p>有时候，我们需要session的声明周期要长一点，比如好多网站有个免密码两周内自动登录的功能。基于这个需求，session必须寻找内存之外的存储载体，数据库能提供完美的解决方案。这里，我选用的是mongodb数据库，作为一个NoSQL数据库，它的基础数据对象时database-collection-document 对象模型非常直观并易于理解，针对node.js 也提供了丰富的驱动和API。express框架提供了针对mongodb的中间件：connect-mongo，我们只需在挂载session的时候在options中传入mongodb的参数即可，程序运行的时候, express app 会自动的替我们管理session的存储，更新和删除。具体可以参考：<a target="_blank" rel="noopener" href="https://github.com/kcbanner/connect-mongo">https://github.com/kcbanner/connect-mongo</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 测试代码</span><br><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var session &#x3D; require(&#39;express-session&#39;);</span><br><span class="line">var cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class="line">var MongoStore &#x3D; require(&#39;connect-mongo&#39;)(session);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line"></span><br><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    secret: &#39;12345&#39;,</span><br><span class="line">    name: &#39;testapp&#39;,</span><br><span class="line">    cookie: &#123;maxAge: 80000 &#125;,</span><br><span class="line">    resave: false,</span><br><span class="line">    saveUninitialized: true,</span><br><span class="line">    store: new MongoStore(&#123;   &#x2F;&#x2F;创建新的mongodb数据库</span><br><span class="line">        host: &#39;localhost&#39;,    &#x2F;&#x2F;数据库的地址，本机的话就是127.0.0.1，也可以是网络主机</span><br><span class="line">        port: 27017,          &#x2F;&#x2F;数据库的端口号</span><br><span class="line">        db: &#39;test-app&#39;        &#x2F;&#x2F;数据库的名称。</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;awesome&#39;, function(req, res)&#123;</span><br><span class="line">    </span><br><span class="line">    if(req.session.lastPage) &#123;</span><br><span class="line">        console.log(&#39;Last page was: &#39; + req.session.lastPage + &quot;.&quot;);    </span><br><span class="line">    &#125;    </span><br><span class="line">    req.session.lastPage &#x3D; &#39;&#x2F;awesome&#39;;</span><br><span class="line">    res.send(&quot;You&#39;re Awesome. And the session expired time is: &quot; + req.session.cookie.maxAge);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;radical&#39;, function(req, res)&#123;</span><br><span class="line">    if (req.session.lastPage) &#123;</span><br><span class="line">        console.log(&#39;Last page was: &#39; + req.session.lastPage + &quot;.&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">    req.session.lastPage &#x3D; &#39;&#x2F;radical&#39;;</span><br><span class="line">    res.send(&#39;What a radical visit! And the session expired time is: &#39; + req.session.cookie.maxAge);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;tubular&#39;, function(req, res)&#123;</span><br><span class="line">    if (req.session.lastPage)&#123;</span><br><span class="line">        console.log(&quot;Last page was: &quot; + req.session.lastPage + &quot;.&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.session.lastPage &#x3D; &#39;&#x2F;tubular&#39;;</span><br><span class="line">    res.send(&#39;Are you a suffer? And the session expired time is: &#39; + req.session.cookie.maxAge);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(5000);</span><br></pre></td></tr></table></figure>

<p>跟session的内存存储一样，只需增加红色部分的store选项即可，app会自动替我们把session存入到mongodb数据，而非内存中。</p>
<h2 id="session的生命周期"><a href="#session的生命周期" class="headerlink" title="session的生命周期"></a>session的生命周期</h2><p>session与发送到客户端浏览器的生命周期是一致的。而我们在挂载session的时候，通过option选项的cookie.maxAge成员，我们可以设置session的过期时间，以ms为单位（但是，如果session存储在mongodb中的话，任何低于60s(60000ms)的设置是没有用的，下文会有详细的解释）。如果maxAge不设置，默认为null，这样的expire的时间就是浏览器的关闭时间，即每次关闭浏览器的时候，session都会失效</p>
<p>由于session是存在服务器端数据库的，所以的它的生命周期可以持久化，而不仅限于浏览器关闭的时间。具体是由cookie.maxAge 决定：如果maxAge设定是1个小时，那么从这个因浏览器访问服务器导致session创建开始后，session会一直保存在服务器端，即使浏览器关闭，session也会继续存在。如果此时服务器宕机，只要开机后数据库没发生不可逆转的破坏，maxAge时间没过期，那么session是可以继续保持的。</p>
<p>当maxAge时间过期后，session会自动的数据库中移除，对应的还有浏览器的cookie。不过，由于connect-mongo的特殊机制（每1分钟检查一次过期session），session的移除可能在时间上会有一定的滞后。</p>
<blockquote>
<p>connect-mongo uses MongoDB’s TTL collection feature (2.2+) to have mongod automatically remove expired sessions. (mongod runs this check every minute.)</p>
<p>Note: By connect/express’s default, session cookies are set to expire when the user closes their browser (maxAge: null). In accordance with standard industry practices, connect-mongo will set these sessions to expire two weeks from their last ‘set’. You can override this behavior by manually setting the maxAge for your cookies – just keep in mind that any value less than 60 seconds is pointless, as mongod will only delete expired documents in a TTL collection every minute.</p>
</blockquote>
<p>当然，由于cookie是由浏览器厂商实现的，cookie不具有跨浏览器的特性，例如，我用firefox浏览器在京东上购物时，勾选了2周内免密码输入，但是当我第一次用IE登陆京东时，同样要重新输入密码。所以，这对服务器的同一个操作，不同的浏览器发起的请求，会产生不同的session-cookie</p>
<p>本章转自<a target="_blank" rel="noopener" href="http://www.cnblogs.com/chenchenluo/p/4197181.html">.cnblogs</a></p>
<h1 id="express-session部分文档翻译"><a href="#express-session部分文档翻译" class="headerlink" title="express-session部分文档翻译"></a>express-session部分文档翻译</h1><ul>
<li><strong>作用</strong>：用指定的参数创建一个session中间件，sesison数据不是保存在cookie中，仅仅sessionID保存到cookie中，session的数据仅仅保存在服务器端</li>
<li><strong>警告</strong>：默认的服务器端的session存储，MemoryStore不是为了生产环境创建的，大多数情况下会内存泄露，主要用于测试和开发环境</li>
</ul>
<h2 id="接受的参数："><a href="#接受的参数：" class="headerlink" title="接受的参数："></a>接受的参数：</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie:"></a>cookie:</h3><p> 也就是<code>session ID</code>的<code>cookie</code>，默认是<code>&#123; path: &#39;/&#39;, httpOnly: true, secure: false, maxAge: null &#125;</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cookie = <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">Cookie</span>(<span class="params">options</span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">this</span>.path = <span class="string">&#x27;/&#x27;</span>;  </span><br><span class="line">  <span class="built_in">this</span>.maxAge = <span class="literal">null</span>;  </span><br><span class="line">  <span class="built_in">this</span>.httpOnly = <span class="literal">true</span>;  </span><br><span class="line">  <span class="keyword">if</span> (options) merge(<span class="built_in">this</span>, options);  </span><br><span class="line">  <span class="built_in">this</span>.originalMaxAge = <span class="literal">undefined</span> == <span class="built_in">this</span>.originalMaxAge  </span><br><span class="line">    ? <span class="built_in">this</span>.maxAge  </span><br><span class="line">    : <span class="built_in">this</span>.originalMaxAge;  </span><br><span class="line">  <span class="comment">//默认的originalMaxAge就是this.maxAge也就是null,如果指定了originalMaxAge那么就是用户指定的值  </span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<h3 id="genid"><a href="#genid" class="headerlink" title="genid:"></a>genid:</h3><p> 产生一个新的<code>session ID</code>的函数，一个返回值是<code>string</code>类型的函数会被作为<code>session ID</code>.这个函数第一个参数是<code>req</code>,所以如果你想要<code>req</code>中的参数产生<code>session ID</code>还是很不错的;默认函数是使用<code>uid-safe</code>这个库产生id值(产生一个算法上安全的UID，可以用于cookie也可以用于URL。和rand-token和uid2相比，后者由于使用了%导致UID产生偏态，同时可能对UID产生不必要的截断。我们的uid-safe使用的是base64算法，其函数uid(byteLength, callback)中第一个参数是比特长度而不是字符串长度)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use(session(&#123;  </span><br><span class="line">   genid: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> genuuid() <span class="comment">// use UUIDs for session IDs   </span></span><br><span class="line">   &#125;,  </span><br><span class="line">   secret: <span class="string">&#x27;keyboard cat&#x27;</span>  </span><br><span class="line"> &#125;)  </span><br></pre></td></tr></table></figure>
<p>源码片段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateSessionId</span>(<span class="params">sess</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> uid(<span class="number">24</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  <span class="keyword">var</span> generateId = options.genid || generateSessionId;<span class="comment">//如果用户没有传入genid参数那么就是默认使用generateSessionId函数来完成  </span></span><br></pre></td></tr></table></figure>
<h3 id="name"><a href="#name" class="headerlink" title="name:"></a>name:</h3><p>在response中sessionID这个cookie的名称。也可以通过这个name读取，默认是connect.sid。如果一台机器上有多个app运行在同样的hostname+port, 那么你需要对这个sessin的cookie进行切割，所以最好的方法还是通过name设置不同的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = options.name || options.key || <span class="string">&#x27;connect.sid&#x27;</span><span class="comment">//很显然cookie的name默认是connect.sid，而且首先获取到的name而不是key  </span></span><br><span class="line">r cookieId = req.sessionID = getcookie(req, name, secrets);  </span><br></pre></td></tr></table></figure>
<h3 id="resave"><a href="#resave" class="headerlink" title="resave:"></a>resave:</h3><p>强制session保存到session store中。即使在请求中这个session没有被修改。但是这个并不一定是必须的，如果客户端有两个并行的请求到你的客户端，一个请求对session的修改可能被另外一个请求覆盖掉，即使第二个请求并没有修改sesion。默认是true,但是默认值已经过时，因此以后default可能会被修改。因此好好研究你的需求选择一个最适用的。大多数情况下你可能需要false 最好的知道你的store是否需要设置resave的方法是通过查看你的store是否实现了touch方法(删除那些空闲的session。同时这个方法也会通知session store指定的session是活动态的)，如果实现了那么你可以用resave:false,如果没有实现touch方法，同时你的store对保存的session设置了一个过期的时间，那么建议你用resave:true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resaveSession = options.resave;  </span><br><span class="line">  <span class="keyword">if</span> (resaveSession === <span class="literal">undefined</span>) &#123;  </span><br><span class="line">    deprecate(<span class="string">&#x27;undefined resave option; provide resave option&#x27;</span>);  </span><br><span class="line">    resaveSession = <span class="literal">true</span>;<span class="comment">//如果用户没有指定resavedSession那么默认就是true  </span></span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure>

<p>我们再来看看其他的逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  store.get(req.sessionID, <span class="function"><span class="keyword">function</span>(<span class="params">err, sess</span>)</span>&#123;  </span><br><span class="line">      <span class="comment">// error handling</span></span><br><span class="line">      <span class="comment">//如果报错那么也会创建一个session</span></span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        debug(<span class="string">&#x27;error %j&#x27;</span>, err);</span><br><span class="line">        <span class="keyword">if</span> (err.code !== <span class="string">&#x27;ENOENT&#x27;</span>) &#123;</span><br><span class="line">          next(err);</span><br><span class="line">          <span class="keyword">return</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        generate();</span><br><span class="line">      <span class="comment">// no session那么就会创建一个session</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!sess) &#123;</span><br><span class="line">        debug(<span class="string">&#x27;no session found&#x27;</span>);</span><br><span class="line">        generate();</span><br><span class="line">      <span class="comment">// populate req.session  </span></span><br><span class="line">      <span class="comment">//如果找到了这个session处理的代码逻辑  </span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        debug(<span class="string">&#x27;session found&#x27;</span>);  </span><br><span class="line">        store.createSession(req, sess);  </span><br><span class="line">        originalId = req.sessionID;  </span><br><span class="line">        originalHash = hash(sess);  </span><br><span class="line">        <span class="comment">//originalHash保存的是找到的这个session的hash结果，如果明确指定了resave为false那么savedHash就是原来的session的结果  </span></span><br><span class="line">        <span class="keyword">if</span> (!resaveSession) &#123;  </span><br><span class="line">          savedHash = originalHash  </span><br><span class="line">        &#125;  </span><br><span class="line">        wrapmethods(req.session);  </span><br><span class="line">      &#125;  </span><br><span class="line">      next();  </span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>其中经过了前面的if语句后我们的savedHash就是originalHash，我们看看这个逻辑在判断这个session是否已经保存的时候再次用到了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSaved</span>(<span class="params">sess</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> originalId === sess.id &amp;&amp; savedHash === hash(sess);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="rolling"><a href="#rolling" class="headerlink" title="rolling:"></a>rolling:</h3><p>强制在每一个response中都发送session标识符的cookie。如果把expiration设置为一个过去的时间那么 那么过期时间设置为默认的值。roling默认是false。如果把这个值设置为true但是saveUnitialized设置为false,那么cookie不会被包含在响应中(没有初始化的session)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollingSessions = options.rolling || <span class="literal">false</span>;<span class="comment">//默认为false  </span></span><br></pre></td></tr></table></figure>

<p>我们看看rolling用于了什么环境了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法用户判断是否需要在请求头中设置cookie  </span></span><br><span class="line"> <span class="comment">// determine if cookie should be set on response  </span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">shouldSetCookie</span>(<span class="params">req</span>) </span>&#123;  </span><br><span class="line">   <span class="comment">// cannot set cookie without a session ID  </span></span><br><span class="line">   <span class="comment">//如果没有sessionID直接返回，这时候不用设置cookie  </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> req.sessionID !== <span class="string">&#x27;string&#x27;</span>) &#123;  </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//var cookieId = req.sessionID = getcookie(req, name, secrets);  </span></span><br><span class="line">   <span class="keyword">return</span> cookieId != req.sessionID    </span><br><span class="line">     ? saveUninitializedSession || isModified(req.session)  </span><br><span class="line">     <span class="comment">//rollingSessions = options.rolling || false,其中rolling表示sessionCookie在每一个响应中都应该被发送。也就是说如果用户设置了rolling即使sessionID没有被修改  </span></span><br><span class="line">     <span class="comment">//也依然会把session的cookie发送到浏览器  </span></span><br><span class="line">     : rollingSessions || req.session.cookie.expires != <span class="literal">null</span> &amp;&amp; isModified(req.session);  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>

<p>很显然，如果客户端发送的sessionID和服务器的sessionID一致，如果你指定了rolling为true，那么还是会发送这个session的cookie到客户端，但是如果你设置了rolling为false，那么这时候如果同时设置了req.session.cookie.expires，而且这个req.session被修改了这时候还是会把session的cookie发送到客户端!</p>
<h3 id="saveUninitialized"><a href="#saveUninitialized" class="headerlink" title="saveUninitialized:"></a>saveUninitialized:</h3><p>强制没有“初始化”的session保存到storage中，没有初始化的session指的是：刚被创建没有被修改,如果是要实现登陆的session那么最好设置为false(reducing server storage usage, or complying with laws that require permission before setting a cookie) 而且设置为false还有一个好处，当客户端没有session的情况下并行发送多个请求时。默认是true,但是不建议使用默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> saveUninitializedSession = options.saveUninitialized;  </span><br><span class="line">/如果用户不指定saveUninitializedSession那么提示用户并设置saveUninitializedSession为<span class="literal">true</span>  </span><br><span class="line"><span class="keyword">if</span> (saveUninitializedSession === <span class="literal">undefined</span>) &#123;  </span><br><span class="line">  deprecate(<span class="string">&#x27;undefined saveUninitialized option; provide saveUninitialized option&#x27;</span>);  </span><br><span class="line">  saveUninitializedSession = <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们来看看这个参数用于做什么判断，首先看看shouldSave方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// determine if session should be saved to store  </span></span><br><span class="line">   <span class="comment">//判断是否需要把session保存到到store中  </span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">shouldSave</span>(<span class="params">req</span>) </span>&#123;  </span><br><span class="line">     <span class="comment">// cannot set cookie without a session ID  </span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> req.sessionID !== <span class="string">&#x27;string&#x27;</span>) &#123;  </span><br><span class="line">       debug(<span class="string">&#x27;session ignored because of bogus req.sessionID %o&#x27;</span>, req.sessionID);  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">//  var saveUninitializedSession = options.saveUninitialized;  </span></span><br><span class="line">     <span class="comment">// var cookieId = req.sessionID = getcookie(req, name, secrets);  </span></span><br><span class="line">     <span class="keyword">return</span> !saveUninitializedSession &amp;&amp; cookieId !== req.sessionID  </span><br><span class="line">       ? isModified(req.session)  </span><br><span class="line">       : !isSaved(req.session)  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果用户指明了不能保存未初始化的session，同时服务器的req.sessionID和浏览器发送过来的不一致，这时候只有在服务器的session修改的时候会保存。如果前面的前提不满足那么就需要看是否已经保存过了，如果没有保存过那么才会保存!</p>
<p>这个参数还被用于决定是否需要把session的cookie发送到客户端：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法用户判断是否需要在请求头中设置cookie  </span></span><br><span class="line">   <span class="comment">// determine if cookie should be set on response  </span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">shouldSetCookie</span>(<span class="params">req</span>) </span>&#123;  </span><br><span class="line">     <span class="comment">// cannot set cookie without a session ID  </span></span><br><span class="line">     <span class="comment">//如果没有sessionID直接返回，这时候不用设置cookie  </span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> req.sessionID !== <span class="string">&#x27;string&#x27;</span>) &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">//var cookieId = req.sessionID = getcookie(req, name, secrets);  </span></span><br><span class="line">     <span class="keyword">return</span> cookieId != req.sessionID    </span><br><span class="line">       ? saveUninitializedSession || isModified(req.session)  </span><br><span class="line">       <span class="comment">//rollingSessions = options.rolling || false,其中rolling表示sessionCookie在每一个响应中都应该被发送。也就是说如果用户设置了rolling即使sessionID没有被修改  </span></span><br><span class="line">       <span class="comment">//也依然会把session的cookie发送到浏览器  </span></span><br><span class="line">       : rollingSessions || req.session.cookie.expires != <span class="literal">null</span> &amp;&amp; isModified(req.session);  </span><br><span class="line">   &#125;  </span><br></pre></td></tr></table></figure>

<p>如果客户端和服务器端的sessionID不一致的前提下，如果用户指定了保存未初始化的session那么就需要发送，否则就只有在修改的时候才发送</p>
<h3 id="secret"><a href="#secret" class="headerlink" title="secret:"></a>secret:</h3><p>用于对sessionID的cookie进行签名，可以是一个string(一个secret)或者数组(多个secret)。如果指定了一个数组那么只会用 第一个元素对sessionID的cookie进行签名，其他的用于验证请求中的签名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> secret = options.secret;  </span><br><span class="line">  <span class="comment">//unsetDestroy表示用户是否指定了unset参数是destroy，是布尔值  </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(secret) &amp;&amp; secret.length === <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;secret option array must contain one or more strings&#x27;</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//保证secret保存的是一个数组，即使用户传入的仅仅是一个string  </span></span><br><span class="line">  <span class="keyword">if</span> (secret &amp;&amp; !<span class="built_in">Array</span>.isArray(secret)) &#123;  </span><br><span class="line">    secret = [secret];  </span><br><span class="line">  &#125;  </span><br><span class="line"> <span class="comment">//必须提供secret参数  </span></span><br><span class="line">  <span class="keyword">if</span> (!secret) &#123;  </span><br><span class="line">    deprecate(<span class="string">&#x27;req.secret; provide secret option&#x27;</span>);  </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure>

<h4 id="上述secret参数可用于的场景"><a href="#上述secret参数可用于的场景" class="headerlink" title="上述secret参数可用于的场景"></a>上述secret参数可用于的场景</h4><h5 id="getcookie方法用于从请求中获取sessionID进行解密，作为秘钥。"><a href="#getcookie方法用于从请求中获取sessionID进行解密，作为秘钥。" class="headerlink" title="getcookie方法用于从请求中获取sessionID进行解密，作为秘钥。"></a>getcookie方法用于从请求中获取sessionID进行解密，作为秘钥。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用：用于从请求对象request中获取session ID值，其中name就是我们在options中指定的，首先从req.headers.cookie获取，接着从req.signedCookies中获取，最后从req.cookies获取  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getcookie</span>(<span class="params">req, name, secrets</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> header = req.headers.cookie;  </span><br><span class="line">  <span class="keyword">var</span> raw;  </span><br><span class="line">  <span class="keyword">var</span> val;  </span><br><span class="line">  <span class="comment">// read from cookie header  </span></span><br><span class="line">  <span class="keyword">if</span> (header) &#123;  </span><br><span class="line">    <span class="keyword">var</span> cookies = cookie.parse(header);  </span><br><span class="line">    raw = cookies[name];  </span><br><span class="line">    <span class="keyword">if</span> (raw) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (raw.substr(<span class="number">0</span>, <span class="number">2</span>) === <span class="string">&#x27;s:&#x27;</span>) &#123;  </span><br><span class="line">        <span class="comment">//切割掉前面的字符&quot;s:&quot;!  </span></span><br><span class="line">        val = unsigncookie(raw.slice(<span class="number">2</span>), secrets);  </span><br><span class="line">        <span class="comment">//val表示false意味着客户端传递过来的cookie被篡改了!  </span></span><br><span class="line">        <span class="keyword">if</span> (val === <span class="literal">false</span>) &#123;  </span><br><span class="line">          debug(<span class="string">&#x27;cookie signature invalid&#x27;</span>);  </span><br><span class="line">          val = <span class="literal">undefined</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        debug(<span class="string">&#x27;cookie unsigned&#x27;</span>)  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// back-compat read from cookieParser() signedCookies data  </span></span><br><span class="line">  <span class="keyword">if</span> (!val &amp;&amp; req.signedCookies) &#123;  </span><br><span class="line">    val = req.signedCookies[name];  </span><br><span class="line">    <span class="keyword">if</span> (val) &#123;  </span><br><span class="line">      deprecate(<span class="string">&#x27;cookie should be available in req.headers.cookie&#x27;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// back-compat read from cookieParser() cookies data  </span></span><br><span class="line">  <span class="keyword">if</span> (!val &amp;&amp; req.cookies) &#123;  </span><br><span class="line">    raw = req.cookies[name];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (raw) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (raw.substr(<span class="number">0</span>, <span class="number">2</span>) === <span class="string">&#x27;s:&#x27;</span>) &#123;  </span><br><span class="line">        val = unsigncookie(raw.slice(<span class="number">2</span>), secrets);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (val) &#123;  </span><br><span class="line">          deprecate(<span class="string">&#x27;cookie should be available in req.headers.cookie&#x27;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (val === <span class="literal">false</span>) &#123;  </span><br><span class="line">          debug(<span class="string">&#x27;cookie signature invalid&#x27;</span>);  </span><br><span class="line">          val = <span class="literal">undefined</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        debug(<span class="string">&#x27;cookie unsigned&#x27;</span>)  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> val;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h5 id="setcookie方法用于对sessionID用指定的秘钥进行签名"><a href="#setcookie方法用于对sessionID用指定的秘钥进行签名" class="headerlink" title="setcookie方法用于对sessionID用指定的秘钥进行签名"></a>setcookie方法用于对sessionID用指定的秘钥进行签名</h5><p>不懂签名的概念可以阅读<a target="_blank" rel="noopener" href="https://niefengjun.cn/blog/576c6f44353308f7389956822726645b.html">阿里巴巴攻城师分享nodeJS精华：cookie 和 session</a>，也可查看另外一篇博客<a target="_blank" rel="noopener" href="http://blog.csdn.net/liangklfang/article/details/51072424">Cookie-Parser是如何解析签名后的cookie的(同时对cookie和cookie-signature进行说明)</a></p>
<p>setcookie(res, name, req.sessionID, secrets[0], cookie.data);<br>方法作用：为HTTP响应设置cookie，设置的cookie是把req.sessionID进行加密过后的cookie,其中name用于保存到客户端的sessionID的cookie的名称  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setcookie</span>(<span class="params">res, name, val, secret, options</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> signed = <span class="string">&#x27;s:&#x27;</span> + signature.sign(val, secret);  </span><br><span class="line">  <span class="comment">//对要发送的cookie进行加密，密钥为secret  </span></span><br><span class="line">  <span class="keyword">var</span> data = cookie.serialize(name, signed, options);  </span><br><span class="line">  <span class="comment">//其中options中可能有decode函数，返回序列化的cookie  </span></span><br><span class="line">  debug(<span class="string">&#x27;set-cookie %s&#x27;</span>, data);  </span><br><span class="line">  <span class="keyword">var</span> prev = res.getHeader(<span class="string">&#x27;set-cookie&#x27;</span>) || [];  </span><br><span class="line">  <span class="comment">//获取set-cookie头，默认是一个空数组  </span></span><br><span class="line">  <span class="keyword">var</span> header = <span class="built_in">Array</span>.isArray(prev) ? prev.concat(data)  </span><br><span class="line">    : <span class="built_in">Array</span>.isArray(data) ? [prev].concat(data)  </span><br><span class="line">    : [prev, data];  </span><br><span class="line">  <span class="comment">//通过set-cookie，发送到客户端  </span></span><br><span class="line">  res.setHeader(<span class="string">&#x27;set-cookie&#x27;</span>, header)  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h3 id="store"><a href="#store" class="headerlink" title="store:"></a>store:</h3><p>保存session的地方，默认是一个MemoryStore实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">store = options.store || <span class="keyword">new</span> MemoryStore  <span class="comment">// notify user that this store is not  </span></span><br><span class="line"><span class="comment">// meant for a production environment  </span></span><br><span class="line"><span class="comment">//如果在生产环境下，同时store也就是用户传入的store(默认为MemoryStore)是MemoryStore那么给出警告  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;production&#x27;</span> == env &amp;&amp; store <span class="keyword">instanceof</span> MemoryStore) &#123;  </span><br><span class="line">  <span class="built_in">console</span>.warn(warning);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// generates the new session  </span></span><br><span class="line"><span class="comment">//为用于指定的store添加一个方法generate，同时为这个方法传入req对象，在这个generate方法中为req指定了sessionID,session,session.cookie  </span></span><br><span class="line"><span class="comment">//如果用户传入的secure为auto,  </span></span><br><span class="line">store.generate = <span class="function"><span class="keyword">function</span>(<span class="params">req</span>)</span>&#123;  </span><br><span class="line">  req.sessionID = generateId(req);  </span><br><span class="line">  req.session = <span class="keyword">new</span> Session(req);  </span><br><span class="line">  req.session.cookie = <span class="keyword">new</span> Cookie(cookieOptions);  </span><br><span class="line">  <span class="comment">//用户指定的secure参数如果是auto,那么修改req.session.cookie的secure参数，并通过issecure来判断  </span></span><br><span class="line">  <span class="keyword">if</span> (cookieOptions.secure === <span class="string">&#x27;auto&#x27;</span>) &#123;  </span><br><span class="line">    req.session.cookie.secure = issecure(req, trustProxy);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看store是否实现了touch方法  </span></span><br><span class="line"><span class="keyword">var</span> storeImplementsTouch = <span class="keyword">typeof</span> store.touch === <span class="string">&#x27;function&#x27;</span>;  </span><br><span class="line"><span class="comment">//为store注册disconnect事件，在该事件中吧storeReady设置为false  </span></span><br><span class="line">store.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; storeReady = <span class="literal">false</span>; &#125;);  </span><br><span class="line"><span class="comment">//为stroe注册connect事件，把storeReady设置为true  </span></span><br><span class="line">store.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; storeReady = <span class="literal">true</span>; &#125;);  </span><br><span class="line">  <span class="comment">// expose store  </span></span><br><span class="line">  req.sessionStore = store;  </span><br></pre></td></tr></table></figure>
<p>我们知道这个store是用于保存session的地方，默认是一个MemoryStore，但是在生产环境下不建议使用MemoryStore,同时store有很多自定义的方法，如这里就为他添加了generate,connect,disconnect，当然也包含destroy方法。如果你对store感兴趣，可以看看下面这个通用的store具有的所有的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;  </span><br><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>).EventEmitter  </span><br><span class="line">    Session = <span class="built_in">require</span>(<span class="string">&#x27;./session&#x27;</span>)  </span><br><span class="line">    Cookie = <span class="built_in">require</span>(<span class="string">&#x27;./cookie&#x27;</span>)  </span><br><span class="line"><span class="keyword">var</span> Store = <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">Store</span>(<span class="params">options</span>)</span>&#123;&#125;;  </span><br><span class="line"><span class="comment">//这个Store实例是一个EventEmitter实例，也就是说Store实例最后还是一个EventEmitter实例对象  </span></span><br><span class="line">Store.prototype.__proto__ = EventEmitter.prototype;  </span><br><span class="line"> <span class="comment">//每一个store有一个默认的regenerate方法用于产生session  </span></span><br><span class="line">Store.prototype.regenerate = <span class="function"><span class="keyword">function</span>(<span class="params">req, fn</span>)</span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;  </span><br><span class="line">  <span class="comment">//regenerate底层调用的是destroy方法，第一个参数是req.sessionID,至于回调中的self.generate必须是对容器进行指定的  </span></span><br><span class="line">  <span class="built_in">this</span>.destroy(req.sessionID, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;  </span><br><span class="line">    self.generate(req);  </span><br><span class="line">    fn(err);<span class="comment">//最后回调fn  </span></span><br><span class="line">  &#125;);  </span><br><span class="line"><span class="comment">//调用这个store的destory方法,销毁req.sessionID，销毁成功后通过刚才的store的generate方法产生一个sessionID  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//通过指定的sid加载一个Session实例，然后触发函数fn(err,sess)  </span></span><br><span class="line">Store.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params">sid, fn</span>)</span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;  </span><br><span class="line">  <span class="comment">//最后调用的是Store的get方法  </span></span><br><span class="line">  <span class="built_in">this</span>.get(sid, <span class="function"><span class="keyword">function</span>(<span class="params">err, sess</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> fn(err);  </span><br><span class="line">    <span class="keyword">if</span> (!sess) <span class="keyword">return</span> fn();  </span><br><span class="line">    <span class="comment">//如果sess为空那么调用fn()方法  </span></span><br><span class="line">    <span class="keyword">var</span> req = &#123; <span class="attr">sessionID</span>: sid, <span class="attr">sessionStore</span>: self &#125;;  </span><br><span class="line">    <span class="comment">//调用createSession来完成的  </span></span><br><span class="line">    sess = self.createSession(req, sess);  </span><br><span class="line">    fn(<span class="literal">null</span>, sess);  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从一个JSON格式的sess中创建一个session实例，如sess=&#123;cookie:&#123;expires:xx,originalMaxAge:xxx&#125;&#125;  </span></span><br><span class="line">Store.prototype.createSession = <span class="function"><span class="keyword">function</span>(<span class="params">req, sess</span>)</span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> expires = sess.cookie.expires  </span><br><span class="line">    , orig = sess.cookie.originalMaxAge;  </span><br><span class="line">    <span class="comment">//创建session时候获取其中的cookie域下面的expires,originalMaxAge参数  </span></span><br><span class="line">  sess.cookie = <span class="keyword">new</span> Cookie(sess.cookie);  </span><br><span class="line">  <span class="comment">//更新session.cookie为一个Cookie实例而不再是一个&#123;&#125;对象了  </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;string&#x27;</span> == <span class="keyword">typeof</span> expires) sess.cookie.expires = <span class="keyword">new</span> <span class="built_in">Date</span>(expires);  </span><br><span class="line">  sess.cookie.originalMaxAge = orig;  </span><br><span class="line">  <span class="comment">//为新构建的cookie添加originalMaxAge属性  </span></span><br><span class="line">  req.session = <span class="keyword">new</span> Session(req, sess);  </span><br><span class="line">  <span class="comment">//创建一个session实例，其中传入的第一个参数是req,第二个参数是sess也就是我们刚才创建的那个Cookie实例，签名为sess=&#123;cookie:cookie对象&#125;  </span></span><br><span class="line">  <span class="keyword">return</span> req.session;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="unset"><a href="#unset" class="headerlink" title="unset:"></a>unset:</h3><p>对没有设置的req.session进行控制，通过delete或者设置为null。默认是keep,destory表示当回应结束后会销毁session，keep表示session会被保存。但是在请求中对session的修改会被忽略，也不会保存</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果用户指定了unset，但是unset不是destroy/keep，那么保存  </span></span><br><span class="line"> <span class="keyword">if</span> (options.unset &amp;&amp; options.unset !== <span class="string">&#x27;destroy&#x27;</span> &amp;&amp; options.unset !== <span class="string">&#x27;keep&#x27;</span>) &#123;  </span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;unset option must be &quot;destroy&quot; or &quot;keep&quot;&#x27;</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// <span class="doctag">TODO:</span> switch to &quot;destroy&quot; on next major  </span></span><br><span class="line"> <span class="keyword">var</span> unsetDestroy = options.unset === <span class="string">&#x27;destroy&#x27;</span>;  </span><br><span class="line">   <span class="comment">// determine if session should be destroyed  </span></span><br><span class="line">   <span class="comment">//sessionID还存在，但是req.session已经被销毁了  </span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">shouldDestroy</span>(<span class="params">req</span>) </span>&#123;  </span><br><span class="line">     <span class="comment">//  var unsetDestroy = options.unset === &#x27;destroy&#x27;;  </span></span><br><span class="line">     <span class="keyword">return</span> req.sessionID &amp;&amp; unsetDestroy &amp;&amp; req.session == <span class="literal">null</span>;  </span><br><span class="line">   &#125;  </span><br></pre></td></tr></table></figure>

<p>我们可以看到unset只能是默认的destroy或者keep，其用于判断是否应该销毁session，如果指定了unset方法为destrory,那么就会销毁session，也就是把req.session设置为null</p>
<p><strong>在版本1.5.0后，cookie-parser这个中间件已经不是express-session工作必须的了。这个模块可以直接对req/res中的cookie进行读写，使用cookie-parser可能导致一些问题，特别是当secret在两个模块之间存在不一致的时候。</strong></p>
<p>请把secure设置为true，这是明智的。但是这需要网站的支持，因为secure需要HTTPS的协议。如果设置了secure，但是你使用HTTP访问，那么cookie不会被设置，如果Node.js运行在代理上，同时使用了secure：true那么在express中需要设置”信任代理“。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express()  </span><br><span class="line">app.set(<span class="string">&#x27;trust proxy&#x27;</span>, <span class="number">1</span>) <span class="comment">// trust first proxy   </span></span><br><span class="line">app.use(session(&#123;  </span><br><span class="line">  secret: <span class="string">&#x27;keyboard cat&#x27;</span>,  </span><br><span class="line">  resave: <span class="literal">false</span>,  </span><br><span class="line">  saveUninitialized: <span class="literal">true</span>,  </span><br><span class="line">  cookie: &#123; <span class="attr">secure</span>: <span class="literal">true</span> &#125;  </span><br><span class="line">&#125;)) </span><br></pre></td></tr></table></figure>

<p>如果在生产环境下需要使用安全的cookit,同时在测试环境也要能够使用。那么可以使用express中的NODE_ENV参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express()  </span><br><span class="line"><span class="keyword">var</span> sess = &#123;  </span><br><span class="line">  secret: <span class="string">&#x27;keyboard cat&#x27;</span>,  </span><br><span class="line">  cookie: &#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (app.get(<span class="string">&#x27;env&#x27;</span>) === <span class="string">&#x27;production&#x27;</span>) &#123;  </span><br><span class="line">  app.set(<span class="string">&#x27;trust proxy&#x27;</span>, <span class="number">1</span>) <span class="comment">// trust first proxy   </span></span><br><span class="line">  sess.cookie.secure = <span class="literal">true</span> <span class="comment">// serve secure cookies   </span></span><br><span class="line">&#125;  </span><br><span class="line">app.use(session(sess))</span><br></pre></td></tr></table></figure>

<p><code>cookie</code>的<code>secure</code>属性可以设置为<code>auto</code>,那么会按照请求的方式来判断，如果是安全的就是secure。但是如果网站同时支持HTTP和HTTPS，这时候通过HTTPS设置的<code>cookie</code></p>
<p>对于HTTP是不可见的。这在express的<code>trust proxy</code>（简化开发和生产环境）正确设置的情况下特别有用。默认下：<code>cookie.maxAge为null</code><br>这意味着，浏览器关闭了这个<code>cookie</code>也就过期了。</p>
<h2 id="req-session"><a href="#req-session" class="headerlink" title="req.session:"></a>req.session:</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use the session middleware   </span></span><br><span class="line">app.use(session(&#123; <span class="attr">secret</span>: <span class="string">&#x27;keyboard cat&#x27;</span>, <span class="attr">cookie</span>: &#123; <span class="attr">maxAge</span>: <span class="number">60000</span> &#125;&#125;))  </span><br><span class="line"><span class="comment">// Access the session as req.session   </span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> sess = req.session<span class="comment">//用这个属性获取session中保存的数据，而且返回的JSON数据  </span></span><br><span class="line">  <span class="keyword">if</span> (sess.views) &#123;  </span><br><span class="line">    sess.views++  </span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)  </span><br><span class="line">    res.write(<span class="string">&#x27;&lt;p&gt;views: &#x27;</span> + sess.views + <span class="string">&#x27;&lt;/p&gt;&#x27;</span>)  </span><br><span class="line">    res.write(<span class="string">&#x27;&lt;p&gt;expires in: &#x27;</span> + (sess.cookie.maxAge / <span class="number">1000</span>) + <span class="string">&#x27;s&lt;/p&gt;&#x27;</span>)  </span><br><span class="line">    res.end()  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    sess.views = <span class="number">1</span>  </span><br><span class="line">    res.end(<span class="string">&#x27;welcome to the session demo. refresh!&#x27;</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure>

<p>其中req.session是一个session对象，格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">session:    </span><br><span class="line">  <span class="comment">//req.session域下面保存的是一个Session实例，其中有cookie表示是一个对象    </span></span><br><span class="line">   Session &#123;    </span><br><span class="line">    <span class="comment">//这里是req.session.cookie是一个Cookie实例    </span></span><br><span class="line">     cookie:    </span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,    </span><br><span class="line">        _expires: Fri May <span class="number">06</span> <span class="number">2016</span> <span class="number">15</span>:<span class="number">44</span>:<span class="number">48</span> GMT+<span class="number">0800</span> (中国标准时间),    </span><br><span class="line">        originalMaxAge: <span class="number">2591999960</span>,    </span><br><span class="line">        httpOnly: <span class="literal">true</span> &#125;,    </span><br><span class="line">       flash: &#123; <span class="attr">error</span>: [<span class="built_in">Object</span>]     </span><br><span class="line">     &#125;    </span><br><span class="line">  &#125;    </span><br></pre></td></tr></table></figure>

<h3 id="Session-regenerate"><a href="#Session-regenerate" class="headerlink" title="Session.regenerate()"></a>Session.regenerate()</h3><p>产生一个session，调用这个方法那么一个新的SID和Session实例就会被创建，同时放置在req.session中。但是第一步是销毁指定的session</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Store.prototype.regenerate = <span class="function"><span class="keyword">function</span>(<span class="params">req, fn</span>)</span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;  </span><br><span class="line">  <span class="comment">//regenerate底层调用的是destroy方法，第一个参数是req.sessionID,至于回调中的self.generate必须是对容器进行指定的  </span></span><br><span class="line">  <span class="built_in">this</span>.destroy(req.sessionID, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;  </span><br><span class="line">    self.generate(req);  </span><br><span class="line">    fn(err);<span class="comment">//最后回调fn  </span></span><br><span class="line">  &#125;);  </span><br><span class="line">  <span class="comment">//调用这个store的destory方法,销毁req.sessionID，销毁成功后通过刚才的store的generate方法产生一个sessionID  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时通用store提供的regenerate方法，但是generate方法一般要特定的库进行辅助：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">store.generate = <span class="function"><span class="keyword">function</span>(<span class="params">req</span>)</span>&#123;</span><br><span class="line">  req.sessionID = generateId(req);</span><br><span class="line">  req.session = <span class="keyword">new</span> Session(req);</span><br><span class="line">  req.session.cookie = <span class="keyword">new</span> Cookie(cookieOptions);  </span><br><span class="line">  <span class="comment">//用户指定的secure参数如果是auto,那么修改req.session.cookie的secure参数，并通过issecure来判断  </span></span><br><span class="line">  <span class="keyword">if</span> (cookieOptions.secure === <span class="string">&#x27;auto&#x27;</span>) &#123;</span><br><span class="line">    req.session.cookie.secure = issecure(req, trustProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时为express-session为store指定的generate方法</p>
<h3 id="session-destory"><a href="#session-destory" class="headerlink" title="session.destory()"></a>session.destory()</h3><p>销毁session，同时在req.session中被移除，但是在下一次请求的时候又会被创建</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   req.session.destroy(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;  </span><br><span class="line">  <span class="comment">// cannot access session here   </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="session-reload"><a href="#session-reload" class="headerlink" title="session.reload()"></a>session.reload()</h3><p>重新装载session中的数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    req.session.reload(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// session updated</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="session-save"><a href="#session-save" class="headerlink" title="session.save()"></a>session.save()</h3><p>把session中的数据重新保存到store中，用内存的内容去替换掉store中的内容。这个方法在HTTP的响应后自动被调用。如果session中的数据被改变了（这个行为可以通过中间件的很多的配置来改变），正因为如此这个方法一般不用显示调用。但是在长连接的websocket中这个方法一般需要手动调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   req.session.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// session saved   </span></span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure>
<h3 id="session-touch"><a href="#session-touch" class="headerlink" title="session.touch()"></a>session.touch()</h3><p>更新maxAge属性，一般不需要手动调用，因为session的中间件已经替你调用了。我们看看Session是如何实现这个方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Session</span>(<span class="params">req, data</span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;req&#x27;</span>, &#123; <span class="attr">value</span>: req &#125;);  </span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;id&#x27;</span>, &#123; <span class="attr">value</span>: req.sessionID &#125;);  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span> &amp;&amp; data !== <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="comment">// merge data into this, ignoring prototype properties  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> data) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (!(prop <span class="keyword">in</span> <span class="built_in">this</span>)) &#123;  </span><br><span class="line">        <span class="built_in">this</span>[prop] = data[prop]  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//重置&quot;.cookie.maxAge&quot;防止在session仍然存活的时候cookie已经过期了  </span></span><br><span class="line">defineMethod(Session.prototype, <span class="string">&#x27;touch&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">touch</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.resetMaxAge();  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="comment">//resetMaxAge方法，用于为cookie的maxAge指定为cookie的originalMaxAge  </span></span><br><span class="line">defineMethod(Session.prototype, <span class="string">&#x27;resetMaxAge&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">resetMaxAge</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">this</span>.cookie.maxAge = <span class="built_in">this</span>.cookie.originalMaxAge;  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>也就是把session的maxAge设置为构造Session对象的时候的初始值。</p>
<h3 id="req-session-id"><a href="#req-session-id" class="headerlink" title="req.session.id"></a>req.session.id</h3><p>唯一的，而且不会被改变。我们看看Session的构造函数就明白了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Session</span>(<span class="params">req, data</span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;req&#x27;</span>, &#123; <span class="attr">value</span>: req &#125;);  </span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;id&#x27;</span>, &#123; <span class="attr">value</span>: req.sessionID &#125;);  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span> &amp;&amp; data !== <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="comment">// merge data into this, ignoring prototype properties  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> data) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (!(prop <span class="keyword">in</span> <span class="built_in">this</span>)) &#123;  </span><br><span class="line">        <span class="built_in">this</span>[prop] = data[prop]  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其中defineProperty方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写了Object对象的defineProperty，其中defineProperty用于为这个对象指定一个函数，其中第二个参数是函数的名称，第三个是函数本身  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineMethod</span>(<span class="params">obj, name, fn</span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, name, &#123;  </span><br><span class="line">    configurable: <span class="literal">true</span>,  </span><br><span class="line">    enumerable: <span class="literal">false</span>,  </span><br><span class="line">    value: fn,  </span><br><span class="line">    writable: <span class="literal">true</span>  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>其中session的id值就是req.sessionID属性而且enumerable为false,所以在控制台是打印不出来的</p>
<h3 id="req-session-cookie"><a href="#req-session-cookie" class="headerlink" title="req.session.cookie"></a>req.session.cookie</h3><p>每一个session都有一个cookie对象，因此在每一次请求的时候你都可以改变session的cookie。如我们可以通过req.session.cookie.expires设置为false，这时候浏览器关闭cookie就不存在了</p>
<p><strong>Cookie.maxAge</strong>：<br>   req.session.cookie.maxAge返回这个cookie剩余的毫秒数，当然我们也可以通过设置expires来完成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hour = <span class="number">3600000</span>  </span><br><span class="line">  req.session.cookie.expires = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + hour)  </span><br><span class="line">  req.session.cookie.maxAge = hour<span class="comment">//和上面的expires等价  </span></span><br></pre></td></tr></table></figure>
<p>当maxAge设置为60000，也就是一分钟，这时候如果已经过去了30s，那么<code>maxAge</code>就会返回<code>30000</code>（不过要等到当前请求结束）。如果这时候我们调用<code>req.session.touch()</code>，那么<code>req.session.maxAge</code>就成了初始值了<code>60000</code>了</p>
<h3 id="req-sessionID"><a href="#req-sessionID" class="headerlink" title="req.sessionID"></a>req.sessionID</h3><p>只读的属性。每一个<code>session store</code>必须是一个<code>EventEmitter</code>对象，同时要实现特定的方法。</p>
<h2 id="MemoryStore"><a href="#MemoryStore" class="headerlink" title="MemoryStore"></a>MemoryStore</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MemoryStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Store.call(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">this</span>.sessions = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了Store中的所有的原型属性</span></span><br><span class="line">util.inherits(MemoryStore, Store)</span><br></pre></td></tr></table></figure>
<p>也就是说MemoryStore继承了通用的Store的所有的属性和方法，如regenerate,load,createSession，当然也实现了很多自己的方法如all,clear,destroy,get,length,set,touch等</p>
<h3 id="required方法"><a href="#required方法" class="headerlink" title="required方法"></a>required方法</h3><p>在这个store上一定会调用的方法</p>
<h3 id="Recommended方法"><a href="#Recommended方法" class="headerlink" title="Recommended方法"></a>Recommended方法</h3><p>表示如果有这个方法那么在这个store上就会调用。Optional方法表示不会调用，但是为了给用户一个统一的store!</p>
<h3 id="store-destroy-sid-callback"><a href="#store-destroy-sid-callback" class="headerlink" title="store.destroy(sid, callback)"></a>store.destroy(sid, callback)</h3><p>必须的方法。通过sessionID来销毁session，如果session已经被销毁，那么回调函数被调用，同时传入一个error对象</p>
<h3 id="store-get-sid-callback"><a href="#store-get-sid-callback" class="headerlink" title="store.get(sid, callback)"></a>store.get(sid, callback)</h3><p>必须的方法。通过sessionID从store中获取session。回调函数是callback(err,session)。如果session存在那么第二个参数就是session，否则第二个参数就是null/undefined。如果error.code===”ENOENT”那么回调为callback(null,null)</p>
<h3 id="store-set-sid-session-callback"><a href="#store-set-sid-session-callback" class="headerlink" title="store.set(sid, session, callback)"></a>store.set(sid, session, callback)</h3><p>必须的方法。如果被成功设置了那么回调为callback(error)</p>
<h3 id="store-touch-sid-session-callback"><a href="#store-touch-sid-session-callback" class="headerlink" title="store.touch(sid, session, callback)"></a>store.touch(sid, session, callback)</h3><p>推荐的方法。通过一个指定的sid和session对象去”接触“这个session.如果接触到了那么回调为callback(error)。session store用这个方法去删除那些空闲的session。同时这个方法也会通知session store指定的session是活动态的。MemoryStore实现了这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过指定的sessionId获取当前的session对象，然后把这个对象的cookie更新为新的session对应的cookie，同时sessions中的当前session也进行更新（包括过期时间等）  </span></span><br><span class="line">MemoryStore.prototype.touch = <span class="function"><span class="keyword">function</span> <span class="title">touch</span>(<span class="params">sessionId, session, callback</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> currentSession = getSession.call(<span class="built_in">this</span>, sessionId)  </span><br><span class="line">  <span class="keyword">if</span> (currentSession) &#123;</span><br><span class="line">    <span class="comment">// update expiration</span></span><br><span class="line">    currentSession.cookie = session.cookie  </span><br><span class="line">    <span class="built_in">this</span>.sessions[sessionId] = <span class="built_in">JSON</span>.stringify(currentSession)</span><br><span class="line">  &#125;</span><br><span class="line">  callback &amp;&amp; defer(callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="store-length-callback"><a href="#store-length-callback" class="headerlink" title="store.length(callback)"></a>store.length(callback)</h3><p> 可选的方法。获取store中所有的session的个数，回调函数为callback(error,length)</p>
<h3 id="store-clear-callback"><a href="#store-clear-callback" class="headerlink" title="store.clear(callback)"></a>store.clear(callback)</h3><p> 可选的方法，从store中吧所有的session都删除，回调函数为callback(err)</p>
<h3 id="store-all-callback"><a href="#store-all-callback" class="headerlink" title="store.all(callback)"></a>store.all(callback)</h3><p> 可选的方法。以一个数组的方法获取store中的sessions。callback(error,sessions)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">session(&#123;  </span><br><span class="line">    secret: settings.cookieSecret,  </span><br><span class="line">    <span class="comment">//blog=s%3AisA3_M-Vso0L_gHvUnPb8Kw9DohpCCBJ.OV7p42pL91uM3jueaJATpZdlIj%2BilgxWoD8HmBSLUSo  </span></span><br><span class="line">    <span class="comment">//其中secret如果是一个string，那么就是用这个string对sessionID对应的cookie进行签名，如果是一个数组那么只有第一个用于签名，其他用于浏览器请求后的验证  </span></span><br><span class="line">    key: settings.db,  </span><br><span class="line">    <span class="comment">//设置的cookie的名字，从上面可以看到这里指定的是blog，所以浏览器的请求中可以看到这里的sessionID已经不是sessionID了，而是这里的blog  </span></span><br><span class="line">    name:&quot;qinliang&quot;,//name的优先级比key要高，如果同时设置了那么就是按照name来制定的  </span><br><span class="line">    <span class="comment">//没有name时候response中为：set-cookie:blog=s%3A6OJEWycwVMmTGXcZqawrW0HNLOTJkYKm.0Slax72TMfW%2B4Tiit3Ox7NAj5S6rPWvMUr6sY02l0DE; Path=/; Expires=Thu, 28 Apr 2016 10:47:13 GMT; HttpOnly  </span></span><br><span class="line">    <span class="comment">//当有name的时候resopnse中：set-cookie:qinliang=s%3ABDOjujVhV0DH9Atax_gl4DgZ4-1RGvjQ.OeUddoRalzB4iSmUHcE8oMziad4Ig7jUT1REzGcYcdg; Path=/; Expires=Thu, 28 Apr 2016 10:48:26 GMT; HttpOnly  </span></span><br><span class="line">    resave:true,//没有实现touch方法，同时也设置了session的过期时间为30天  </span><br><span class="line">    rolling:true,//如果设置了rolling为true，同时saveUninitialized为true，那么每一个请求都会发送没有初始化的session！  </span><br><span class="line">    saveUninitialized:false,//设置为true,存储空间浪费，不允许权限管理  </span><br><span class="line">    cookie:   </span><br><span class="line">    &#123;  </span><br><span class="line">        maxAge: 1000 * 60 * 60 * 24 * 30  </span><br><span class="line">     &#125;,  </span><br><span class="line">    <span class="comment">//cookie里面全部的设置都是对于sessionID的属性的设置，默认的属性为&#123; path: &#x27;/&#x27;, httpOnly: true, secure: false, maxAge: null &#125;.  </span></span><br><span class="line">    <span class="comment">//所以最后我们保存到数据库里面的信息就是：&#123;&quot;cookie&quot;:&#123;&quot;originalMaxAge&quot;:2592000000,&quot;expires&quot;:&quot;2016-04-27T02:30:51.713Z&quot;,&quot;httpOnly&quot;:true,&quot;path&quot;:&quot;/&quot;&#125;,&quot;flash&quot;:&#123;&#125;&#125;  </span></span><br><span class="line">    store: new MongoStore(&#123;  </span><br><span class="line">      db: settings.db,  </span><br><span class="line">      host: settings.host,  </span><br><span class="line">      port: settings.port  </span><br><span class="line">    &#125;)  </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
<h2 id="从源码的角度来分析配置项"><a href="#从源码的角度来分析配置项" class="headerlink" title="从源码的角度来分析配置项"></a>从源码的角度来分析配置项</h2><h3 id="这里面的secret到底有什么用呢"><a href="#这里面的secret到底有什么用呢" class="headerlink" title="这里面的secret到底有什么用呢?"></a>这里面的secret到底有什么用呢?</h3><p>首先我建议你读一下Cookie-Parser是如何解析签名后的cookie的(同时对cookie和cookie-signature进行说明)，然后我们看看这个express-session到底是如何做的?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unsigncookie</span>(<span class="params">val, secrets</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; secrets.length; i++) &#123;  </span><br><span class="line">    <span class="keyword">var</span> result = signature.unsign(val, secrets[i]);  </span><br><span class="line">    <span class="keyword">if</span> (result !== <span class="literal">false</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这里是通过cookie-signature进行的解密操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var cookieId = req.sessionID = getcookie(req, name, secrets);  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getcookie</span>(<span class="params">req, name, secrets</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> header = req.headers.cookie;  </span><br><span class="line">  <span class="keyword">var</span> raw;  </span><br><span class="line">  <span class="keyword">var</span> val;  </span><br><span class="line">  <span class="comment">// read from cookie header  </span></span><br><span class="line">  <span class="keyword">if</span> (header) &#123;  </span><br><span class="line">    <span class="keyword">var</span> cookies = cookie.parse(header);  </span><br><span class="line">    raw = cookies[name];  </span><br><span class="line">    <span class="keyword">if</span> (raw) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (raw.substr(<span class="number">0</span>, <span class="number">2</span>) === <span class="string">&#x27;s:&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//切割掉前面的字符&quot;s:&quot;!  </span></span><br><span class="line">        val = unsigncookie(raw.slice(<span class="number">2</span>), secrets);  </span><br><span class="line">        <span class="comment">//val表示false意味着客户端传递过来的cookie被篡改了!  </span></span><br><span class="line">        <span class="keyword">if</span> (val === <span class="literal">false</span>) &#123;</span><br><span class="line">          debug(<span class="string">&#x27;cookie signature invalid&#x27;</span>);  </span><br><span class="line">          val = <span class="literal">undefined</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        debug(<span class="string">&#x27;cookie unsigned&#x27;</span>)  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// back-compat read from cookieParser() signedCookies data  </span></span><br><span class="line">  <span class="comment">//如果从req.headers.cookie中没有读取到session ID的数据，那么就去cookie parser的req.signedCookies中读取  </span></span><br><span class="line">  <span class="keyword">if</span> (!val &amp;&amp; req.signedCookies) &#123;</span><br><span class="line">    val = req.signedCookies[name];</span><br><span class="line">    <span class="keyword">if</span> (val) &#123;</span><br><span class="line">      deprecate(<span class="string">&#x27;cookie should be available in req.headers.cookie&#x27;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// back-compat read from cookieParser() cookies data  </span></span><br><span class="line">  <span class="comment">//如果req.signedCookies中也没有获取到数据那么直接从req.cookies中获取</span></span><br><span class="line">  <span class="keyword">if</span> (!val &amp;&amp; req.cookies) &#123;</span><br><span class="line">    raw = req.cookies[name];</span><br><span class="line">    <span class="keyword">if</span> (raw) &#123;</span><br><span class="line">      <span class="keyword">if</span> (raw.substr(<span class="number">0</span>, <span class="number">2</span>) === <span class="string">&#x27;s:&#x27;</span>) &#123;</span><br><span class="line">        val = unsigncookie(raw.slice(<span class="number">2</span>), secrets);</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">          deprecate(<span class="string">&#x27;cookie should be available in req.headers.cookie&#x27;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (val === <span class="literal">false</span>) &#123;</span><br><span class="line">          debug(<span class="string">&#x27;cookie signature invalid&#x27;</span>);</span><br><span class="line">          val = <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debug(<span class="string">&#x27;cookie unsigned&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这里我们很容易看到对于session ID的获取就是通过上面的secret进行签名的，如果获取到的sessionID已经被修改过，那么表示这个session已经无效了。首先是从req.headers.cookie中获取，然后从req.signedCookies中获取，最后从req.cookies中进行获取!</p>
<h3 id="cookie字段有什么用的"><a href="#cookie字段有什么用的" class="headerlink" title="cookie字段有什么用的?"></a>cookie字段有什么用的?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Session = <span class="built_in">require</span>(<span class="string">&#x27;./session/session&#x27;</span>)</span><br><span class="line">  , MemoryStore = <span class="built_in">require</span>(<span class="string">&#x27;./session/memory&#x27;</span>)</span><br><span class="line">  , Cookie = <span class="built_in">require</span>(<span class="string">&#x27;./session/cookie&#x27;</span>)</span><br><span class="line">  , Store = <span class="built_in">require</span>(<span class="string">&#x27;./session/store&#x27;</span>)</span><br><span class="line"> <span class="keyword">var</span> cookieOptions = options.cookie || &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateSessionId</span>(<span class="params">sess</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uid(<span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// generates the new session  </span></span><br><span class="line">  store.generate = <span class="function"><span class="keyword">function</span>(<span class="params">req</span>)</span>&#123;  </span><br><span class="line">    req.sessionID = generateId(req);<span class="comment">//产生一个sessionID  </span></span><br><span class="line">    req.session = <span class="keyword">new</span> Session(req);<span class="comment">//产生一个Session  </span></span><br><span class="line">    req.session.cookie = <span class="keyword">new</span> Cookie(cookieOptions);<span class="comment">//在req.session对象的cookie域下面保存的是一个Cookie对象  </span></span><br><span class="line">    <span class="keyword">if</span> (cookieOptions.secure === <span class="string">&#x27;auto&#x27;</span>) &#123;  </span><br><span class="line">      req.session.cookie.secure = issecure(req, trustProxy);  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>我们看看cookie字段在哪里被处理了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cookie = <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">Cookie</span>(<span class="params">options</span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">this</span>.path = <span class="string">&#x27;/&#x27;</span>;  </span><br><span class="line">  <span class="built_in">this</span>.maxAge = <span class="literal">null</span>;  </span><br><span class="line">  <span class="built_in">this</span>.httpOnly = <span class="literal">true</span>;  </span><br><span class="line">  <span class="comment">//最终的this就是这个新创建的Cookie具有这些默认的属性，同时还具有用户自己传入的options参数，如用户传入的var cookieOptions = options.cookie || &#123;&#125;;  </span></span><br><span class="line">  <span class="comment">//也就是用户传入的options.cookie属性  </span></span><br><span class="line">  <span class="keyword">if</span> (options) merge(<span class="built_in">this</span>, options);  </span><br><span class="line">  <span class="comment">/*这个utils.merge的源码只有一句话： </span></span><br><span class="line"><span class="comment">  exports = module.exports = function(a, b)&#123; </span></span><br><span class="line"><span class="comment">  if (a &amp;&amp; b) &#123; </span></span><br><span class="line"><span class="comment">    for (var key in b) &#123; </span></span><br><span class="line"><span class="comment">      a[key] = b[key]; </span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">  &#125; </span></span><br><span class="line"><span class="comment">  return a; </span></span><br><span class="line"><span class="comment">&#125;;*/</span>  </span><br><span class="line">  <span class="built_in">this</span>.originalMaxAge = <span class="literal">undefined</span> == <span class="built_in">this</span>.originalMaxAge  </span><br><span class="line">    ? <span class="built_in">this</span>.maxAge  </span><br><span class="line">    : <span class="built_in">this</span>.originalMaxAge;  </span><br><span class="line">  <span class="comment">//默认的originalMaxAge就是this.maxAge也就是null,如果指定了originalMaxAge那么就是用户指定的值  </span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>也就是说我们在session中传入的cookie参数也成为新创建的cookie的一个属性了，而且这个这个新创建的cookie被保存到req.session.cookie下。</p>
<p>本章转自<a target="_blank" rel="noopener" href="http://blog.csdn.net/liangklfang/article/details/50998959">高山上的鱼</a>的博客</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/node-js/" rel="tag"># node.js</a>
              <a href="/tags/express/" rel="tag"># express</a>
              <a href="/tags/session/" rel="tag"># session</a>
              <a href="/tags/cookie/" rel="tag"># cookie</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/10/29/mongoDB/" rel="prev" title="mongoDB">
      <i class="fa fa-chevron-left"></i> mongoDB
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/10/31/connect-flash/" rel="next" title="connect-flash">
      connect-flash <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Session%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">Session是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E6%97%B6%E4%BF%B1%E8%BF%9B"><span class="nav-number">1.1.</span> <span class="nav-text">与时俱进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.</span> <span class="nav-text">session 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81session"><span class="nav-number">1.3.</span> <span class="nav-text">为什么需要session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session-%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%90%84%E4%B8%AA%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E9%85%8D%E5%90%88"><span class="nav-number">1.4.</span> <span class="nav-text">session 存储使用中各个中间件的配合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#express%E6%A1%86%E6%9E%B6%E4%B9%8Bsession"><span class="nav-number">2.</span> <span class="nav-text">express框架之session</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#session%E4%B9%8B%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%EF%BC%88%E6%9C%AC%E5%B0%8F%E7%BB%93%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%AD%A3%E7%A1%AE%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">session之内存存储（本小结不一定正确）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#express-session%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">express-session中间件的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session%E5%86%85%E5%AE%B9%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%9B%B4%E6%94%B9-%E5%BA%94%E7%94%A8%E5%88%B0express%E4%B8%AD"><span class="nav-number">2.3.</span> <span class="nav-text">session内容的存储和更改(应用到express中)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session%E4%B9%8Bmongoose%E5%AD%98%E5%82%A8"><span class="nav-number">2.4.</span> <span class="nav-text">session之mongoose存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.5.</span> <span class="nav-text">session的生命周期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#express-session%E9%83%A8%E5%88%86%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91"><span class="nav-number">3.</span> <span class="nav-text">express-session部分文档翻译</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="nav-number">3.1.</span> <span class="nav-text">接受的参数：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie"><span class="nav-number">3.1.1.</span> <span class="nav-text">cookie:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#genid"><span class="nav-number">3.1.2.</span> <span class="nav-text">genid:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#name"><span class="nav-number">3.1.3.</span> <span class="nav-text">name:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resave"><span class="nav-number">3.1.4.</span> <span class="nav-text">resave:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rolling"><span class="nav-number">3.1.5.</span> <span class="nav-text">rolling:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#saveUninitialized"><span class="nav-number">3.1.6.</span> <span class="nav-text">saveUninitialized:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#secret"><span class="nav-number">3.1.7.</span> <span class="nav-text">secret:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E8%BF%B0secret%E5%8F%82%E6%95%B0%E5%8F%AF%E7%94%A8%E4%BA%8E%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.7.1.</span> <span class="nav-text">上述secret参数可用于的场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#getcookie%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E4%BB%8E%E8%AF%B7%E6%B1%82%E4%B8%AD%E8%8E%B7%E5%8F%96sessionID%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%AF%86%EF%BC%8C%E4%BD%9C%E4%B8%BA%E7%A7%98%E9%92%A5%E3%80%82"><span class="nav-number">3.1.7.1.1.</span> <span class="nav-text">getcookie方法用于从请求中获取sessionID进行解密，作为秘钥。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setcookie%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E5%AF%B9sessionID%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E7%A7%98%E9%92%A5%E8%BF%9B%E8%A1%8C%E7%AD%BE%E5%90%8D"><span class="nav-number">3.1.7.1.2.</span> <span class="nav-text">setcookie方法用于对sessionID用指定的秘钥进行签名</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store"><span class="nav-number">3.1.8.</span> <span class="nav-text">store:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unset"><span class="nav-number">3.1.9.</span> <span class="nav-text">unset:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#req-session"><span class="nav-number">3.2.</span> <span class="nav-text">req.session:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Session-regenerate"><span class="nav-number">3.2.1.</span> <span class="nav-text">Session.regenerate()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session-destory"><span class="nav-number">3.2.2.</span> <span class="nav-text">session.destory()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session-reload"><span class="nav-number">3.2.3.</span> <span class="nav-text">session.reload()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session-save"><span class="nav-number">3.2.4.</span> <span class="nav-text">session.save()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session-touch"><span class="nav-number">3.2.5.</span> <span class="nav-text">session.touch()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#req-session-id"><span class="nav-number">3.2.6.</span> <span class="nav-text">req.session.id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#req-session-cookie"><span class="nav-number">3.2.7.</span> <span class="nav-text">req.session.cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#req-sessionID"><span class="nav-number">3.2.8.</span> <span class="nav-text">req.sessionID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MemoryStore"><span class="nav-number">3.3.</span> <span class="nav-text">MemoryStore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#required%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.1.</span> <span class="nav-text">required方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Recommended%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.2.</span> <span class="nav-text">Recommended方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store-destroy-sid-callback"><span class="nav-number">3.3.3.</span> <span class="nav-text">store.destroy(sid, callback)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store-get-sid-callback"><span class="nav-number">3.3.4.</span> <span class="nav-text">store.get(sid, callback)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store-set-sid-session-callback"><span class="nav-number">3.3.5.</span> <span class="nav-text">store.set(sid, session, callback)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store-touch-sid-session-callback"><span class="nav-number">3.3.6.</span> <span class="nav-text">store.touch(sid, session, callback)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store-length-callback"><span class="nav-number">3.3.7.</span> <span class="nav-text">store.length(callback)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store-clear-callback"><span class="nav-number">3.3.8.</span> <span class="nav-text">store.clear(callback)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store-all-callback"><span class="nav-number">3.3.9.</span> <span class="nav-text">store.all(callback)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E5%88%86%E6%9E%90%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="nav-number">3.4.</span> <span class="nav-text">从源码的角度来分析配置项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E9%87%8C%E9%9D%A2%E7%9A%84secret%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%91%A2"><span class="nav-number">3.4.1.</span> <span class="nav-text">这里面的secret到底有什么用呢?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie%E5%AD%97%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84"><span class="nav-number">3.4.2.</span> <span class="nav-text">cookie字段有什么用的?</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xuefeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuefeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
